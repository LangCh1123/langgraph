interactions:
- request:
    body: '{"post":[{"id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","start_time":"2024-09-19T18:20:49.020831+00:00","end_time":"2024-09-19T18:20:49.021706+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.020831+00:00"},{"name":"end","time":"2024-09-19T18:20:49.021706+00:00"}],"reference_example_id":null,"parent_run_id":null,"tags":[],"trace_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","dotted_order":"20240919T182049020831Z4c57d2ad-30ab-4dbb-9e27-91ea1605a666","outputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"session_name":"default","name":"LangGraphUpdateState","inputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"run_type":"chain"},{"id":"4a29815d-adc6-4add-9a72-f17a79d2bdf0","start_time":"2024-09-19T18:20:49.021047+00:00","end_time":"2024-09-19T18:20:49.021287+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.021047+00:00"},{"name":"end","time":"2024-09-19T18:20:49.021287+00:00"}],"reference_example_id":null,"parent_run_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","tags":["seq:step:1","langsmith:hidden"],"trace_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","dotted_order":"20240919T182049020831Z4c57d2ad-30ab-4dbb-9e27-91ea1605a666.20240919T182049021047Z4a29815d-adc6-4add-9a72-f17a79d2bdf0","outputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"session_name":"default","name":"ChannelWrite<evaluate,candidate,examples,messages,test_cases,runtime_limit,status>","inputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"run_type":"chain"},{"id":"67d57c15-8da9-4657-a1f8-dbc04ed69085","start_time":"2024-09-19T18:20:49.021495+00:00","end_time":"2024-09-19T18:20:49.021655+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.021495+00:00"},{"name":"end","time":"2024-09-19T18:20:49.021655+00:00"}],"reference_example_id":null,"parent_run_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","tags":["seq:step:2"],"trace_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","dotted_order":"20240919T182049020831Z4c57d2ad-30ab-4dbb-9e27-91ea1605a666.20240919T182049021495Z67d57c15-8da9-4657-a1f8-dbc04ed69085","outputs":{"output":"solve"},"session_name":"default","name":"control_edge","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"},{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","additional_kwargs":{},"response_metadata":{},"type":"human","id":"fc1135fe-45a9-4264-9cf1-99db01aeb146","example":false}],"test_cases":[{"inputs":"4
      3 3\n2 4\n3 1\n4 2\n1 3\nL L R\n","outputs":"4\n"},{"inputs":"50 10 10\n6 4\n42
      48\n2 41\n40 8\n17 29\n28 7\n34 46\n4 9\n36 27\n9 37\n28 32\n22 10\n30 48\n16
      31\n11 33\n36 3\n14 39\n45 5\n46 13\n34 23\n29 6\n3 38\n44 30\n21 15\n41 50\n12
      9\n30 24\n45 6\n19 39\n11 14\n2 46\n39 22\n14 9\n48 43\n16 50\n30 9\n32 2\n25
      24\n3 38\n11 24\n25 3\n4 19\n9 22\n10 19\n37 13\n14 25\n36 29\n33 34\n21 48\n33
      2\nL L R L L R R R R R\n","outputs":"50\n"},{"inputs":"100 20 100\n39 28\n29
      65\n8 76\n23 97\n78 21\n100 63\n95 59\n59 63\n31 16\n83 82\n95 53\n52 13\n50
      2\n29 46\n52 69\n57 91\n96 85\n7 4\n13 29\n52 42\n1 51\n4 95\n62 14\n9 92\n29
      92\n44 29\n87 45\n31 15\n91 34\n36 47\n84 82\n86 48\n11 38\n89 11\n40 44\n58
      1\n57 18\n45 37\n9 70\n12 5\n50 98\n49 32\n65 39\n66 100\n38 41\n30 73\n23 68\n72
      33\n5 60\n95 44\n55 4\n97 11\n22 41\n47 82\n62 58\n86 11\n8 35\n43 72\n25 8\n23
      14\n100 4\n86 22\n71 9\n6 27\n68 53\n23 22\n8 19\n84 81\n59 31\n63 72\n40 48\n82
      99\n34 76\n22 11\n35 44\n24 35\n48 62\n56 18\n70 14\n45 90\n66 19\n63 73\n37
      47\n54 47\n29 16\n18 68\n15 51\n19 1\n27 40\n11 61\n84 86\n95 83\n47 3\n100
      17\n16 96\n58 81\n14 20\n5 2\n66 58\n48 94\nR R L L L L L L R L L L R R L L
      R L L L\n","outputs":"84\n"},{"inputs":"500 50 1000\n308 171\n115 440\n166 2\n202
      52\n111 430\n470 467\n289 254\n87 79\n486 167\n335 452\n346 435\n249 459\n34
      10\n497 299\n139 123\n162 446\n293 276\n385 458\n130 439\n361 92\n368 183\n410
      156\n436 496\n235 274\n163 421\n225 8\n355 473\n318 389\n482 314\n187 121\n436
      201\n418 81\n328 155\n38 457\n93 251\n400 460\n433 310\n468 220\n305 54\n493
      319\n474 217\n326 328\n42 143\n216 23\n308 255\n495 244\n307 413\n324 134\n419
      213\n443 11\n315 194\n322 99\n3 141\n319 160\n194 311\n478 167\n380 156\n347
      421\n298 414\n443 106\n20 290\n201 326\n202 376\n460 472\n440 254\n482 107\n447
      155\n205 302\n296 23\n313 489\n334 290\n8 213\n297 354\n485 447\n119 279\n52
      139\n68 104\n464 121\n331 275\n92 270\n28 425\n376 327\n80 81\n128 375\n455
      440\n215 288\n81 222\n352 378\n427 188\n176 46\n467 227\n184 34\n182 499\n7
      364\n274 98\n133 153\n23 361\n479 102\n293 458\n328 99\n397 42\n239 330\n116
      90\n59 42\n278 234\n439 96\n312 474\n129 345\n473 135\n208 98\n85 192\n250 107\n404
      229\n60 48\n186 387\n147 435\n280 385\n116 395\n326 26\n289 103\n259 79\n50
      422\n53 179\n266 377\n165 473\n474 101\n164 223\n59 420\n303 118\n467 341\n356
      113\n127 488\n497 242\n234 323\n267 22\n277 377\n453 327\n298 5\n357 63\n233
      373\n387 206\n474 402\n428 384\n321 83\n354 288\n423 209\n400 49\n48 249\n142
      282\n71 408\n155 199\n136 107\n377 433\n111 233\n347 343\n458 233\n400 431\n486
      180\n166 307\n262 19\n94 184\n80 345\n84 127\n445 225\n408 15\n484 63\n66 119\n169
      442\n51 132\n27 397\n326 484\n481 78\n414 466\n257 79\n124 18\n450 217\n53 29\n414
      136\n155 358\n212 415\n225 195\n329 290\n313 349\n83 215\n480 109\n463 158\n92
      295\n87 357\n260 343\n288 384\n212 237\n452 264\n265 217\n251 271\n75 314\n185
      151\n8 13\n292 172\n362 374\n238 193\n335 200\n494 288\n135 105\n482 422\n340
      193\n10 144\n308 274\n212 58\n396 138\n371 81\n288 230\n445 431\n253 158\n305
      490\n203 491\n41 404\n268 386\n44 402\n491 25\n323 182\n70 332\n177 377\n457
      389\n287 353\n26 9\n285 314\n91 229\n244 343\n239 400\n333 441\n242 225\n344
      10\n111 239\n411 453\n116 86\n134 185\n269 311\n413 226\n51 199\n430 76\n60
      66\n241 150\n146 337\n492 384\n88 176\n324 330\n401 20\n339 11\n258 101\n463
      373\n186 448\n409 307\n110 322\n32 160\n372 313\n88 431\n378 328\n80 23\n16
      72\n259 104\n99 82\n433 499\n453 123\n361 211\n75 323\n435 113\n271 196\n419
      232\n17 302\n392 388\n466 479\n319 343\n158 250\n217 174\n321 475\n277 272\n409
      61\n270 361\n35 131\n423 461\n305 210\n73 427\n257 491\n159 125\n144 402\n12
      109\n232 182\n303 389\n284 372\n62 104\n346 190\n227 106\n102 497\n319 136\n479
      241\n97 135\n302 21\n62 58\n364 72\n182 7\n473 46\n468 204\n79 270\n444 362\n141
      6\n318 339\n47 44\n296 149\n392 114\n136 370\n207 84\n357 360\n105 418\n418
      468\n341 451\n326 165\n348 293\n368 427\n415 163\n140 407\n168 309\n245 67\n353
      393\n215 244\n6 350\n466 212\n434 174\n424 390\n91 341\n357 283\n143 34\n447
      491\n179 166\n269 93\n328 260\n499 348\n69 96\n414 273\n488 480\n368 345\n329
      333\n409 114\n6 332\n3 448\n24 211\n82 18\n97 28\n360 275\n45 128\n367 373\n240
      217\n220 160\n164 485\n432 3\n464 299\n348 144\n484 108\n110 341\n439 464\n141
      314\n175 222\n331 123\n102 191\n397 146\n170 115\n18 409\n183 89\n68 347\n73
      499\n201 388\n150 400\n32 133\n7 141\n473 297\n104 113\n110 130\n335 441\n252
      436\n131 500\n81 300\n114 451\n61 149\n391 480\n495 464\n479 47\n203 480\n447
      234\n112 453\n226 84\n102 182\n49 211\n163 383\n3 267\n170 133\n266 102\n285
      232\n404 197\n380 295\n176 226\n110 6\n272 312\n485 70\n398 96\n375 475\n32
      476\n156 80\n186 171\n314 41\n437 335\n173 54\n288 309\n285 192\n5 16\n486 181\n241
      447\n38 365\n258 23\n434 7\n470 308\n482 1\n135 489\n432 321\n11 97\n213 447\n431
      385\n353 219\n46 489\n262 402\n5 99\n434 97\n45 472\n313 154\n494 247\n13 315\n406
      494\n168 41\n334 99\n213 345\n48 425\n143 330\n161 347\n400 58\n336 161\n460
      192\n111 393\n140 155\n364 453\n161 209\n51 173\n376 456\n18 43\n348 203\n493
      412\n47 40\n336 42\n370 349\n388 269\n406 75\n282 217\n266 392\n110 406\n399
      325\n358 59\n386 260\n83 261\n215 100\n155 415\n154 147\n326 201\n39 14\n94
      260\n214 481\n28 471\n56 161\n188 173\n53 149\n78 451\n473 287\n361 210\n46
      443\n470 113\n394 476\n379 399\n123 56\n99 13\n69 44\n272 134\n377 151\n105
      432\n312 292\n456 216\n440 34\n18 264\n172 378\n474 70\n172 295\n182 417\n271
      412\n315 245\n467 266\nR L R L R R L R L R L L L R R R R L L L R R L L R L R
      L L L R L R R R R L R L R R R L R L L R L L R\n","outputs":"98\n"},{"inputs":"500
      50 100000\n232 214\n427 64\n280 272\n267 102\n27 177\n431 212\n207 151\n284
      14\n246 371\n61 59\n195 134\n341 129\n169 398\n224 250\n173 395\n317 256\n109
      96\n171 240\n367 437\n341 393\n465 124\n105 23\n274 388\n36 20\n110 96\n430
      157\n82 270\n285 250\n20 360\n352 192\n255 20\n448 215\n115 118\n454 482\n407
      146\n226 223\n269 182\n246 395\n70 281\n414 31\n229 195\n187 310\n464 324\n411
      483\n35 262\n27 141\n282 474\n355 248\n443 308\n229 201\n454 307\n424 74\n488
      169\n468 409\n301 233\n440 29\n427 478\n190 243\n153 101\n77 188\n362 103\n328
      495\n76 183\n243 371\n342 323\n71 147\n129 494\n221 117\n14 40\n25 167\n273
      316\n47 51\n294 237\n293 446\n337 370\n485 50\n472 313\n45 400\n347 139\n270
      40\n461 192\n187 442\n38 259\n410 51\n298 434\n69 422\n250 116\n473 395\n352
      117\n340 188\n486 325\n89 310\n489 485\n209 335\n123 330\n374 436\n373 412\n377
      410\n22 286\n313 320\n71 381\n93 172\n348 417\n66 199\n34 258\n238 371\n434
      327\n180 422\n311 240\n108 286\n421 333\n221 294\n245 449\n55 266\n86 219\n437
      8\n452 382\n180 299\n298 245\n350 331\n354 87\n202 287\n265 233\n208 428\n473
      167\n213 245\n500 285\n390 96\n85 445\n361 22\n15 150\n29 466\n31 208\n117 328\n305
      466\n11 10\n404 64\n297 169\n296 356\n448 120\n23 160\n365 22\n296 254\n469
      232\n50 181\n253 65\n330 281\n30 212\n341 498\n40 497\n463 402\n6 367\n465 302\n387
      260\n10 334\n380 32\n345 96\n405 492\n349 373\n223 251\n53 475\n315 235\n107
      196\n446 447\n194 337\n443 8\n238 301\n226 202\n454 112\n314 463\n297 45\n494
      493\n140 250\n484 340\n474 206\n90 27\n32 256\n113 139\n452 58\n437 497\n395
      380\n4 484\n32 230\n186 485\n193 351\n448 342\n395 293\n334 386\n395 318\n77
      368\n375 19\n246 407\n274 358\n45 77\n416 333\n425 162\n64 281\n145 95\n362
      182\n80 54\n32 379\n395 278\n171 229\n15 65\n398 92\n285 272\n462 30\n30 87\n388
      426\n16 155\n259 440\n316 322\n72 312\n417 433\n494 348\n339 377\n226 233\n155
      248\n313 21\n165 62\n112 449\n186 425\n478 215\n12 217\n141 27\n371 399\n318
      38\n72 390\n202 488\n174 47\n335 12\n423 412\n97 429\n160 409\n450 324\n323
      413\n272 8\n338 101\n222 201\n318 362\n79 40\n112 248\n78 184\n137 131\n23 311\n177
      210\n174 99\n121 270\n380 132\n31 329\n455 353\n93 78\n360 282\n179 81\n482
      348\n295 60\n387 258\n308 316\n293 296\n446 316\n458 474\n377 132\n73 497\n401
      452\n129 431\n132 435\n135 224\n365 494\n6 43\n427 487\n242 73\n399 128\n330
      58\n296 475\n205 93\n142 163\n67 18\n146 139\n366 398\n442 346\n329 73\n281
      463\n148 145\n309 153\n39 235\n492 280\n307 242\n259 488\n299 406\n462 3\n499
      455\n17 65\n472 162\n55 338\n60 348\n35 240\n272 315\n54 419\n311 362\n424 201\n448
      415\n480 106\n8 91\n446 306\n496 259\n160 346\n214 29\n262 185\n42 316\n374
      453\n15 409\n44 286\n75 98\n57 386\n311 480\n438 111\n246 270\n216 253\n360
      13\n410 207\n272 421\n53 485\n449 314\n21 343\n482 395\n295 496\n155 339\n134
      229\n288 190\n466 450\n21 404\n60 266\n25 128\n370 384\n140 279\n442 263\n51
      494\n247 352\n160 120\n194 493\n14 340\n340 20\n30 473\n100 317\n14 418\n119
      386\n173 30\n151 197\n157 372\n80 149\n2 373\n411 53\n367 10\n404 378\n129 449\n370
      494\n288 209\n13 318\n34 464\n486 399\n381 456\n285 53\n486 287\n249 142\n159
      180\n142 160\n53 405\n212 271\n414 467\n500 42\n415 221\n35 203\n281 399\n372
      166\n362 209\n65 95\n165 349\n499 150\n135 248\n143 145\n279 137\n305 183\n41
      368\n305 454\n335 156\n347 101\n376 381\n303 157\n131 26\n322 344\n87 238\n438
      251\n86 437\n252 73\n36 394\n217 166\n30 373\n201 70\n241 357\n375 427\n13 221\n27
      240\n453 182\n248 83\n207 70\n279 145\n159 68\n395 97\n4 146\n169 391\n392 237\n409
      273\n462 109\n195 54\n465 69\n480 329\n142 358\n69 94\n39 316\n29 98\n237 307\n242
      396\n374 137\n492 230\n134 12\n472 377\n100 380\n2 61\n488 196\n114 305\n116
      445\n133 257\n303 201\n351 341\n17 231\n290 105\n389 32\n500 262\n20 343\n343
      5\n354 315\n382 306\n194 383\n366 34\n430 332\n338 45\n128 470\n154 430\n23
      356\n123 391\n86 412\n495 474\n295 495\n87 314\n337 430\n319 43\n96 52\n348
      289\n286 65\n174 215\n248 11\n111 376\n333 264\n157 207\n119 279\n97 204\n43
      91\n29 337\n437 116\n151 126\n45 321\n20 492\n224 219\n280 9\n283 454\n75 31\n316
      185\n258 500\n301 414\n206 419\n45 154\n475 87\n97 3\n423 33\n118 425\n10 14\n97
      381\n5 320\n99 137\n180 382\n442 106\n264 109\n291 21\n109 91\n286 166\n361
      330\n320 335\n190 191\n300 307\n467 162\nR L L R R R R R L L L R R L R R L L
      L R L R R R L L R L R L R R R L R R L L R R R R R R L R R L R R\n","outputs":"8\n"},{"inputs":"1000
      50 9999999\n254 68\n223 790\n92 307\n449 109\n757 626\n770 110\n500 640\n499
      995\n418 127\n60 988\n702 267\n568 740\n837 423\n996 176\n895 955\n505 148\n22
      727\n289 466\n34 90\n574 142\n715 695\n252 567\n687 102\n561 456\n229 972\n444
      282\n238 11\n373 74\n785 369\n601 680\n323 457\n179 696\n184 820\n513 569\n909
      438\n710 975\n133 313\n541 819\n415 453\n626 995\n776 69\n628 13\n80 1\n438
      216\n721 391\n247 395\n847 426\n442 382\n245 955\n302 505\n392 364\n479 876\n28
      372\n46 794\n824 672\n788 952\n740 768\n316 171\n120 754\n387 840\n496 633\n586
      694\n410 27\n428 6\n981 81\n510 725\n444 341\n600 472\n712 998\n265 887\n21
      405\n838 760\n524 154\n283 643\n259 669\n834 106\n653 419\n151 415\n445 578\n420
      778\n11 282\n502 454\n622 453\n277 685\n802 894\n923 822\n298 113\n934 173\n266
      216\n815 876\n236 1000\n333 240\n418 483\n654 214\n413 426\n343 423\n59 844\n228
      32\n649 505\n716 450\n750 990\n272 399\n102 557\n571 719\n772 385\n594 359\n736
      278\n598 505\n761 604\n718 525\n29 413\n947 87\n256 526\n118 256\n382 185\n706
      131\n174 329\n529 628\n885 99\n346 8\n835 292\n366 570\n569 963\n426 681\n918
      496\n205 946\n908 503\n384 515\n29 853\n771 762\n389 476\n893 915\n156 773\n542
      392\n872 239\n399 58\n530 764\n980 451\n78 405\n131 996\n900 688\n293 159\n190
      29\n674 570\n233 444\n332 622\n271 576\n536 426\n348 429\n817 571\n667 567\n981
      549\n330 960\n999 759\n716 481\n754 968\n520 399\n126 62\n427 799\n631 659\n242
      314\n280 864\n241 167\n289 941\n947 457\n511 614\n23 843\n162 704\n802 512\n463
      518\n344 216\n485 864\n966 610\n925 392\n761 907\n403 2\n573 34\n866 813\n201
      506\n753 147\n315 616\n112 689\n458 625\n393 612\n136 855\n481 480\n422 965\n343
      388\n926 619\n131 686\n525 533\n40 97\n567 257\n910 119\n114 14\n617 428\n981
      729\n117 791\n705 861\n402 841\n67 882\n672 840\n198 366\n579 123\n984 710\n161
      860\n594 552\n957 512\n160 218\n982 273\n583 599\n53 564\n679 521\n354 383\n381
      755\n575 447\n988 598\n638 185\n963 217\n659 298\n278 171\n158 871\n722 114\n735
      881\n331 716\n506 265\n314 558\n828 344\n78 533\n79 458\n287 653\n256 626\n251
      245\n810 565\n461 821\n863 738\n991 20\n961 65\n133 695\n297 815\n410 802\n79
      76\n359 259\n419 436\n791 849\n245 430\n502 852\n55 104\n97 217\n668 909\n389
      882\n647 379\n901 607\n795 385\n301 92\n551 62\n893 982\n137 604\n240 908\n39
      382\n756 636\n811 609\n839 218\n64 935\n786 732\n844 174\n965 842\n904 866\n448
      699\n602 100\n790 153\n161 34\n134 650\n637 725\n557 676\n458 664\n663 621\n273
      501\n838 336\n788 975\n419 983\n148 384\n824 51\n601 623\n749 202\n722 890\n706
      234\n924 191\n883 560\n915 791\n587 373\n455 249\n993 727\n102 182\n62 889\n156
      833\n871 655\n216 694\n57 816\n316 158\n369 389\n47 75\n622 322\n265 857\n882
      180\n647 820\n904 101\n421 248\n827 522\n781 241\n762 288\n425 984\n294 640\n677
      350\n807 344\n507 175\n84 906\n249 57\n227 514\n913 108\n45 560\n928 300\n12
      348\n899 191\n221 31\n783 982\n318 207\n965 611\n846 993\n960 4\n688 819\n178
      771\n724 427\n179 950\n292 92\n410 688\n987 366\n36 237\n556 256\n267 338\n589
      584\n544 905\n546 741\n897 857\n744 584\n675 922\n706 750\n700 236\n700 343\n679
      109\n30 681\n797 368\n399 184\n604 954\n791 870\n292 379\n805 187\n283 350\n928
      531\n558 23\n466 233\n944 523\n982 995\n758 33\n337 437\n469 289\n85 867\n824
      688\n173 614\n557 816\n344 361\n2 978\n62 281\n508 620\n304 325\n204 599\n847
      537\n594 957\n570 282\n393 62\n1000 213\n703 84\n432 526\n772 604\n492 680\n419
      835\n393 772\n165 454\n53 672\n425 356\n997 980\n954 195\n517 899\n151 438\n181
      895\n499 532\n460 553\n615 891\n431 386\n846 922\n418 616\n108 810\n387 272\n615
      439\n296 392\n146 292\n371 452\n838 887\n702 989\n324 234\n883 175\n765 342\n79
      380\n584 509\n117 781\n430 534\n396 890\n695 783\n161 310\n573 456\n701 71\n99
      71\n522 937\n310 575\n277 985\n809 159\n159 573\n853 238\n304 788\n98 421\n569
      528\n306 964\n769 353\n98 929\n662 671\n737 714\n741 835\n136 614\n123 445\n188
      399\n430 996\n910 940\n921 114\n529 224\n901 627\n996 821\n506 654\n137 274\n6
      234\n554 19\n256 290\n732 348\n477 867\n961 599\n664 501\n998 445\n496 259\n736
      768\n372 265\n992 624\n243 987\n797 748\n992 933\n373 997\n518 926\n15 774\n216
      98\n121 692\n317 434\n642 980\n934 639\n776 781\n249 511\n549 620\n127 540\n596
      369\n878 392\n116 870\n676 488\n218 193\n766 585\n966 981\n682 439\n24 998\n872
      665\n329 157\n656 104\n937 904\n967 837\n524 93\n728 471\n462 958\n862 929\n179
      537\n769 396\n729 534\n980 47\n866 14\n837 889\n11 60\n553 340\n216 208\n795
      504\n112 761\n341 987\n206 420\n457 19\n377 670\n299 555\n206 419\n303 286\n952
      634\n684 169\n647 520\n57 658\n579 962\n349 794\n169 495\n650 632\n608 342\n970
      165\n761 426\n183 138\n95 481\n44 652\n252 346\n290 203\n332 973\n372 978\n493
      780\n987 71\n741 687\n217 262\n182 866\n245 141\n207 215\n305 967\n992 487\n456
      439\n319 852\n90 570\n549 379\n125 880\n704 848\n858 196\n979 196\n618 720\n883
      834\n333 416\n699 577\n556 257\n143 212\n576 135\n50 383\n573 720\n234 662\n290
      783\n393 766\n662 96\n965 519\n643 943\n67 260\n14 949\n94 346\n716 144\n275
      623\n753 417\n834 328\n551 883\n710 123\n602 944\n137 243\n78 881\n8 739\n328
      324\n610 322\n267 676\n581 280\n976 26\n978 691\n522 604\n313 274\n20 498\n953
      923\n380 14\n45 333\n309 533\n576 386\n765 935\n125 92\n259 734\n413 877\n761
      346\n508 736\n371 485\n778 244\n440 442\n517 460\n939 821\n382 318\n835 778\n650
      143\n663 577\n529 427\n512 5\n871 122\n90 635\n350 850\n980 857\n937 703\n694
      66\n298 133\n507 167\n592 445\n987 325\n762 821\n455 763\n316 117\n340 196\n543
      203\n200 765\n676 641\n400 25\n842 731\n881 130\n785 926\n195 83\n59 701\n249
      2\n145 235\n327 258\n408 781\n372 75\n249 63\n270 143\n265 821\n908 292\n813
      659\n316 654\n389 549\n783 174\n474 977\n256 884\n29 856\n886 525\n90 564\n782
      849\n696 153\n923 944\n216 544\n86 832\n716 345\n476 528\n3 143\n181 392\n43
      315\n917 517\n643 524\n752 671\n379 637\n195 468\n200 328\n669 895\n833 943\n190
      400\n487 276\n231 202\n620 58\n82 623\n201 262\n366 243\n929 282\n111 571\n805
      863\n242 183\n851 788\n2 403\n116 670\n297 948\n965 487\n347 451\n114 929\n4
      733\n339 85\n707 539\n699 72\n133 627\n705 244\n549 509\n458 790\n43 308\n930
      45\n710 45\n66 359\n344 30\n197 42\n832 310\n322 188\n394 660\n624 453\n550
      674\n876 683\n652 581\n278 201\n441 87\n990 484\n746 919\n880 456\n315 297\n166
      10\n679 714\n403 510\n375 77\n49 768\n88 673\n572 638\n698 448\n672 350\n380
      949\n550 820\n387 539\n655 132\n810 886\n939 476\n183 104\n838 861\n817 592\n722
      543\n668 123\n311 756\n795 234\n745 844\n33 416\n193 412\n716 742\n584 454\n633
      590\n585 794\n476 524\n621 10\n979 458\n870 148\n402 943\n690 69\n65 352\n176
      211\n586 920\n55 618\n687 247\n382 754\n989 317\n207 973\n906 792\n766 733\n667
      386\n742 645\n196 963\n792 597\n906 482\n17 970\n185 545\n181 770\n816 587\n740
      855\n833 473\n608 173\n789 167\n145 46\n310 262\n779 976\n1000 872\n972 547\n835
      116\n495 740\n597 511\n61 133\n407 593\n903 223\n179 994\n77 12\n466 36\n536
      606\n202 33\n651 863\n294 781\n190 293\n5 162\n191 839\n277 685\n930 225\n548
      990\n357 954\n583 611\n176 113\n956 604\n476 421\n640 12\n378 193\n44 381\n56
      689\n513 597\n334 517\n110 524\n355 386\n209 636\n962 756\n978 671\n709 912\n633
      237\n24 589\n840 500\n9 831\n863 739\n24 258\n119 431\n946 631\n27 631\n148
      137\n155 854\n874 715\n490 188\n858 882\n378 490\n118 753\n430 310\n252 791\n140
      466\n529 163\n723 647\n945 21\n277 324\n651 776\n812 157\n982 37\n223 471\n224
      44\n289 433\n926 18\n275 395\n770 704\n704 374\n494 196\n839 22\n710 914\n20
      655\n934 649\n330 936\n424 141\n445 405\n177 667\n227 753\n63 867\n185 988\n884
      811\n734 6\n867 790\n731 712\n985 921\n734 46\n834 105\n700 119\n753 29\n407
      529\n521 851\n933 698\n869 512\n802 931\n378 338\n270 614\n149 4\n971 367\n793
      701\n78 129\n621 811\n174 807\n268 226\n277 20\n606 683\n548 127\n885 833\n176
      754\n696 329\n684 425\n666 306\n38 166\n309 360\n532 453\n60 610\n581 33\n420
      106\n839 39\n331 115\n59 289\n150 958\n415 34\n142 942\n139 837\n270 175\n262
      287\n480 651\n453 788\n363 984\n240 422\n593 172\n806 365\n277 996\n403 960\n463
      813\n248 612\n771 14\n997 264\n307 136\n101 928\n310 714\n214 789\n716 666\n928
      78\n650 519\n852 242\n690 9\n606 318\n5 361\n629 467\n173 228\n430 943\n593
      426\n559 251\n561 659\n178 222\n724 744\n362 791\n409 289\n221 410\n159 424\n652
      848\n432 609\n518 436\n321 498\n902 494\n78 331\n788 670\n109 346\n921 21\n356
      450\n243 79\n193 956\n222 954\n245 442\n363 403\n865 366\n603 296\n327 472\n84
      647\n321 337\n140 398\n20 928\n420 128\n273 692\n148 981\n141 742\n59 334\n698
      632\n287 294\n73 1\n48 289\n367 2\n585 693\n473 20\n339 794\n356 479\n543 375\n758
      962\n502 382\n653 2\n362 146\n95 773\n479 792\n404 117\n85 477\n117 485\n765
      835\n486 701\n527 959\n720 866\n104 428\n696 998\n802 453\n312 656\n186 964\n657
      548\n109 751\n320 939\n895 723\n407 331\n551 876\n815 316\n710 301\n368 589\n611
      440\n806 66\nR R R L R L R L L R R L L L R L R R L R L R L L R L L R R R L R
      R L L R L R L R R R L L L L R L R R\n","outputs":"765\n"},{"inputs":"1000 500
      1\n2 501\n3 502\n4 503\n5 504\n6 505\n7 506\n8 507\n9 508\n10 509\n11 510\n12
      511\n13 512\n14 513\n15 514\n16 515\n17 516\n18 517\n19 518\n20 519\n21 520\n22
      521\n23 522\n24 523\n25 524\n26 525\n27 526\n28 527\n29 528\n30 529\n31 530\n32
      531\n33 532\n34 533\n35 534\n36 535\n37 536\n38 537\n39 538\n40 539\n41 540\n42
      541\n43 542\n44 543\n45 544\n46 545\n47 546\n48 547\n49 548\n50 549\n51 550\n52
      551\n53 552\n54 553\n55 554\n56 555\n57 556\n58 557\n59 558\n60 559\n61 560\n62
      561\n63 562\n64 563\n65 564\n66 565\n67 566\n68 567\n69 568\n70 569\n71 570\n72
      571\n73 572\n74 573\n75 574\n76 575\n77 576\n78 577\n79 578\n80 579\n81 580\n82
      581\n83 582\n84 583\n85 584\n86 585\n87 586\n88 587\n89 588\n90 589\n91 590\n92
      591\n93 592\n94 593\n95 594\n96 595\n97 596\n98 597\n99 598\n100 599\n101 600\n102
      601\n103 602\n104 603\n105 604\n106 605\n107 606\n108 607\n109 608\n110 609\n111
      610\n112 611\n113 612\n114 613\n115 614\n116 615\n117 616\n118 617\n119 618\n120
      619\n121 620\n122 621\n123 622\n124 623\n125 624\n126 625\n127 626\n128 627\n129
      628\n130 629\n131 630\n132 631\n133 632\n134 633\n135 634\n136 635\n137 636\n138
      637\n139 638\n140 639\n141 640\n142 641\n143 642\n144 643\n145 644\n146 645\n147
      646\n148 647\n149 648\n150 649\n151 650\n152 651\n153 652\n154 653\n155 654\n156
      655\n157 656\n158 657\n159 658\n160 659\n161 660\n162 661\n163 662\n164 663\n165
      664\n166 665\n167 666\n168 667\n169 668\n170 669\n171 670\n172 671\n173 672\n174
      673\n175 674\n176 675\n177 676\n178 677\n179 678\n180 679\n181 680\n182 681\n183
      682\n184 683\n185 684\n186 685\n187 686\n188 687\n189 688\n190 689\n191 690\n192
      691\n193 692\n194 693\n195 694\n196 695\n197 696\n198 697\n199 698\n200 699\n201
      700\n202 701\n203 702\n204 703\n205 704\n206 705\n207 706\n208 707\n209 708\n210
      709\n211 710\n212 711\n213 712\n214 713\n215 714\n216 715\n217 716\n218 717\n219
      718\n220 719\n221 720\n222 721\n223 722\n224 723\n225 724\n226 725\n227 726\n228
      727\n229 728\n230 729\n231 730\n232 731\n233 732\n234 733\n235 734\n236 735\n237
      736\n238 737\n239 738\n240 739\n241 740\n242 741\n243 742\n244 743\n245 744\n246
      745\n247 746\n248 747\n249 748\n250 749\n251 750\n252 751\n253 752\n254 753\n255
      754\n256 755\n257 756\n258 757\n259 758\n260 759\n261 760\n262 761\n263 762\n264
      763\n265 764\n266 765\n267 766\n268 767\n269 768\n270 769\n271 770\n272 771\n273
      772\n274 773\n275 774\n276 775\n277 776\n278 777\n279 778\n280 779\n281 780\n282
      781\n283 782\n284 783\n285 784\n286 785\n287 786\n288 787\n289 788\n290 789\n291
      790\n292 791\n293 792\n294 793\n295 794\n296 795\n297 796\n298 797\n299 798\n300
      799\n301 800\n302 801\n303 802\n304 803\n305 804\n306 805\n307 806\n308 807\n309
      808\n310 809\n311 810\n312 811\n313 812\n314 813\n315 814\n316 815\n317 816\n318
      817\n319 818\n320 819\n321 820\n322 821\n323 822\n324 823\n325 824\n326 825\n327
      826\n328 827\n329 828\n330 829\n331 830\n332 831\n333 832\n334 833\n335 834\n336
      835\n337 836\n338 837\n339 838\n340 839\n341 840\n342 841\n343 842\n344 843\n345
      844\n346 845\n347 846\n348 847\n349 848\n350 849\n351 850\n352 851\n353 852\n354
      853\n355 854\n356 855\n357 856\n358 857\n359 858\n360 859\n361 860\n362 861\n363
      862\n364 863\n365 864\n366 865\n367 866\n368 867\n369 868\n370 869\n371 870\n372
      871\n373 872\n374 873\n375 874\n376 875\n377 876\n378 877\n379 878\n380 879\n381
      880\n382 881\n383 882\n384 883\n385 884\n386 885\n387 886\n388 887\n389 888\n390
      889\n391 890\n392 891\n393 892\n394 893\n395 894\n396 895\n397 896\n398 897\n399
      898\n400 899\n401 900\n402 901\n403 902\n404 903\n405 904\n406 905\n407 906\n408
      907\n409 908\n410 909\n411 910\n412 911\n413 912\n414 913\n415 914\n416 915\n417
      916\n418 917\n419 918\n420 919\n421 920\n422 921\n423 922\n424 923\n425 924\n426
      925\n427 926\n428 927\n429 928\n430 929\n431 930\n432 931\n433 932\n434 933\n435
      934\n436 935\n437 936\n438 937\n439 938\n440 939\n441 940\n442 941\n443 942\n444
      943\n445 944\n446 945\n447 946\n448 947\n449 948\n450 949\n451 950\n452 951\n453
      952\n454 953\n455 954\n456 955\n457 956\n458 957\n459 958\n460 959\n461 960\n462
      961\n463 962\n464 963\n465 964\n466 965\n467 966\n468 967\n469 968\n470 969\n471
      970\n472 971\n473 972\n474 973\n475 974\n476 975\n477 976\n478 977\n479 978\n480
      979\n481 980\n482 981\n483 982\n484 983\n485 984\n486 985\n487 986\n488 987\n489
      988\n490 989\n491 990\n492 991\n493 992\n494 993\n495 994\n496 995\n497 996\n498
      997\n499 998\n500 999\n501 2\n502 3\n503 4\n504 5\n505 6\n506 7\n507 8\n508
      9\n509 10\n510 11\n511 12\n512 13\n513 14\n514 15\n515 16\n516 17\n517 18\n518
      19\n519 20\n520 21\n521 22\n522 23\n523 24\n524 25\n525 26\n526 27\n527 28\n528
      29\n529 30\n530 31\n531 32\n532 33\n533 34\n534 35\n535 36\n536 37\n537 38\n538
      39\n539 40\n540 41\n541 42\n542 43\n543 44\n544 45\n545 46\n546 47\n547 48\n548
      49\n549 50\n550 51\n551 52\n552 53\n553 54\n554 55\n555 56\n556 57\n557 58\n558
      59\n559 60\n560 61\n561 62\n562 63\n563 64\n564 65\n565 66\n566 67\n567 68\n568
      69\n569 70\n570 71\n571 72\n572 73\n573 74\n574 75\n575 76\n576 77\n577 78\n578
      79\n579 80\n580 81\n581 82\n582 83\n583 84\n584 85\n585 86\n586 87\n587 88\n588
      89\n589 90\n590 91\n591 92\n592 93\n593 94\n594 95\n595 96\n596 97\n597 98\n598
      99\n599 100\n600 101\n601 102\n602 103\n603 104\n604 105\n605 106\n606 107\n607
      108\n608 109\n609 110\n610 111\n611 112\n612 113\n613 114\n614 115\n615 116\n616
      117\n617 118\n618 119\n619 120\n620 121\n621 122\n622 123\n623 124\n624 125\n625
      126\n626 127\n627 128\n628 129\n629 130\n630 131\n631 132\n632 133\n633 134\n634
      135\n635 136\n636 137\n637 138\n638 139\n639 140\n640 141\n641 142\n642 143\n643
      144\n644 145\n645 146\n646 147\n647 148\n648 149\n649 150\n650 151\n651 152\n652
      153\n653 154\n654 155\n655 156\n656 157\n657 158\n658 159\n659 160\n660 161\n661
      162\n662 163\n663 164\n664 165\n665 166\n666 167\n667 168\n668 169\n669 170\n670
      171\n671 172\n672 173\n673 174\n674 175\n675 176\n676 177\n677 178\n678 179\n679
      180\n680 181\n681 182\n682 183\n683 184\n684 185\n685 186\n686 187\n687 188\n688
      189\n689 190\n690 191\n691 192\n692 193\n693 194\n694 195\n695 196\n696 197\n697
      198\n698 199\n699 200\n700 201\n701 202\n702 203\n703 204\n704 205\n705 206\n706
      207\n707 208\n708 209\n709 210\n710 211\n711 212\n712 213\n713 214\n714 215\n715
      216\n716 217\n717 218\n718 219\n719 220\n720 221\n721 222\n722 223\n723 224\n724
      225\n725 226\n726 227\n727 228\n728 229\n729 230\n730 231\n731 232\n732 233\n733
      234\n734 235\n735 236\n736 237\n737 238\n738 239\n739 240\n740 241\n741 242\n742
      243\n743 244\n744 245\n745 246\n746 247\n747 248\n748 249\n749 250\n750 251\n751
      252\n752 253\n753 254\n754 255\n755 256\n756 257\n757 258\n758 259\n759 260\n760
      261\n761 262\n762 263\n763 264\n764 265\n765 266\n766 267\n767 268\n768 269\n769
      270\n770 271\n771 272\n772 273\n773 274\n774 275\n775 276\n776 277\n777 278\n778
      279\n779 280\n780 281\n781 282\n782 283\n783 284\n784 285\n785 286\n786 287\n787
      288\n788 289\n789 290\n790 291\n791 292\n792 293\n793 294\n794 295\n795 296\n796
      297\n797 298\n798 299\n799 300\n800 301\n801 302\n802 303\n803 304\n804 305\n805
      306\n806 307\n807 308\n808 309\n809 310\n810 311\n811 312\n812 313\n813 314\n814
      315\n815 316\n816 317\n817 318\n818 319\n819 320\n820 321\n821 322\n822 323\n823
      324\n824 325\n825 326\n826 327\n827 328\n828 329\n829 330\n830 331\n831 332\n832
      333\n833 334\n834 335\n835 336\n836 337\n837 338\n838 339\n839 340\n840 341\n841
      342\n842 343\n843 344\n844 345\n845 346\n846 347\n847 348\n848 349\n849 350\n850
      351\n851 352\n852 353\n853 354\n854 355\n855 356\n856 357\n857 358\n858 359\n859
      360\n860 361\n861 362\n862 363\n863 364\n864 365\n865 366\n866 367\n867 368\n868
      369\n869 370\n870 371\n871 372\n872 373\n873 374\n874 375\n875 376\n876 377\n877
      378\n878 379\n879 380\n880 381\n881 382\n882 383\n883 384\n884 385\n885 386\n886
      387\n887 388\n888 389\n889 390\n890 391\n891 392\n892 393\n893 394\n894 395\n895
      396\n896 397\n897 398\n898 399\n899 400\n900 401\n901 402\n902 403\n903 404\n904
      405\n905 406\n906 407\n907 408\n908 409\n909 410\n910 411\n911 412\n912 413\n913
      414\n914 415\n915 416\n916 417\n917 418\n918 419\n919 420\n920 421\n921 422\n922
      423\n923 424\n924 425\n925 426\n926 427\n927 428\n928 429\n929 430\n930 431\n931
      432\n932 433\n933 434\n934 435\n935 436\n936 437\n937 438\n938 439\n939 440\n940
      441\n941 442\n942 443\n943 444\n944 445\n945 446\n946 447\n947 448\n948 449\n949
      450\n950 451\n951 452\n952 453\n953 454\n954 455\n955 456\n956 457\n957 458\n958
      459\n959 460\n960 461\n961 462\n962 463\n963 464\n964 465\n965 466\n966 467\n967
      468\n968 469\n969 470\n970 471\n971 472\n972 473\n973 474\n974 475\n975 476\n976
      477\n977 478\n978 479\n979 480\n980 481\n981 482\n982 483\n983 484\n984 485\n985
      486\n986 487\n987 488\n988 489\n989 490\n990 491\n991 492\n992 493\n993 494\n994
      495\n995 496\n996 497\n997 498\n998 499\n999 500\n1000 1\n1 500\nL L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L R\n","outputs":"2\n"},{"inputs":"1000
      500 1000000000\n774 167\n876 97\n409 751\n549 934\n598 944\n883 986\n736 191\n125
      761\n126 954\n227 57\n768 279\n295 692\n203 460\n520 341\n875 735\n733 1\n902
      961\n97 310\n711 998\n595 308\n941 477\n645 28\n19 769\n788 496\n723 367\n904
      842\n645 551\n533 199\n10 52\n539 237\n138 624\n237 39\n584 685\n700 646\n682
      646\n953 974\n474 950\n353 845\n70 141\n340 792\n507 596\n633 503\n146 517\n701
      155\n568 592\n391 706\n567 979\n96 502\n664 148\n147 697\n793 451\n671 619\n400
      375\n463 470\n515 154\n613 373\n749 598\n227 894\n114 280\n401 34\n871 143\n739
      789\n122 186\n290 785\n333 788\n833 478\n238 855\n448 990\n230 262\n811 96\n415
      423\n469 516\n372 47\n409 486\n326 161\n519 548\n304 609\n336 777\n794 977\n561
      479\n764 745\n308 354\n600 755\n343 829\n16 153\n924 430\n927 744\n297 299\n791
      706\n136 468\n218 6\n16 521\n614 703\n297 759\n32 209\n237 147\n954 896\n500
      553\n650 194\n733 665\n346 8\n447 625\n752 743\n275 894\n800 410\n361 18\n767
      728\n890 380\n783 187\n490 814\n747 79\n312 52\n974 812\n604 624\n5 688\n640
      703\n696 86\n327 447\n181 953\n692 332\n714 52\n349 480\n132 239\n211 914\n777
      700\n79 523\n778 390\n575 104\n553 530\n79 558\n218 718\n612 265\n156 290\n63
      688\n242 754\n19 955\n157 368\n434 288\n958 644\n553 734\n695 983\n608 825\n725
      534\n928 277\n64 6\n186 633\n75 797\n897 582\n86 311\n269 679\n64 288\n633 220\n7
      418\n860 964\n61 412\n49 756\n747 656\n580 471\n190 859\n99 605\n216 285\n589
      290\n433 837\n872 871\n147 140\n549 210\n779 534\n781 785\n951 640\n100 364\n404
      148\n471 150\n156 402\n972 697\n260 70\n653 827\n706 241\n116 139\n77 339\n361
      223\n831 261\n784 609\n794 564\n746 97\n204 845\n460 607\n345 282\n108 500\n683
      79\n548 294\n148 200\n120 206\n440 587\n344 868\n926 56\n90 756\n316 873\n716
      462\n788 461\n910 991\n658 369\n949 354\n2 56\n205 684\n486 752\n977 986\n303
      448\n191 742\n34 886\n609 959\n941 50\n66 608\n274 134\n69 61\n946 978\n404
      603\n698 352\n308 699\n760 512\n734 245\n263 62\n230 565\n509 420\n658 543\n657
      618\n853 597\n667 919\n205 292\n404 625\n705 349\n955 108\n304 4\n811 611\n55
      922\n123 788\n167 737\n850 748\n302 358\n520 311\n252 176\n929 105\n125 947\n375
      329\n591 130\n305 295\n478 611\n402 781\n615 564\n392 669\n486 514\n808 4\n250
      657\n751 903\n367 622\n214 970\n150 494\n426 274\n440 152\n954 30\n281 258\n676
      759\n221 77\n539 835\n993 282\n855 478\n147 662\n833 749\n319 583\n651 37\n557
      216\n6 706\n709 432\n979 501\n583 284\n882 216\n541 558\n974 113\n986 864\n947
      978\n146 801\n807 644\n815 639\n392 133\n574 395\n521 130\n610 526\n187 671\n309
      517\n523 244\n800 404\n459 692\n313 432\n805 299\n647 103\n628 144\n256 435\n788
      70\n425 179\n554 998\n573 74\n479 535\n951 17\n205 260\n533 727\n503 684\n482
      313\n376 795\n96 532\n445 742\n634 72\n886 241\n858 673\n310 283\n203 863\n280
      776\n936 111\n310 887\n127 866\n498 12\n944 352\n695 425\n664 422\n571 759\n305
      15\n852 291\n87 737\n531 944\n761 841\n578 964\n55 858\n91 991\n320 400\n229
      798\n617 726\n809 560\n77 856\n336 92\n629 907\n202 286\n273 53\n576 359\n790
      458\n655 902\n650 232\n865 705\n441 955\n47 112\n706 627\n910 322\n352 70\n233
      780\n925 569\n871 906\n827 424\n191 99\n476 118\n810 617\n575 816\n519 225\n47
      735\n281 840\n42 679\n303 747\n305 212\n421 656\n634 653\n787 558\n573 9\n815
      399\n432 357\n850 907\n474 659\n876 401\n474 394\n625 872\n128 257\n63 169\n935
      366\n268 239\n929 688\n246 562\n692 384\n472 265\n392 286\n15 823\n995 216\n81
      468\n874 956\n868 699\n701 844\n923 181\n100 337\n701 386\n702 968\n976 983\n7
      221\n544 699\n604 367\n315 347\n5 681\n521 999\n897 954\n466 122\n909 686\n821
      962\n529 95\n142 981\n431 842\n366 485\n162 342\n467 168\n914 362\n218 870\n729
      532\n216 733\n565 737\n83 461\n42 548\n582 950\n585 754\n911 114\n200 404\n446
      631\n246 163\n115 407\n856 933\n926 770\n294 144\n991 374\n27 206\n458 591\n294
      540\n403 335\n440 337\n637 24\n90 899\n137 290\n303 934\n272 900\n97 738\n658
      952\n670 935\n721 315\n78 711\n689 105\n269 498\n47 914\n38 450\n601 477\n786
      237\n500 875\n487 989\n516 141\n922 139\n392 370\n876 49\n322 897\n984 394\n212
      413\n105 252\n869 725\n749 916\n990 138\n365 590\n966 150\n826 818\n376 665\n806
      244\n805 79\n382 197\n449 610\n597 770\n506 932\n163 69\n697 619\n672 565\n695
      773\n480 685\n262 844\n274 228\n345 452\n45 73\n468 850\n316 272\n280 49\n820
      80\n658 769\n201 516\n700 716\n936 396\n686 960\n313 381\n732 792\n417 993\n988
      690\n220 684\n493 616\n756 960\n465 71\n584 97\n472 403\n176 481\n171 729\n996
      223\n444 284\n970 129\n243 282\n509 326\n426 277\n318 765\n319 890\n448 811\n505
      204\n123 322\n626 706\n770 97\n460 297\n578 983\n25 925\n557 468\n208 526\n597
      802\n160 457\n127 585\n86 797\n349 404\n38 796\n214 894\n351 688\n567 977\n393
      336\n73 205\n633 2\n187 9\n927 95\n477 486\n620 425\n640 131\n233 766\n67 318\n914
      415\n721 303\n563 287\n197 265\n974 115\n241 719\n451 666\n923 435\n19 461\n443
      945\n555 271\n783 526\n47 422\n657 632\n539 723\n949 805\n490 22\n107 404\n660
      655\n668 633\n770 261\n351 572\n278 625\n358 296\n437 152\n593 991\n423 375\n869
      821\n148 877\n452 38\n599 753\n194 440\n774 301\n843 433\n307 863\n417 428\n123
      120\n999 400\n96 356\n695 533\n508 639\n875 282\n13 743\n102 512\n971 906\n902
      922\n658 95\n361 783\n747 556\n567 54\n770 335\n481 892\n454 832\n643 550\n539
      689\n434 46\n328 308\n679 692\n403 133\n556 725\n38 457\n646 47\n551 359\n829
      298\n914 747\n703 683\n81 535\n926 887\n366 568\n788 905\n608 573\n302 935\n232
      981\n979 986\n465 534\n711 502\n990 356\n900 892\n714 80\n541 979\n826 243\n13
      258\n778 938\n144 495\n857 283\n399 817\n855 53\n751 87\n385 81\n72 849\n614
      782\n350 955\n490 249\n847 555\n328 739\n534 505\n982 546\n114 111\n836 258\n605
      44\n892 356\n860 99\n408 963\n185 792\n43 608\n992 657\n742 341\n963 231\n941
      161\n785 620\n900 670\n476 233\n568 589\n343 403\n198 299\n446 442\n654 658\n540
      413\n620 724\n556 662\n683 547\n670 424\n239 985\n654 531\n145 791\n502 396\n460
      977\n628 27\n918 970\n429 115\n621 227\n556 626\n236 95\n39 855\n170 594\n868
      853\n493 538\n276 731\n522 282\n262 18\n72 763\n414 531\n92 41\n910 9\n363 690\n475
      335\n268 383\n960 503\n829 998\n357 999\n944 225\n203 436\n114 830\n166 987\n111
      779\n4 182\n894 769\n65 985\n810 326\n345 524\n15 819\n858 283\n553 817\n785
      382\n815 494\n380 110\n718 934\n545 183\n763 62\n169 874\n841 524\n407 86\n293
      823\n70 454\n148 766\n977 163\n936 186\n445 489\n2 581\n870 168\n74 601\n277
      143\n534 173\n325 648\n235 493\n521 427\n369 280\n512 661\n102 933\n114 250\n698
      442\n764 633\n627 560\n473 628\n140 342\n148 566\n294 776\n708 827\n949 33\n827
      535\n877 347\n313 597\n978 176\n257 80\n108 722\n681 157\n163 796\n141 789\n355
      614\n769 846\n955 268\n411 249\n43 119\n427 343\n503 253\n229 731\n952 541\n328
      929\n716 936\n360 175\n658 392\n331 172\n187 472\n961 893\n85 81\n739 391\n348
      149\n991 390\n619 418\n85 473\n22 313\n556 325\n206 235\n606 921\n170 317\n96
      179\n709 778\n351 247\n249 663\n140 685\n743 878\n76 90\n378 66\n831 997\n835
      915\n821 209\n580 376\n533 785\n610 490\n57 132\n807 504\n310 867\n282 12\n113
      882\n674 252\n567 416\n129 642\n857 859\n59 40\n855 246\n306 27\n454 885\n403
      338\n21 364\n828 78\n495 986\n581 157\n852 214\n520 964\n96 194\n216 14\n961
      696\n7 170\n554 65\n209 760\n310 514\n787 115\n751 541\n453 771\n256 632\n200
      103\n617 133\n259 468\n346 778\n431 793\n323 998\n806 284\n46 812\n453 599\n229
      13\n711 538\n526 849\n5 628\n741 457\n399 996\n88 950\n98 56\n82 708\n523 780\n838
      305\n572 160\n303 730\n795 700\n541 599\n650 121\n611 360\n659 489\n560 15\n116
      300\n471 866\n648 910\n816 745\n965 897\n805 839\n676 642\n495 600\n801 149\n329
      948\n848 869\n546 498\n990 157\n209 1000\n645 769\n366 112\n420 836\n978 67\n97
      793\n164 413\n41 320\n603 69\n961 97\n668 113\n246 996\n60 93\n216 606\n590
      557\n114 151\n908 110\n271 273\n221 690\n460 550\n109 908\n694 624\n672 87\n943
      274\n155 903\n371 822\n367 968\n169 427\n60 384\n384 2\n293 497\n504 200\n958
      774\n825 530\n463 636\n80 923\n544 125\n546 215\n211 840\n841 365\n94 563\n186
      461\n530 706\n239 941\n442 622\n294 734\n470 797\n285 779\n922 109\n308 385\n97
      387\n659 640\n512 557\n206 722\n396 398\n439 490\n960 976\n302 841\n682 892\n782
      123\n513 427\n856 334\n576 492\n112 497\n953 771\n233 49\n158 244\n40 21\n800
      245\n94 195\n643 884\n36 954\n860 689\n795 541\n580 928\n15 444\n354 222\n129
      281\n713 592\n130 665\n363 362\n65 520\n605 104\n892 756\n349 337\n303 343\n221
      690\n296 80\n379 442\n972 310\n369 338\n754 75\n559 882\n355 623\n474 484\n640
      836\n198 704\n707 154\n808 950\n910 156\n638 564\n850 858\n253 497\n289 631\n939
      612\n941 307\n949 46\n381 859\n279 88\n482 104\n571 473\n939 120\n176 997\n274
      983\n298 535\n490 936\n98 339\n145 350\n836 434\n333 774\n397 625\n432 698\n22
      165\n556 300\n252 389\n404 174\n861 694\n294 37\n43 919\n371 340\n805 861\n275
      902\n199 420\n603 386\n205 287\n511 601\n263 943\n650 284\n459 558\nL L L R
      R R L L R L L R L L R L R L R L R R L L L R L R L L L R R L R R L R R L L L
      L R L R R L L R R L L R R R R L R L R R R R L R L R R L L R R R R L R R L L
      L L L R L L R L L R L L R L R L L L L R R R R R L R R L L L L R R R R R L R
      L R R R R L L R R L L R L L R L L L L L L R R R R L R R L L R R R L L R R R
      R R L L R R R L L L R L L L L L L R R L R L L L R L R L L R L L R L R L L R
      R L L R R R R L R L L R L R R R L R L L L R L R L L L L R L L R R R L R L L
      L L R L L L L L L R L R L R R R L L L R R R L L R L R L L L R L R L R L R L
      L R L R R R L L R R R L R L L R R R L R L L L R R L L R L L L R L R R R R L
      L R L L L R R L R L L L L R R L R R R L R L L L L R L R R L L L L L L L L L
      R L R L R R L L L R L L L R L R L R L L R L R R L R L R L R L L L R R L R L
      R L L R R L R L L L R R R R R L R L L L L R L R L R R L R R R R L R R R L R
      L R R L L R R L L R R R R L R L L L R R R R R L R R L L R R L L R L L L R L
      R L L R R L L R L L R L L R L L L L L R R L R R L L L R R L L L L R L L R L
      L L\n","outputs":"935\n"},{"inputs":"1000 500 1000000000\n647 576\n436 5\n85
      30\n442 896\n420 198\n770 909\n516 565\n705 437\n121 306\n789 823\n224 303\n288
      84\n945 31\n118 263\n176 304\n835 174\n879 622\n179 315\n651 620\n211 422\n169
      980\n683 37\n897 387\n825 17\n44 965\n191 268\n267 479\n351 563\n509 820\n177
      36\n475 11\n210 706\n985 388\n20 987\n359 582\n409 879\n562 91\n915 458\n477
      739\n826 873\n703 16\n140 321\n846 490\n883 707\n661 60\n742 488\n422 951\n193
      406\n338 564\n393 48\n146 153\n927 59\n243 193\n868 71\n284 693\n943 986\n60
      82\n659 258\n923 893\n964 936\n304 705\n423 726\n656 967\n483 345\n882 227\n393
      27\n379 671\n437 973\n215 304\n396 498\n348 338\n836 760\n772 494\n17 46\n386
      980\n333 690\n684 755\n767 339\n73 249\n684 955\n476 428\n981 206\n450 770\n179
      664\n73 574\n514 421\n263 349\n532 386\n194 548\n432 931\n527 764\n972 210\n871
      90\n901 943\n691 584\n897 166\n363 230\n723 812\n999 901\n827 423\n826 340\n843
      89\n40 374\n474 585\n273 257\n868 799\n373 839\n361 243\n281 261\n537 971\n844
      434\n488 558\n663 210\n369 13\n463 547\n435 288\n239 630\n376 278\n355 202\n215
      628\n810 82\n778 182\n272 138\n424 552\n398 961\n874 241\n746 361\n798 760\n571
      518\n772 33\n65 558\n672 303\n187 48\n932 542\n601 498\n521 410\n579 298\n592
      203\n436 367\n106 833\n679 980\n426 424\n340 575\n183 262\n93 306\n646 509\n864
      318\n163 402\n717 446\n943 317\n944 815\n78 874\n113 21\n76 900\n388 534\n732
      66\n513 509\n842 204\n84 376\n818 528\n34 463\n388 897\n780 550\n298 496\n995
      593\n164 938\n407 242\n812 871\n262 239\n770 1\n772 854\n419 636\n362 260\n192
      445\n987 9\n972 20\n471 711\n268 251\n260 566\n98 607\n510 262\n544 268\n855
      707\n139 116\n298 260\n117 69\n113 535\n57 475\n146 248\n919 132\n256 243\n504
      78\n953 771\n328 565\n688 778\n171 549\n391 66\n817 245\n125 307\n360 422\n566
      828\n842 679\n714 898\n505 859\n145 775\n343 752\n369 198\n830 674\n320 509\n238
      8\n638 760\n556 28\n825 724\n272 301\n30 984\n722 948\n811 564\n626 877\n813
      482\n87 310\n256 429\n413 625\n978 242\n103 887\n657 740\n646 564\n768 822\n288
      391\n123 669\n374 844\n616 185\n759 593\n61 924\n74 147\n233 330\n928 645\n306
      257\n239 603\n554 341\n489 562\n432 486\n126 551\n307 413\n942 429\n433 315\n625
      49\n851 735\n641 263\n658 67\n762 890\n748 41\n887 53\n297 477\n7 203\n169 847\n764
      600\n332 241\n151 638\n653 444\n419 438\n758 43\n486 609\n777 478\n223 435\n544
      984\n676 291\n24 914\n695 673\n390 701\n875 558\n547 990\n510 230\n231 12\n868
      235\n455 286\n672 564\n680 509\n524 456\n987 747\n242 882\n82 918\n525 458\n183
      219\n130 573\n920 356\n482 818\n345 343\n48 927\n354 267\n514 160\n904 185\n724
      583\n46 599\n390 32\n345 632\n265 779\n901 789\n236 83\n8 365\n7 279\n72 489\n448
      416\n831 847\n695 537\n113 208\n48 368\n744 123\n950 789\n722 340\n172 418\n323
      437\n196 223\n225 431\n305 584\n147 312\n862 218\n152 662\n986 334\n508 32\n870
      973\n239 270\n340 982\n392 290\n771 113\n981 294\n531 303\n730 78\n525 955\n861
      181\n890 7\n844 104\n577 995\n765 914\n329 272\n945 550\n244 183\n819 936\n516
      211\n225 638\n675 557\n932 205\n859 661\n635 735\n967 495\n267 857\n501 111\n960
      429\n105 76\n342 433\n699 286\n335 295\n468 153\n230 984\n715 806\n973 390\n362
      904\n946 572\n917 580\n658 883\n74 924\n91 927\n34 402\n355 139\n477 697\n923
      176\n334 257\n470 802\n762 51\n137 828\n856 109\n365 163\n140 281\n94 797\n515
      168\n720 606\n446 754\n7 800\n892 836\n848 166\n363 182\n423 184\n335 536\n234
      823\n363 89\n283 580\n657 999\n94 796\n279 539\n592 794\n706 311\n399 151\n416
      757\n303 307\n944 502\n825 306\n35 247\n489 721\n134 74\n543 496\n162 178\n427
      170\n176 872\n965 807\n411 908\n600 468\n219 350\n971 986\n458 625\n645 402\n126
      469\n59 513\n67 900\n233 200\n973 128\n47 487\n657 826\n656 832\n49 973\n638
      811\n880 589\n279 450\n290 601\n436 748\n225 80\n501 702\n548 559\n566 614\n810
      799\n165 135\n926 211\n621 582\n388 628\n765 437\n600 755\n247 480\n343 525\n929
      633\n477 716\n732 53\n795 232\n755 342\n142 320\n307 304\n470 471\n438 747\n682
      410\n680 69\n37 445\n857 989\n551 104\n820 245\n980 748\n229 457\n464 960\n509
      610\n543 615\n952 685\n287 258\n340 756\n81 777\n503 762\n186 534\n182 574\n978
      39\n914 880\n494 733\n125 473\n833 353\n281 648\n313 142\n257 855\n108 208\n891
      394\n818 230\n502 898\n358 356\n11 895\n889 544\n469 219\n934 734\n98 427\n467
      222\n252 299\n575 884\n946 239\n377 202\n445 485\n762 688\n230 931\n917 731\n828
      627\n86 190\n521 975\n733 341\n545 19\n75 642\n445 541\n864 48\n191 790\n284
      136\n380 660\n337 824\n496 450\n511 726\n380 780\n456 559\n406 894\n748 278\n220
      833\n971 764\n851 45\n405 647\n937 620\n695 127\n761 330\n614 140\n341 302\n316
      837\n752 178\n562 131\n957 369\n690 714\n262 789\n344 481\n621 314\n596 471\n358
      353\n118 646\n972 164\n772 85\n493 737\n576 185\n38 891\n21 789\n421 582\n272
      729\n303 961\n443 564\n749 786\n397 722\n451 344\n192 808\n696 661\n805 20\n824
      928\n104 668\n664 31\n853 701\n274 225\n490 694\n159 761\n422 461\n73 216\n376
      173\n353 124\n894 803\n468 86\n962 163\n98 766\n534 922\n693 989\n941 356\n20
      793\n57 293\n18 898\n338 528\n10 759\n988 82\n327 363\n606 679\n487 500\n482
      306\n937 795\n820 34\n561 354\n307 605\n342 248\n961 713\n392 369\n5 761\n618
      694\n288 627\n805 275\n60 131\n990 665\n161 828\n516 994\n485 804\n789 304\n838
      701\n657 144\n305 351\n743 265\n63 135\n985 420\n247 954\n465 535\n580 269\n161
      991\n399 502\n8 912\n681 523\n905 165\n327 693\n469 516\n393 477\n11 50\n179
      754\n666 594\n240 651\n13 838\n604 477\n724 536\n98 885\n878 848\n738 885\n759
      419\n408 664\n583 86\n708 51\n953 453\n880 963\n502 58\n68 167\n651 307\n169
      15\n145 125\n844 868\n12 941\n104 889\n788 194\n774 547\n612 533\n562 194\n970
      621\n597 922\n425 828\n884 278\n237 952\n797 888\n610 965\n254 106\n441 97\n326
      452\n37 429\n341 177\n974 466\n75 585\n998 636\n131 967\n608 79\n888 33\n258
      123\n310 494\n74 106\n733 684\n423 987\n141 863\n83 466\n315 472\n247 7\n1000
      220\n472 74\n805 821\n61 287\n787 668\n717 26\n52 974\n500 362\n467 574\n819
      200\n609 241\n186 749\n456 620\n215 122\n443 461\n128 442\n680 951\n515 836\n771
      927\n474 909\n947 190\n934 998\n163 433\n711 982\n358 530\n181 318\n122 718\n67
      577\n689 633\n698 132\n445 825\n925 476\n127 792\n664 897\n718 137\n805 664\n679
      90\n662 841\n875 372\n174 584\n253 706\n902 375\n423 320\n951 464\n304 1\n595
      748\n177 871\n575 304\n662 238\n200 732\n727 357\n395 405\n446 408\n597 672\n132
      771\n256 384\n476 509\n110 251\n828 413\n714 131\n413 660\n230 589\n530 804\n892
      544\n394 444\n275 120\n800 21\n876 597\n781 472\n269 912\n594 876\n647 70\n384
      109\n672 563\n521 385\n45 933\n396 274\n521 277\n429 413\n820 174\n856 446\n293
      7\n467 520\n603 599\n992 223\n862 937\n450 860\n6 185\n968 29\n747 488\n765
      791\n772 160\n416 293\n437 197\n57 608\n370 264\n406 15\n270 872\n534 224\n822
      877\n799 683\n814 248\n542 171\n433 862\n200 531\n349 316\n674 121\n476 441\n765
      264\n637 821\n223 359\n436 628\n725 57\n851 258\n280 672\n487 430\n706 652\n678
      248\n822 462\n109 373\n992 809\n689 665\n281 516\n106 45\n779 94\n217 353\n452
      652\n981 176\n708 831\n786 340\n855 624\n769 560\n275 798\n159 96\n259 267\n821
      251\n428 509\n267 708\n376 724\n753 506\n818 969\n858 621\n973 838\n149 32\n21
      934\n371 875\n557 492\n786 183\n289 945\n278 548\n563 450\n150 990\n958 768\n698
      685\n492 450\n190 661\n770 48\n281 94\n237 429\n126 609\n714 848\n835 622\n339
      621\n804 980\n917 434\n879 479\n883 380\n469 193\n147 166\n877 990\n967 67\n650
      88\n466 931\n182 54\n711 307\n15 425\n506 201\n46 197\n173 202\n176 89\n635
      406\n568 517\n785 388\n709 283\n553 938\n273 871\n356 922\n958 173\n204 139\n578
      915\n797 592\n691 655\n793 736\n851 317\n289 378\n406 923\n783 325\n792 919\n712
      500\n201 616\n789 473\n486 144\n747 795\n316 950\n286 894\n864 434\n837 554\n88
      981\n642 290\n298 930\n667 55\n205 801\n379 996\n719 442\n847 272\n57 636\n744
      894\n779 490\n688 95\n792 973\n340 655\n407 176\n561 494\n509 554\n784 806\n483
      802\n860 39\n603 590\n34 673\n31 881\n944 87\n516 40\n980 646\n881 19\n92 672\n992
      431\n679 398\n959 239\n243 467\n792 378\n624 626\n180 835\n665 134\n424 50\n806
      454\n930 102\n892 797\n141 223\n443 21\n241 534\n693 232\n317 723\n981 275\n961
      576\n93 104\n953 716\n81 484\n902 97\n617 325\n499 775\n130 428\n876 373\n577
      16\n595 19\n388 187\n904 432\n771 220\n154 751\n494 466\n678 938\n921 631\n5
      354\n114 906\n802 83\n582 300\n857 63\n728 732\n435 656\n99 381\n674 838\n568
      929\n270 338\n149 775\n440 994\n241 118\n932 513\n748 288\n866 213\n546 668\n295
      127\n967 503\n190 46\n586 976\n53 36\n357 78\n874 924\n7 143\n261 155\n269 700\n500
      861\n169 783\n374 916\n71 591\n481 616\n610 127\n94 929\n630 283\n326 567\n259
      379\n603 615\n456 476\n890 814\n970 502\n968 238\n553 820\n451 722\n602 824\n989
      672\n766 469\n639 728\n596 733\n656 577\n367 333\n143 977\n711 745\n943 519\n572
      832\n332 541\n333 652\n131 886\n471 581\n607 72\n756 595\n96 873\n416 86\n600
      363\n818 255\n939 537\n588 433\nR L L L L R R L L L R L R R L R L R R R R L
      R R L L R L L L R R L L L R L L L R R L L R L R R L R L L L R L L R L L L R
      L L R R R L R R L R R L L R R L R R R L L L R R L L R R R L R L L L L L R R
      L L R R L L R L R R L R L L R L L L R L L L R L R L R R L L R R R R R L L R
      R R L R R R L R R R L R L R L L R R L R R R L R R R R L L L L R L R R R L L
      R L L R L R R L L R L R L L R R L L R L R R R L R R R R R L L R R R R L R L
      R L L L R R R R L L L L R L L L L L L L L L R R L R R R L R L R R R L R L R
      R R L R L R L L L R R R L R L L R R L L R L L L L L R R L L R R L R R R R L
      L L R R L L R R L R R R L L L L R R R R L R L L R R L R L L L R R L R L L R
      L R L R R R L R L L R R R L R L L R R R R L R L L R L R R R R L R L L R R R
      R L R L L R R L L L L L R L R R L R R R R R R R R R R L R R R L L R R L R R
      R L R R L R L L R R L R R L L R R L R R R L R R R L R R R R R L R R L L R R
      R R L R L L L R R L L R L L L L R L L R L L L R R L R L R L R R L L R R R R
      R R L L L L L R R L R L L L L R L L L R L L\n","outputs":"376\n"},{"inputs":"1000
      500 1000000000\n2 503\n3 504\n4 505\n5 506\n6 507\n7 508\n8 509\n9 510\n10 511\n11
      512\n12 513\n13 514\n14 515\n15 516\n16 517\n17 518\n18 519\n19 520\n20 521\n21
      522\n22 523\n23 524\n24 525\n25 526\n26 527\n27 528\n28 529\n29 530\n30 531\n31
      532\n32 533\n33 534\n34 535\n35 536\n36 537\n37 538\n38 539\n39 540\n40 541\n41
      542\n42 543\n43 544\n44 545\n45 546\n46 547\n47 548\n48 549\n49 550\n50 551\n51
      552\n52 553\n53 554\n54 555\n55 556\n56 557\n57 558\n58 559\n59 560\n60 561\n61
      562\n62 563\n63 564\n64 565\n65 566\n66 567\n67 568\n68 569\n69 570\n70 571\n71
      572\n72 573\n73 574\n74 575\n75 576\n76 577\n77 578\n78 579\n79 580\n80 581\n81
      582\n82 583\n83 584\n84 585\n85 586\n86 587\n87 588\n88 589\n89 590\n90 591\n91
      592\n92 593\n93 594\n94 595\n95 596\n96 597\n97 598\n98 599\n99 600\n100 601\n101
      602\n102 603\n103 604\n104 605\n105 606\n106 607\n107 608\n108 609\n109 610\n110
      611\n111 612\n112 613\n113 614\n114 615\n115 616\n116 617\n117 618\n118 619\n119
      620\n120 621\n121 622\n122 623\n123 624\n124 625\n125 626\n126 627\n127 628\n128
      629\n129 630\n130 631\n131 632\n132 633\n133 634\n134 635\n135 636\n136 637\n137
      638\n138 639\n139 640\n140 641\n141 642\n142 643\n143 644\n144 645\n145 646\n146
      647\n147 648\n148 649\n149 650\n150 651\n151 652\n152 653\n153 654\n154 655\n155
      656\n156 657\n157 658\n158 659\n159 660\n160 661\n161 662\n162 663\n163 664\n164
      665\n165 666\n166 667\n167 668\n168 669\n169 670\n170 671\n171 672\n172 673\n173
      674\n174 675\n175 676\n176 677\n177 678\n178 679\n179 680\n180 681\n181 682\n182
      683\n183 684\n184 685\n185 686\n186 687\n187 688\n188 689\n189 690\n190 691\n191
      692\n192 693\n193 694\n194 695\n195 696\n196 697\n197 698\n198 699\n199 700\n200
      701\n201 702\n202 703\n203 704\n204 705\n205 706\n206 707\n207 708\n208 709\n209
      710\n210 711\n211 712\n212 713\n213 714\n214 715\n215 716\n216 717\n217 718\n218
      719\n219 720\n220 721\n221 722\n222 723\n223 724\n224 725\n225 726\n226 727\n227
      728\n228 729\n229 730\n230 731\n231 732\n232 733\n233 734\n234 735\n235 736\n236
      737\n237 738\n238 739\n239 740\n240 741\n241 742\n242 743\n243 744\n244 745\n245
      746\n246 747\n247 748\n248 749\n249 750\n250 751\n251 752\n252 753\n253 754\n254
      755\n255 756\n256 757\n257 758\n258 759\n259 760\n260 761\n261 762\n262 763\n263
      764\n264 765\n265 766\n266 767\n267 768\n268 769\n269 770\n270 771\n271 772\n272
      773\n273 774\n274 775\n275 776\n276 777\n277 778\n278 779\n279 780\n280 781\n281
      782\n282 783\n283 784\n284 785\n285 786\n286 787\n287 788\n288 789\n289 790\n290
      791\n291 792\n292 793\n293 794\n294 795\n295 796\n296 797\n297 798\n298 799\n299
      800\n300 801\n301 802\n302 803\n303 804\n304 805\n305 806\n306 807\n307 808\n308
      809\n309 810\n310 811\n311 812\n312 813\n313 814\n314 815\n315 816\n316 817\n317
      818\n318 819\n319 820\n320 821\n321 822\n322 823\n323 824\n324 825\n325 826\n326
      827\n327 828\n328 829\n329 830\n330 831\n331 832\n332 833\n333 834\n334 835\n335
      836\n336 837\n337 838\n338 839\n339 840\n340 841\n341 842\n342 843\n343 844\n344
      845\n345 846\n346 847\n347 848\n348 849\n349 850\n350 851\n351 852\n352 853\n353
      854\n354 855\n355 856\n356 857\n357 858\n358 859\n359 860\n360 861\n361 862\n362
      863\n363 864\n364 865\n365 866\n366 867\n367 868\n368 869\n369 870\n370 871\n371
      872\n372 873\n373 874\n374 875\n375 876\n376 877\n377 878\n378 879\n379 880\n380
      881\n381 882\n382 883\n383 884\n384 885\n385 886\n386 887\n387 888\n388 889\n389
      890\n390 891\n391 892\n392 893\n393 894\n394 895\n395 896\n396 897\n397 898\n398
      899\n399 900\n400 901\n401 902\n402 903\n403 904\n404 905\n405 906\n406 907\n407
      908\n408 909\n409 910\n410 911\n411 912\n412 913\n413 914\n414 915\n415 916\n416
      917\n417 918\n418 919\n419 920\n420 921\n421 922\n422 923\n423 924\n424 925\n425
      926\n426 927\n427 928\n428 929\n429 930\n430 931\n431 932\n432 933\n433 934\n434
      935\n435 936\n436 937\n437 938\n438 939\n439 940\n440 941\n441 942\n442 943\n443
      944\n444 945\n445 946\n446 947\n447 948\n448 949\n449 950\n450 951\n451 952\n452
      953\n453 954\n454 955\n455 956\n456 957\n457 958\n458 959\n459 960\n460 961\n461
      962\n462 963\n463 964\n464 965\n465 966\n466 967\n467 968\n468 969\n469 970\n470
      971\n471 972\n472 973\n473 974\n474 975\n475 976\n476 977\n477 978\n478 979\n479
      980\n480 981\n481 982\n482 983\n483 984\n484 985\n485 986\n486 987\n487 988\n488
      989\n489 990\n490 991\n491 992\n492 993\n493 994\n494 995\n495 996\n496 997\n497
      998\n498 999\n499 1000\n500 1\n501 2\n502 3\n503 4\n504 5\n505 6\n506 7\n507
      8\n508 9\n509 10\n510 11\n511 12\n512 13\n513 14\n514 15\n515 16\n516 17\n517
      18\n518 19\n519 20\n520 21\n521 22\n522 23\n523 24\n524 25\n525 26\n526 27\n527
      28\n528 29\n529 30\n530 31\n531 32\n532 33\n533 34\n534 35\n535 36\n536 37\n537
      38\n538 39\n539 40\n540 41\n541 42\n542 43\n543 44\n544 45\n545 46\n546 47\n547
      48\n548 49\n549 50\n550 51\n551 52\n552 53\n553 54\n554 55\n555 56\n556 57\n557
      58\n558 59\n559 60\n560 61\n561 62\n562 63\n563 64\n564 65\n565 66\n566 67\n567
      68\n568 69\n569 70\n570 71\n571 72\n572 73\n573 74\n574 75\n575 76\n576 77\n577
      78\n578 79\n579 80\n580 81\n581 82\n582 83\n583 84\n584 85\n585 86\n586 87\n587
      88\n588 89\n589 90\n590 91\n591 92\n592 93\n593 94\n594 95\n595 96\n596 97\n597
      98\n598 99\n599 100\n600 101\n601 102\n602 103\n603 104\n604 105\n605 106\n606
      107\n607 108\n608 109\n609 110\n610 111\n611 112\n612 113\n613 114\n614 115\n615
      116\n616 117\n617 118\n618 119\n619 120\n620 121\n621 122\n622 123\n623 124\n624
      125\n625 126\n626 127\n627 128\n628 129\n629 130\n630 131\n631 132\n632 133\n633
      134\n634 135\n635 136\n636 137\n637 138\n638 139\n639 140\n640 141\n641 142\n642
      143\n643 144\n644 145\n645 146\n646 147\n647 148\n648 149\n649 150\n650 151\n651
      152\n652 153\n653 154\n654 155\n655 156\n656 157\n657 158\n658 159\n659 160\n660
      161\n661 162\n662 163\n663 164\n664 165\n665 166\n666 167\n667 168\n668 169\n669
      170\n670 171\n671 172\n672 173\n673 174\n674 175\n675 176\n676 177\n677 178\n678
      179\n679 180\n680 181\n681 182\n682 183\n683 184\n684 185\n685 186\n686 187\n687
      188\n688 189\n689 190\n690 191\n691 192\n692 193\n693 194\n694 195\n695 196\n696
      197\n697 198\n698 199\n699 200\n700 201\n701 202\n702 203\n703 204\n704 205\n705
      206\n706 207\n707 208\n708 209\n709 210\n710 211\n711 212\n712 213\n713 214\n714
      215\n715 216\n716 217\n717 218\n718 219\n719 220\n720 221\n721 222\n722 223\n723
      224\n724 225\n725 226\n726 227\n727 228\n728 229\n729 230\n730 231\n731 232\n732
      233\n733 234\n734 235\n735 236\n736 237\n737 238\n738 239\n739 240\n740 241\n741
      242\n742 243\n743 244\n744 245\n745 246\n746 247\n747 248\n748 249\n749 250\n750
      251\n751 252\n752 253\n753 254\n754 255\n755 256\n756 257\n757 258\n758 259\n759
      260\n760 261\n761 262\n762 263\n763 264\n764 265\n765 266\n766 267\n767 268\n768
      269\n769 270\n770 271\n771 272\n772 273\n773 274\n774 275\n775 276\n776 277\n777
      278\n778 279\n779 280\n780 281\n781 282\n782 283\n783 284\n784 285\n785 286\n786
      287\n787 288\n788 289\n789 290\n790 291\n791 292\n792 293\n793 294\n794 295\n795
      296\n796 297\n797 298\n798 299\n799 300\n800 301\n801 302\n802 303\n803 304\n804
      305\n805 306\n806 307\n807 308\n808 309\n809 310\n810 311\n811 312\n812 313\n813
      314\n814 315\n815 316\n816 317\n817 318\n818 319\n819 320\n820 321\n821 322\n822
      323\n823 324\n824 325\n825 326\n826 327\n827 328\n828 329\n829 330\n830 331\n831
      332\n832 333\n833 334\n834 335\n835 336\n836 337\n837 338\n838 339\n839 340\n840
      341\n841 342\n842 343\n843 344\n844 345\n845 346\n846 347\n847 348\n848 349\n849
      350\n850 351\n851 352\n852 353\n853 354\n854 355\n855 356\n856 357\n857 358\n858
      359\n859 360\n860 361\n861 362\n862 363\n863 364\n864 365\n865 366\n866 367\n867
      368\n868 369\n869 370\n870 371\n871 372\n872 373\n873 374\n874 375\n875 376\n876
      377\n877 378\n878 379\n879 380\n880 381\n881 382\n882 383\n883 384\n884 385\n885
      386\n886 387\n887 388\n888 389\n889 390\n890 391\n891 392\n892 393\n893 394\n894
      395\n895 396\n896 397\n897 398\n898 399\n899 400\n900 401\n901 402\n902 403\n903
      404\n904 405\n905 406\n906 407\n907 408\n908 409\n909 410\n910 411\n911 412\n912
      413\n913 414\n914 415\n915 416\n916 417\n917 418\n918 419\n919 420\n920 421\n921
      422\n922 423\n923 424\n924 425\n925 426\n926 427\n927 428\n928 429\n929 430\n930
      431\n931 432\n932 433\n933 434\n934 435\n935 436\n936 437\n937 438\n938 439\n939
      440\n940 441\n941 442\n942 443\n943 444\n944 445\n945 446\n946 447\n947 448\n948
      449\n949 450\n950 451\n951 452\n952 453\n953 454\n954 455\n955 456\n956 457\n957
      458\n958 459\n959 460\n960 461\n961 462\n962 463\n963 464\n964 465\n965 466\n966
      467\n967 468\n968 469\n969 470\n970 471\n971 472\n972 473\n973 474\n974 475\n975
      476\n976 477\n977 478\n978 479\n979 480\n980 481\n981 482\n982 483\n983 484\n984
      485\n985 486\n986 487\n987 488\n988 489\n989 490\n990 491\n991 492\n992 493\n993
      494\n994 495\n995 496\n996 497\n997 498\n998 499\n999 500\n1000 501\n1 502\nL
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L R\n","outputs":"1\n"}],"runtime_limit":2,"status":"in_progress"},"run_type":"chain"}]}'
    headers:
      Accept:
      - application/json
      Accept-Encoding:
      - gzip, deflate
      Connection:
      - keep-alive
      Content-Length:
      - '81419'
      Content-Type:
      - application/json
      User-Agent:
      - langsmith-py/0.1.123
    method: POST
    uri: https://api.smith.langchain.com/runs/batch
  response:
    body:
      string: '{"detail":"Monthly unique traces usage limit exceeded"}'
    headers:
      Access-Control-Allow-Credentials:
      - 'true'
      Access-Control-Allow-Headers:
      - '*'
      Access-Control-Allow-Methods:
      - '*'
      Access-Control-Allow-Origin:
      - ''
      Access-Control-Expose-Headers:
      - '*'
      Access-Control-Max-Age:
      - '600'
      Alt-Svc:
      - h3=":443"; ma=2592000,h3-29=":443"; ma=2592000
      Content-Length:
      - '55'
      Via:
      - 1.1 google
      content-type:
      - application/json
      date:
      - Thu, 19 Sep 2024 18:20:48 GMT
      server:
      - uvicorn
    status:
      code: 429
      message: Too Many Requests
- request:
    body: '{"post":[{"id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","start_time":"2024-09-19T18:20:49.020831+00:00","end_time":"2024-09-19T18:20:49.021706+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.020831+00:00"},{"name":"end","time":"2024-09-19T18:20:49.021706+00:00"}],"reference_example_id":null,"parent_run_id":null,"tags":[],"trace_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","dotted_order":"20240919T182049020831Z4c57d2ad-30ab-4dbb-9e27-91ea1605a666","outputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"session_name":"default","name":"LangGraphUpdateState","inputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"run_type":"chain"},{"id":"4a29815d-adc6-4add-9a72-f17a79d2bdf0","start_time":"2024-09-19T18:20:49.021047+00:00","end_time":"2024-09-19T18:20:49.021287+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.021047+00:00"},{"name":"end","time":"2024-09-19T18:20:49.021287+00:00"}],"reference_example_id":null,"parent_run_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","tags":["seq:step:1","langsmith:hidden"],"trace_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","dotted_order":"20240919T182049020831Z4c57d2ad-30ab-4dbb-9e27-91ea1605a666.20240919T182049021047Z4a29815d-adc6-4add-9a72-f17a79d2bdf0","outputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"session_name":"default","name":"ChannelWrite<evaluate,candidate,examples,messages,test_cases,runtime_limit,status>","inputs":{"messages":[["user","Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately."]]},"run_type":"chain"},{"id":"67d57c15-8da9-4657-a1f8-dbc04ed69085","start_time":"2024-09-19T18:20:49.021495+00:00","end_time":"2024-09-19T18:20:49.021655+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.021495+00:00"},{"name":"end","time":"2024-09-19T18:20:49.021655+00:00"}],"reference_example_id":null,"parent_run_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","tags":["seq:step:2"],"trace_id":"4c57d2ad-30ab-4dbb-9e27-91ea1605a666","dotted_order":"20240919T182049020831Z4c57d2ad-30ab-4dbb-9e27-91ea1605a666.20240919T182049021495Z67d57c15-8da9-4657-a1f8-dbc04ed69085","outputs":{"output":"solve"},"session_name":"default","name":"control_edge","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"},{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","additional_kwargs":{},"response_metadata":{},"type":"human","id":"fc1135fe-45a9-4264-9cf1-99db01aeb146","example":false}],"test_cases":[{"inputs":"4
      3 3\n2 4\n3 1\n4 2\n1 3\nL L R\n","outputs":"4\n"},{"inputs":"50 10 10\n6 4\n42
      48\n2 41\n40 8\n17 29\n28 7\n34 46\n4 9\n36 27\n9 37\n28 32\n22 10\n30 48\n16
      31\n11 33\n36 3\n14 39\n45 5\n46 13\n34 23\n29 6\n3 38\n44 30\n21 15\n41 50\n12
      9\n30 24\n45 6\n19 39\n11 14\n2 46\n39 22\n14 9\n48 43\n16 50\n30 9\n32 2\n25
      24\n3 38\n11 24\n25 3\n4 19\n9 22\n10 19\n37 13\n14 25\n36 29\n33 34\n21 48\n33
      2\nL L R L L R R R R R\n","outputs":"50\n"},{"inputs":"100 20 100\n39 28\n29
      65\n8 76\n23 97\n78 21\n100 63\n95 59\n59 63\n31 16\n83 82\n95 53\n52 13\n50
      2\n29 46\n52 69\n57 91\n96 85\n7 4\n13 29\n52 42\n1 51\n4 95\n62 14\n9 92\n29
      92\n44 29\n87 45\n31 15\n91 34\n36 47\n84 82\n86 48\n11 38\n89 11\n40 44\n58
      1\n57 18\n45 37\n9 70\n12 5\n50 98\n49 32\n65 39\n66 100\n38 41\n30 73\n23 68\n72
      33\n5 60\n95 44\n55 4\n97 11\n22 41\n47 82\n62 58\n86 11\n8 35\n43 72\n25 8\n23
      14\n100 4\n86 22\n71 9\n6 27\n68 53\n23 22\n8 19\n84 81\n59 31\n63 72\n40 48\n82
      99\n34 76\n22 11\n35 44\n24 35\n48 62\n56 18\n70 14\n45 90\n66 19\n63 73\n37
      47\n54 47\n29 16\n18 68\n15 51\n19 1\n27 40\n11 61\n84 86\n95 83\n47 3\n100
      17\n16 96\n58 81\n14 20\n5 2\n66 58\n48 94\nR R L L L L L L R L L L R R L L
      R L L L\n","outputs":"84\n"},{"inputs":"500 50 1000\n308 171\n115 440\n166 2\n202
      52\n111 430\n470 467\n289 254\n87 79\n486 167\n335 452\n346 435\n249 459\n34
      10\n497 299\n139 123\n162 446\n293 276\n385 458\n130 439\n361 92\n368 183\n410
      156\n436 496\n235 274\n163 421\n225 8\n355 473\n318 389\n482 314\n187 121\n436
      201\n418 81\n328 155\n38 457\n93 251\n400 460\n433 310\n468 220\n305 54\n493
      319\n474 217\n326 328\n42 143\n216 23\n308 255\n495 244\n307 413\n324 134\n419
      213\n443 11\n315 194\n322 99\n3 141\n319 160\n194 311\n478 167\n380 156\n347
      421\n298 414\n443 106\n20 290\n201 326\n202 376\n460 472\n440 254\n482 107\n447
      155\n205 302\n296 23\n313 489\n334 290\n8 213\n297 354\n485 447\n119 279\n52
      139\n68 104\n464 121\n331 275\n92 270\n28 425\n376 327\n80 81\n128 375\n455
      440\n215 288\n81 222\n352 378\n427 188\n176 46\n467 227\n184 34\n182 499\n7
      364\n274 98\n133 153\n23 361\n479 102\n293 458\n328 99\n397 42\n239 330\n116
      90\n59 42\n278 234\n439 96\n312 474\n129 345\n473 135\n208 98\n85 192\n250 107\n404
      229\n60 48\n186 387\n147 435\n280 385\n116 395\n326 26\n289 103\n259 79\n50
      422\n53 179\n266 377\n165 473\n474 101\n164 223\n59 420\n303 118\n467 341\n356
      113\n127 488\n497 242\n234 323\n267 22\n277 377\n453 327\n298 5\n357 63\n233
      373\n387 206\n474 402\n428 384\n321 83\n354 288\n423 209\n400 49\n48 249\n142
      282\n71 408\n155 199\n136 107\n377 433\n111 233\n347 343\n458 233\n400 431\n486
      180\n166 307\n262 19\n94 184\n80 345\n84 127\n445 225\n408 15\n484 63\n66 119\n169
      442\n51 132\n27 397\n326 484\n481 78\n414 466\n257 79\n124 18\n450 217\n53 29\n414
      136\n155 358\n212 415\n225 195\n329 290\n313 349\n83 215\n480 109\n463 158\n92
      295\n87 357\n260 343\n288 384\n212 237\n452 264\n265 217\n251 271\n75 314\n185
      151\n8 13\n292 172\n362 374\n238 193\n335 200\n494 288\n135 105\n482 422\n340
      193\n10 144\n308 274\n212 58\n396 138\n371 81\n288 230\n445 431\n253 158\n305
      490\n203 491\n41 404\n268 386\n44 402\n491 25\n323 182\n70 332\n177 377\n457
      389\n287 353\n26 9\n285 314\n91 229\n244 343\n239 400\n333 441\n242 225\n344
      10\n111 239\n411 453\n116 86\n134 185\n269 311\n413 226\n51 199\n430 76\n60
      66\n241 150\n146 337\n492 384\n88 176\n324 330\n401 20\n339 11\n258 101\n463
      373\n186 448\n409 307\n110 322\n32 160\n372 313\n88 431\n378 328\n80 23\n16
      72\n259 104\n99 82\n433 499\n453 123\n361 211\n75 323\n435 113\n271 196\n419
      232\n17 302\n392 388\n466 479\n319 343\n158 250\n217 174\n321 475\n277 272\n409
      61\n270 361\n35 131\n423 461\n305 210\n73 427\n257 491\n159 125\n144 402\n12
      109\n232 182\n303 389\n284 372\n62 104\n346 190\n227 106\n102 497\n319 136\n479
      241\n97 135\n302 21\n62 58\n364 72\n182 7\n473 46\n468 204\n79 270\n444 362\n141
      6\n318 339\n47 44\n296 149\n392 114\n136 370\n207 84\n357 360\n105 418\n418
      468\n341 451\n326 165\n348 293\n368 427\n415 163\n140 407\n168 309\n245 67\n353
      393\n215 244\n6 350\n466 212\n434 174\n424 390\n91 341\n357 283\n143 34\n447
      491\n179 166\n269 93\n328 260\n499 348\n69 96\n414 273\n488 480\n368 345\n329
      333\n409 114\n6 332\n3 448\n24 211\n82 18\n97 28\n360 275\n45 128\n367 373\n240
      217\n220 160\n164 485\n432 3\n464 299\n348 144\n484 108\n110 341\n439 464\n141
      314\n175 222\n331 123\n102 191\n397 146\n170 115\n18 409\n183 89\n68 347\n73
      499\n201 388\n150 400\n32 133\n7 141\n473 297\n104 113\n110 130\n335 441\n252
      436\n131 500\n81 300\n114 451\n61 149\n391 480\n495 464\n479 47\n203 480\n447
      234\n112 453\n226 84\n102 182\n49 211\n163 383\n3 267\n170 133\n266 102\n285
      232\n404 197\n380 295\n176 226\n110 6\n272 312\n485 70\n398 96\n375 475\n32
      476\n156 80\n186 171\n314 41\n437 335\n173 54\n288 309\n285 192\n5 16\n486 181\n241
      447\n38 365\n258 23\n434 7\n470 308\n482 1\n135 489\n432 321\n11 97\n213 447\n431
      385\n353 219\n46 489\n262 402\n5 99\n434 97\n45 472\n313 154\n494 247\n13 315\n406
      494\n168 41\n334 99\n213 345\n48 425\n143 330\n161 347\n400 58\n336 161\n460
      192\n111 393\n140 155\n364 453\n161 209\n51 173\n376 456\n18 43\n348 203\n493
      412\n47 40\n336 42\n370 349\n388 269\n406 75\n282 217\n266 392\n110 406\n399
      325\n358 59\n386 260\n83 261\n215 100\n155 415\n154 147\n326 201\n39 14\n94
      260\n214 481\n28 471\n56 161\n188 173\n53 149\n78 451\n473 287\n361 210\n46
      443\n470 113\n394 476\n379 399\n123 56\n99 13\n69 44\n272 134\n377 151\n105
      432\n312 292\n456 216\n440 34\n18 264\n172 378\n474 70\n172 295\n182 417\n271
      412\n315 245\n467 266\nR L R L R R L R L R L L L R R R R L L L R R L L R L R
      L L L R L R R R R L R L R R R L R L L R L L R\n","outputs":"98\n"},{"inputs":"500
      50 100000\n232 214\n427 64\n280 272\n267 102\n27 177\n431 212\n207 151\n284
      14\n246 371\n61 59\n195 134\n341 129\n169 398\n224 250\n173 395\n317 256\n109
      96\n171 240\n367 437\n341 393\n465 124\n105 23\n274 388\n36 20\n110 96\n430
      157\n82 270\n285 250\n20 360\n352 192\n255 20\n448 215\n115 118\n454 482\n407
      146\n226 223\n269 182\n246 395\n70 281\n414 31\n229 195\n187 310\n464 324\n411
      483\n35 262\n27 141\n282 474\n355 248\n443 308\n229 201\n454 307\n424 74\n488
      169\n468 409\n301 233\n440 29\n427 478\n190 243\n153 101\n77 188\n362 103\n328
      495\n76 183\n243 371\n342 323\n71 147\n129 494\n221 117\n14 40\n25 167\n273
      316\n47 51\n294 237\n293 446\n337 370\n485 50\n472 313\n45 400\n347 139\n270
      40\n461 192\n187 442\n38 259\n410 51\n298 434\n69 422\n250 116\n473 395\n352
      117\n340 188\n486 325\n89 310\n489 485\n209 335\n123 330\n374 436\n373 412\n377
      410\n22 286\n313 320\n71 381\n93 172\n348 417\n66 199\n34 258\n238 371\n434
      327\n180 422\n311 240\n108 286\n421 333\n221 294\n245 449\n55 266\n86 219\n437
      8\n452 382\n180 299\n298 245\n350 331\n354 87\n202 287\n265 233\n208 428\n473
      167\n213 245\n500 285\n390 96\n85 445\n361 22\n15 150\n29 466\n31 208\n117 328\n305
      466\n11 10\n404 64\n297 169\n296 356\n448 120\n23 160\n365 22\n296 254\n469
      232\n50 181\n253 65\n330 281\n30 212\n341 498\n40 497\n463 402\n6 367\n465 302\n387
      260\n10 334\n380 32\n345 96\n405 492\n349 373\n223 251\n53 475\n315 235\n107
      196\n446 447\n194 337\n443 8\n238 301\n226 202\n454 112\n314 463\n297 45\n494
      493\n140 250\n484 340\n474 206\n90 27\n32 256\n113 139\n452 58\n437 497\n395
      380\n4 484\n32 230\n186 485\n193 351\n448 342\n395 293\n334 386\n395 318\n77
      368\n375 19\n246 407\n274 358\n45 77\n416 333\n425 162\n64 281\n145 95\n362
      182\n80 54\n32 379\n395 278\n171 229\n15 65\n398 92\n285 272\n462 30\n30 87\n388
      426\n16 155\n259 440\n316 322\n72 312\n417 433\n494 348\n339 377\n226 233\n155
      248\n313 21\n165 62\n112 449\n186 425\n478 215\n12 217\n141 27\n371 399\n318
      38\n72 390\n202 488\n174 47\n335 12\n423 412\n97 429\n160 409\n450 324\n323
      413\n272 8\n338 101\n222 201\n318 362\n79 40\n112 248\n78 184\n137 131\n23 311\n177
      210\n174 99\n121 270\n380 132\n31 329\n455 353\n93 78\n360 282\n179 81\n482
      348\n295 60\n387 258\n308 316\n293 296\n446 316\n458 474\n377 132\n73 497\n401
      452\n129 431\n132 435\n135 224\n365 494\n6 43\n427 487\n242 73\n399 128\n330
      58\n296 475\n205 93\n142 163\n67 18\n146 139\n366 398\n442 346\n329 73\n281
      463\n148 145\n309 153\n39 235\n492 280\n307 242\n259 488\n299 406\n462 3\n499
      455\n17 65\n472 162\n55 338\n60 348\n35 240\n272 315\n54 419\n311 362\n424 201\n448
      415\n480 106\n8 91\n446 306\n496 259\n160 346\n214 29\n262 185\n42 316\n374
      453\n15 409\n44 286\n75 98\n57 386\n311 480\n438 111\n246 270\n216 253\n360
      13\n410 207\n272 421\n53 485\n449 314\n21 343\n482 395\n295 496\n155 339\n134
      229\n288 190\n466 450\n21 404\n60 266\n25 128\n370 384\n140 279\n442 263\n51
      494\n247 352\n160 120\n194 493\n14 340\n340 20\n30 473\n100 317\n14 418\n119
      386\n173 30\n151 197\n157 372\n80 149\n2 373\n411 53\n367 10\n404 378\n129 449\n370
      494\n288 209\n13 318\n34 464\n486 399\n381 456\n285 53\n486 287\n249 142\n159
      180\n142 160\n53 405\n212 271\n414 467\n500 42\n415 221\n35 203\n281 399\n372
      166\n362 209\n65 95\n165 349\n499 150\n135 248\n143 145\n279 137\n305 183\n41
      368\n305 454\n335 156\n347 101\n376 381\n303 157\n131 26\n322 344\n87 238\n438
      251\n86 437\n252 73\n36 394\n217 166\n30 373\n201 70\n241 357\n375 427\n13 221\n27
      240\n453 182\n248 83\n207 70\n279 145\n159 68\n395 97\n4 146\n169 391\n392 237\n409
      273\n462 109\n195 54\n465 69\n480 329\n142 358\n69 94\n39 316\n29 98\n237 307\n242
      396\n374 137\n492 230\n134 12\n472 377\n100 380\n2 61\n488 196\n114 305\n116
      445\n133 257\n303 201\n351 341\n17 231\n290 105\n389 32\n500 262\n20 343\n343
      5\n354 315\n382 306\n194 383\n366 34\n430 332\n338 45\n128 470\n154 430\n23
      356\n123 391\n86 412\n495 474\n295 495\n87 314\n337 430\n319 43\n96 52\n348
      289\n286 65\n174 215\n248 11\n111 376\n333 264\n157 207\n119 279\n97 204\n43
      91\n29 337\n437 116\n151 126\n45 321\n20 492\n224 219\n280 9\n283 454\n75 31\n316
      185\n258 500\n301 414\n206 419\n45 154\n475 87\n97 3\n423 33\n118 425\n10 14\n97
      381\n5 320\n99 137\n180 382\n442 106\n264 109\n291 21\n109 91\n286 166\n361
      330\n320 335\n190 191\n300 307\n467 162\nR L L R R R R R L L L R R L R R L L
      L R L R R R L L R L R L R R R L R R L L R R R R R R L R R L R R\n","outputs":"8\n"},{"inputs":"1000
      50 9999999\n254 68\n223 790\n92 307\n449 109\n757 626\n770 110\n500 640\n499
      995\n418 127\n60 988\n702 267\n568 740\n837 423\n996 176\n895 955\n505 148\n22
      727\n289 466\n34 90\n574 142\n715 695\n252 567\n687 102\n561 456\n229 972\n444
      282\n238 11\n373 74\n785 369\n601 680\n323 457\n179 696\n184 820\n513 569\n909
      438\n710 975\n133 313\n541 819\n415 453\n626 995\n776 69\n628 13\n80 1\n438
      216\n721 391\n247 395\n847 426\n442 382\n245 955\n302 505\n392 364\n479 876\n28
      372\n46 794\n824 672\n788 952\n740 768\n316 171\n120 754\n387 840\n496 633\n586
      694\n410 27\n428 6\n981 81\n510 725\n444 341\n600 472\n712 998\n265 887\n21
      405\n838 760\n524 154\n283 643\n259 669\n834 106\n653 419\n151 415\n445 578\n420
      778\n11 282\n502 454\n622 453\n277 685\n802 894\n923 822\n298 113\n934 173\n266
      216\n815 876\n236 1000\n333 240\n418 483\n654 214\n413 426\n343 423\n59 844\n228
      32\n649 505\n716 450\n750 990\n272 399\n102 557\n571 719\n772 385\n594 359\n736
      278\n598 505\n761 604\n718 525\n29 413\n947 87\n256 526\n118 256\n382 185\n706
      131\n174 329\n529 628\n885 99\n346 8\n835 292\n366 570\n569 963\n426 681\n918
      496\n205 946\n908 503\n384 515\n29 853\n771 762\n389 476\n893 915\n156 773\n542
      392\n872 239\n399 58\n530 764\n980 451\n78 405\n131 996\n900 688\n293 159\n190
      29\n674 570\n233 444\n332 622\n271 576\n536 426\n348 429\n817 571\n667 567\n981
      549\n330 960\n999 759\n716 481\n754 968\n520 399\n126 62\n427 799\n631 659\n242
      314\n280 864\n241 167\n289 941\n947 457\n511 614\n23 843\n162 704\n802 512\n463
      518\n344 216\n485 864\n966 610\n925 392\n761 907\n403 2\n573 34\n866 813\n201
      506\n753 147\n315 616\n112 689\n458 625\n393 612\n136 855\n481 480\n422 965\n343
      388\n926 619\n131 686\n525 533\n40 97\n567 257\n910 119\n114 14\n617 428\n981
      729\n117 791\n705 861\n402 841\n67 882\n672 840\n198 366\n579 123\n984 710\n161
      860\n594 552\n957 512\n160 218\n982 273\n583 599\n53 564\n679 521\n354 383\n381
      755\n575 447\n988 598\n638 185\n963 217\n659 298\n278 171\n158 871\n722 114\n735
      881\n331 716\n506 265\n314 558\n828 344\n78 533\n79 458\n287 653\n256 626\n251
      245\n810 565\n461 821\n863 738\n991 20\n961 65\n133 695\n297 815\n410 802\n79
      76\n359 259\n419 436\n791 849\n245 430\n502 852\n55 104\n97 217\n668 909\n389
      882\n647 379\n901 607\n795 385\n301 92\n551 62\n893 982\n137 604\n240 908\n39
      382\n756 636\n811 609\n839 218\n64 935\n786 732\n844 174\n965 842\n904 866\n448
      699\n602 100\n790 153\n161 34\n134 650\n637 725\n557 676\n458 664\n663 621\n273
      501\n838 336\n788 975\n419 983\n148 384\n824 51\n601 623\n749 202\n722 890\n706
      234\n924 191\n883 560\n915 791\n587 373\n455 249\n993 727\n102 182\n62 889\n156
      833\n871 655\n216 694\n57 816\n316 158\n369 389\n47 75\n622 322\n265 857\n882
      180\n647 820\n904 101\n421 248\n827 522\n781 241\n762 288\n425 984\n294 640\n677
      350\n807 344\n507 175\n84 906\n249 57\n227 514\n913 108\n45 560\n928 300\n12
      348\n899 191\n221 31\n783 982\n318 207\n965 611\n846 993\n960 4\n688 819\n178
      771\n724 427\n179 950\n292 92\n410 688\n987 366\n36 237\n556 256\n267 338\n589
      584\n544 905\n546 741\n897 857\n744 584\n675 922\n706 750\n700 236\n700 343\n679
      109\n30 681\n797 368\n399 184\n604 954\n791 870\n292 379\n805 187\n283 350\n928
      531\n558 23\n466 233\n944 523\n982 995\n758 33\n337 437\n469 289\n85 867\n824
      688\n173 614\n557 816\n344 361\n2 978\n62 281\n508 620\n304 325\n204 599\n847
      537\n594 957\n570 282\n393 62\n1000 213\n703 84\n432 526\n772 604\n492 680\n419
      835\n393 772\n165 454\n53 672\n425 356\n997 980\n954 195\n517 899\n151 438\n181
      895\n499 532\n460 553\n615 891\n431 386\n846 922\n418 616\n108 810\n387 272\n615
      439\n296 392\n146 292\n371 452\n838 887\n702 989\n324 234\n883 175\n765 342\n79
      380\n584 509\n117 781\n430 534\n396 890\n695 783\n161 310\n573 456\n701 71\n99
      71\n522 937\n310 575\n277 985\n809 159\n159 573\n853 238\n304 788\n98 421\n569
      528\n306 964\n769 353\n98 929\n662 671\n737 714\n741 835\n136 614\n123 445\n188
      399\n430 996\n910 940\n921 114\n529 224\n901 627\n996 821\n506 654\n137 274\n6
      234\n554 19\n256 290\n732 348\n477 867\n961 599\n664 501\n998 445\n496 259\n736
      768\n372 265\n992 624\n243 987\n797 748\n992 933\n373 997\n518 926\n15 774\n216
      98\n121 692\n317 434\n642 980\n934 639\n776 781\n249 511\n549 620\n127 540\n596
      369\n878 392\n116 870\n676 488\n218 193\n766 585\n966 981\n682 439\n24 998\n872
      665\n329 157\n656 104\n937 904\n967 837\n524 93\n728 471\n462 958\n862 929\n179
      537\n769 396\n729 534\n980 47\n866 14\n837 889\n11 60\n553 340\n216 208\n795
      504\n112 761\n341 987\n206 420\n457 19\n377 670\n299 555\n206 419\n303 286\n952
      634\n684 169\n647 520\n57 658\n579 962\n349 794\n169 495\n650 632\n608 342\n970
      165\n761 426\n183 138\n95 481\n44 652\n252 346\n290 203\n332 973\n372 978\n493
      780\n987 71\n741 687\n217 262\n182 866\n245 141\n207 215\n305 967\n992 487\n456
      439\n319 852\n90 570\n549 379\n125 880\n704 848\n858 196\n979 196\n618 720\n883
      834\n333 416\n699 577\n556 257\n143 212\n576 135\n50 383\n573 720\n234 662\n290
      783\n393 766\n662 96\n965 519\n643 943\n67 260\n14 949\n94 346\n716 144\n275
      623\n753 417\n834 328\n551 883\n710 123\n602 944\n137 243\n78 881\n8 739\n328
      324\n610 322\n267 676\n581 280\n976 26\n978 691\n522 604\n313 274\n20 498\n953
      923\n380 14\n45 333\n309 533\n576 386\n765 935\n125 92\n259 734\n413 877\n761
      346\n508 736\n371 485\n778 244\n440 442\n517 460\n939 821\n382 318\n835 778\n650
      143\n663 577\n529 427\n512 5\n871 122\n90 635\n350 850\n980 857\n937 703\n694
      66\n298 133\n507 167\n592 445\n987 325\n762 821\n455 763\n316 117\n340 196\n543
      203\n200 765\n676 641\n400 25\n842 731\n881 130\n785 926\n195 83\n59 701\n249
      2\n145 235\n327 258\n408 781\n372 75\n249 63\n270 143\n265 821\n908 292\n813
      659\n316 654\n389 549\n783 174\n474 977\n256 884\n29 856\n886 525\n90 564\n782
      849\n696 153\n923 944\n216 544\n86 832\n716 345\n476 528\n3 143\n181 392\n43
      315\n917 517\n643 524\n752 671\n379 637\n195 468\n200 328\n669 895\n833 943\n190
      400\n487 276\n231 202\n620 58\n82 623\n201 262\n366 243\n929 282\n111 571\n805
      863\n242 183\n851 788\n2 403\n116 670\n297 948\n965 487\n347 451\n114 929\n4
      733\n339 85\n707 539\n699 72\n133 627\n705 244\n549 509\n458 790\n43 308\n930
      45\n710 45\n66 359\n344 30\n197 42\n832 310\n322 188\n394 660\n624 453\n550
      674\n876 683\n652 581\n278 201\n441 87\n990 484\n746 919\n880 456\n315 297\n166
      10\n679 714\n403 510\n375 77\n49 768\n88 673\n572 638\n698 448\n672 350\n380
      949\n550 820\n387 539\n655 132\n810 886\n939 476\n183 104\n838 861\n817 592\n722
      543\n668 123\n311 756\n795 234\n745 844\n33 416\n193 412\n716 742\n584 454\n633
      590\n585 794\n476 524\n621 10\n979 458\n870 148\n402 943\n690 69\n65 352\n176
      211\n586 920\n55 618\n687 247\n382 754\n989 317\n207 973\n906 792\n766 733\n667
      386\n742 645\n196 963\n792 597\n906 482\n17 970\n185 545\n181 770\n816 587\n740
      855\n833 473\n608 173\n789 167\n145 46\n310 262\n779 976\n1000 872\n972 547\n835
      116\n495 740\n597 511\n61 133\n407 593\n903 223\n179 994\n77 12\n466 36\n536
      606\n202 33\n651 863\n294 781\n190 293\n5 162\n191 839\n277 685\n930 225\n548
      990\n357 954\n583 611\n176 113\n956 604\n476 421\n640 12\n378 193\n44 381\n56
      689\n513 597\n334 517\n110 524\n355 386\n209 636\n962 756\n978 671\n709 912\n633
      237\n24 589\n840 500\n9 831\n863 739\n24 258\n119 431\n946 631\n27 631\n148
      137\n155 854\n874 715\n490 188\n858 882\n378 490\n118 753\n430 310\n252 791\n140
      466\n529 163\n723 647\n945 21\n277 324\n651 776\n812 157\n982 37\n223 471\n224
      44\n289 433\n926 18\n275 395\n770 704\n704 374\n494 196\n839 22\n710 914\n20
      655\n934 649\n330 936\n424 141\n445 405\n177 667\n227 753\n63 867\n185 988\n884
      811\n734 6\n867 790\n731 712\n985 921\n734 46\n834 105\n700 119\n753 29\n407
      529\n521 851\n933 698\n869 512\n802 931\n378 338\n270 614\n149 4\n971 367\n793
      701\n78 129\n621 811\n174 807\n268 226\n277 20\n606 683\n548 127\n885 833\n176
      754\n696 329\n684 425\n666 306\n38 166\n309 360\n532 453\n60 610\n581 33\n420
      106\n839 39\n331 115\n59 289\n150 958\n415 34\n142 942\n139 837\n270 175\n262
      287\n480 651\n453 788\n363 984\n240 422\n593 172\n806 365\n277 996\n403 960\n463
      813\n248 612\n771 14\n997 264\n307 136\n101 928\n310 714\n214 789\n716 666\n928
      78\n650 519\n852 242\n690 9\n606 318\n5 361\n629 467\n173 228\n430 943\n593
      426\n559 251\n561 659\n178 222\n724 744\n362 791\n409 289\n221 410\n159 424\n652
      848\n432 609\n518 436\n321 498\n902 494\n78 331\n788 670\n109 346\n921 21\n356
      450\n243 79\n193 956\n222 954\n245 442\n363 403\n865 366\n603 296\n327 472\n84
      647\n321 337\n140 398\n20 928\n420 128\n273 692\n148 981\n141 742\n59 334\n698
      632\n287 294\n73 1\n48 289\n367 2\n585 693\n473 20\n339 794\n356 479\n543 375\n758
      962\n502 382\n653 2\n362 146\n95 773\n479 792\n404 117\n85 477\n117 485\n765
      835\n486 701\n527 959\n720 866\n104 428\n696 998\n802 453\n312 656\n186 964\n657
      548\n109 751\n320 939\n895 723\n407 331\n551 876\n815 316\n710 301\n368 589\n611
      440\n806 66\nR R R L R L R L L R R L L L R L R R L R L R L L R L L R R R L R
      R L L R L R L R R R L L L L R L R R\n","outputs":"765\n"},{"inputs":"1000 500
      1\n2 501\n3 502\n4 503\n5 504\n6 505\n7 506\n8 507\n9 508\n10 509\n11 510\n12
      511\n13 512\n14 513\n15 514\n16 515\n17 516\n18 517\n19 518\n20 519\n21 520\n22
      521\n23 522\n24 523\n25 524\n26 525\n27 526\n28 527\n29 528\n30 529\n31 530\n32
      531\n33 532\n34 533\n35 534\n36 535\n37 536\n38 537\n39 538\n40 539\n41 540\n42
      541\n43 542\n44 543\n45 544\n46 545\n47 546\n48 547\n49 548\n50 549\n51 550\n52
      551\n53 552\n54 553\n55 554\n56 555\n57 556\n58 557\n59 558\n60 559\n61 560\n62
      561\n63 562\n64 563\n65 564\n66 565\n67 566\n68 567\n69 568\n70 569\n71 570\n72
      571\n73 572\n74 573\n75 574\n76 575\n77 576\n78 577\n79 578\n80 579\n81 580\n82
      581\n83 582\n84 583\n85 584\n86 585\n87 586\n88 587\n89 588\n90 589\n91 590\n92
      591\n93 592\n94 593\n95 594\n96 595\n97 596\n98 597\n99 598\n100 599\n101 600\n102
      601\n103 602\n104 603\n105 604\n106 605\n107 606\n108 607\n109 608\n110 609\n111
      610\n112 611\n113 612\n114 613\n115 614\n116 615\n117 616\n118 617\n119 618\n120
      619\n121 620\n122 621\n123 622\n124 623\n125 624\n126 625\n127 626\n128 627\n129
      628\n130 629\n131 630\n132 631\n133 632\n134 633\n135 634\n136 635\n137 636\n138
      637\n139 638\n140 639\n141 640\n142 641\n143 642\n144 643\n145 644\n146 645\n147
      646\n148 647\n149 648\n150 649\n151 650\n152 651\n153 652\n154 653\n155 654\n156
      655\n157 656\n158 657\n159 658\n160 659\n161 660\n162 661\n163 662\n164 663\n165
      664\n166 665\n167 666\n168 667\n169 668\n170 669\n171 670\n172 671\n173 672\n174
      673\n175 674\n176 675\n177 676\n178 677\n179 678\n180 679\n181 680\n182 681\n183
      682\n184 683\n185 684\n186 685\n187 686\n188 687\n189 688\n190 689\n191 690\n192
      691\n193 692\n194 693\n195 694\n196 695\n197 696\n198 697\n199 698\n200 699\n201
      700\n202 701\n203 702\n204 703\n205 704\n206 705\n207 706\n208 707\n209 708\n210
      709\n211 710\n212 711\n213 712\n214 713\n215 714\n216 715\n217 716\n218 717\n219
      718\n220 719\n221 720\n222 721\n223 722\n224 723\n225 724\n226 725\n227 726\n228
      727\n229 728\n230 729\n231 730\n232 731\n233 732\n234 733\n235 734\n236 735\n237
      736\n238 737\n239 738\n240 739\n241 740\n242 741\n243 742\n244 743\n245 744\n246
      745\n247 746\n248 747\n249 748\n250 749\n251 750\n252 751\n253 752\n254 753\n255
      754\n256 755\n257 756\n258 757\n259 758\n260 759\n261 760\n262 761\n263 762\n264
      763\n265 764\n266 765\n267 766\n268 767\n269 768\n270 769\n271 770\n272 771\n273
      772\n274 773\n275 774\n276 775\n277 776\n278 777\n279 778\n280 779\n281 780\n282
      781\n283 782\n284 783\n285 784\n286 785\n287 786\n288 787\n289 788\n290 789\n291
      790\n292 791\n293 792\n294 793\n295 794\n296 795\n297 796\n298 797\n299 798\n300
      799\n301 800\n302 801\n303 802\n304 803\n305 804\n306 805\n307 806\n308 807\n309
      808\n310 809\n311 810\n312 811\n313 812\n314 813\n315 814\n316 815\n317 816\n318
      817\n319 818\n320 819\n321 820\n322 821\n323 822\n324 823\n325 824\n326 825\n327
      826\n328 827\n329 828\n330 829\n331 830\n332 831\n333 832\n334 833\n335 834\n336
      835\n337 836\n338 837\n339 838\n340 839\n341 840\n342 841\n343 842\n344 843\n345
      844\n346 845\n347 846\n348 847\n349 848\n350 849\n351 850\n352 851\n353 852\n354
      853\n355 854\n356 855\n357 856\n358 857\n359 858\n360 859\n361 860\n362 861\n363
      862\n364 863\n365 864\n366 865\n367 866\n368 867\n369 868\n370 869\n371 870\n372
      871\n373 872\n374 873\n375 874\n376 875\n377 876\n378 877\n379 878\n380 879\n381
      880\n382 881\n383 882\n384 883\n385 884\n386 885\n387 886\n388 887\n389 888\n390
      889\n391 890\n392 891\n393 892\n394 893\n395 894\n396 895\n397 896\n398 897\n399
      898\n400 899\n401 900\n402 901\n403 902\n404 903\n405 904\n406 905\n407 906\n408
      907\n409 908\n410 909\n411 910\n412 911\n413 912\n414 913\n415 914\n416 915\n417
      916\n418 917\n419 918\n420 919\n421 920\n422 921\n423 922\n424 923\n425 924\n426
      925\n427 926\n428 927\n429 928\n430 929\n431 930\n432 931\n433 932\n434 933\n435
      934\n436 935\n437 936\n438 937\n439 938\n440 939\n441 940\n442 941\n443 942\n444
      943\n445 944\n446 945\n447 946\n448 947\n449 948\n450 949\n451 950\n452 951\n453
      952\n454 953\n455 954\n456 955\n457 956\n458 957\n459 958\n460 959\n461 960\n462
      961\n463 962\n464 963\n465 964\n466 965\n467 966\n468 967\n469 968\n470 969\n471
      970\n472 971\n473 972\n474 973\n475 974\n476 975\n477 976\n478 977\n479 978\n480
      979\n481 980\n482 981\n483 982\n484 983\n485 984\n486 985\n487 986\n488 987\n489
      988\n490 989\n491 990\n492 991\n493 992\n494 993\n495 994\n496 995\n497 996\n498
      997\n499 998\n500 999\n501 2\n502 3\n503 4\n504 5\n505 6\n506 7\n507 8\n508
      9\n509 10\n510 11\n511 12\n512 13\n513 14\n514 15\n515 16\n516 17\n517 18\n518
      19\n519 20\n520 21\n521 22\n522 23\n523 24\n524 25\n525 26\n526 27\n527 28\n528
      29\n529 30\n530 31\n531 32\n532 33\n533 34\n534 35\n535 36\n536 37\n537 38\n538
      39\n539 40\n540 41\n541 42\n542 43\n543 44\n544 45\n545 46\n546 47\n547 48\n548
      49\n549 50\n550 51\n551 52\n552 53\n553 54\n554 55\n555 56\n556 57\n557 58\n558
      59\n559 60\n560 61\n561 62\n562 63\n563 64\n564 65\n565 66\n566 67\n567 68\n568
      69\n569 70\n570 71\n571 72\n572 73\n573 74\n574 75\n575 76\n576 77\n577 78\n578
      79\n579 80\n580 81\n581 82\n582 83\n583 84\n584 85\n585 86\n586 87\n587 88\n588
      89\n589 90\n590 91\n591 92\n592 93\n593 94\n594 95\n595 96\n596 97\n597 98\n598
      99\n599 100\n600 101\n601 102\n602 103\n603 104\n604 105\n605 106\n606 107\n607
      108\n608 109\n609 110\n610 111\n611 112\n612 113\n613 114\n614 115\n615 116\n616
      117\n617 118\n618 119\n619 120\n620 121\n621 122\n622 123\n623 124\n624 125\n625
      126\n626 127\n627 128\n628 129\n629 130\n630 131\n631 132\n632 133\n633 134\n634
      135\n635 136\n636 137\n637 138\n638 139\n639 140\n640 141\n641 142\n642 143\n643
      144\n644 145\n645 146\n646 147\n647 148\n648 149\n649 150\n650 151\n651 152\n652
      153\n653 154\n654 155\n655 156\n656 157\n657 158\n658 159\n659 160\n660 161\n661
      162\n662 163\n663 164\n664 165\n665 166\n666 167\n667 168\n668 169\n669 170\n670
      171\n671 172\n672 173\n673 174\n674 175\n675 176\n676 177\n677 178\n678 179\n679
      180\n680 181\n681 182\n682 183\n683 184\n684 185\n685 186\n686 187\n687 188\n688
      189\n689 190\n690 191\n691 192\n692 193\n693 194\n694 195\n695 196\n696 197\n697
      198\n698 199\n699 200\n700 201\n701 202\n702 203\n703 204\n704 205\n705 206\n706
      207\n707 208\n708 209\n709 210\n710 211\n711 212\n712 213\n713 214\n714 215\n715
      216\n716 217\n717 218\n718 219\n719 220\n720 221\n721 222\n722 223\n723 224\n724
      225\n725 226\n726 227\n727 228\n728 229\n729 230\n730 231\n731 232\n732 233\n733
      234\n734 235\n735 236\n736 237\n737 238\n738 239\n739 240\n740 241\n741 242\n742
      243\n743 244\n744 245\n745 246\n746 247\n747 248\n748 249\n749 250\n750 251\n751
      252\n752 253\n753 254\n754 255\n755 256\n756 257\n757 258\n758 259\n759 260\n760
      261\n761 262\n762 263\n763 264\n764 265\n765 266\n766 267\n767 268\n768 269\n769
      270\n770 271\n771 272\n772 273\n773 274\n774 275\n775 276\n776 277\n777 278\n778
      279\n779 280\n780 281\n781 282\n782 283\n783 284\n784 285\n785 286\n786 287\n787
      288\n788 289\n789 290\n790 291\n791 292\n792 293\n793 294\n794 295\n795 296\n796
      297\n797 298\n798 299\n799 300\n800 301\n801 302\n802 303\n803 304\n804 305\n805
      306\n806 307\n807 308\n808 309\n809 310\n810 311\n811 312\n812 313\n813 314\n814
      315\n815 316\n816 317\n817 318\n818 319\n819 320\n820 321\n821 322\n822 323\n823
      324\n824 325\n825 326\n826 327\n827 328\n828 329\n829 330\n830 331\n831 332\n832
      333\n833 334\n834 335\n835 336\n836 337\n837 338\n838 339\n839 340\n840 341\n841
      342\n842 343\n843 344\n844 345\n845 346\n846 347\n847 348\n848 349\n849 350\n850
      351\n851 352\n852 353\n853 354\n854 355\n855 356\n856 357\n857 358\n858 359\n859
      360\n860 361\n861 362\n862 363\n863 364\n864 365\n865 366\n866 367\n867 368\n868
      369\n869 370\n870 371\n871 372\n872 373\n873 374\n874 375\n875 376\n876 377\n877
      378\n878 379\n879 380\n880 381\n881 382\n882 383\n883 384\n884 385\n885 386\n886
      387\n887 388\n888 389\n889 390\n890 391\n891 392\n892 393\n893 394\n894 395\n895
      396\n896 397\n897 398\n898 399\n899 400\n900 401\n901 402\n902 403\n903 404\n904
      405\n905 406\n906 407\n907 408\n908 409\n909 410\n910 411\n911 412\n912 413\n913
      414\n914 415\n915 416\n916 417\n917 418\n918 419\n919 420\n920 421\n921 422\n922
      423\n923 424\n924 425\n925 426\n926 427\n927 428\n928 429\n929 430\n930 431\n931
      432\n932 433\n933 434\n934 435\n935 436\n936 437\n937 438\n938 439\n939 440\n940
      441\n941 442\n942 443\n943 444\n944 445\n945 446\n946 447\n947 448\n948 449\n949
      450\n950 451\n951 452\n952 453\n953 454\n954 455\n955 456\n956 457\n957 458\n958
      459\n959 460\n960 461\n961 462\n962 463\n963 464\n964 465\n965 466\n966 467\n967
      468\n968 469\n969 470\n970 471\n971 472\n972 473\n973 474\n974 475\n975 476\n976
      477\n977 478\n978 479\n979 480\n980 481\n981 482\n982 483\n983 484\n984 485\n985
      486\n986 487\n987 488\n988 489\n989 490\n990 491\n991 492\n992 493\n993 494\n994
      495\n995 496\n996 497\n997 498\n998 499\n999 500\n1000 1\n1 500\nL L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L R\n","outputs":"2\n"},{"inputs":"1000
      500 1000000000\n774 167\n876 97\n409 751\n549 934\n598 944\n883 986\n736 191\n125
      761\n126 954\n227 57\n768 279\n295 692\n203 460\n520 341\n875 735\n733 1\n902
      961\n97 310\n711 998\n595 308\n941 477\n645 28\n19 769\n788 496\n723 367\n904
      842\n645 551\n533 199\n10 52\n539 237\n138 624\n237 39\n584 685\n700 646\n682
      646\n953 974\n474 950\n353 845\n70 141\n340 792\n507 596\n633 503\n146 517\n701
      155\n568 592\n391 706\n567 979\n96 502\n664 148\n147 697\n793 451\n671 619\n400
      375\n463 470\n515 154\n613 373\n749 598\n227 894\n114 280\n401 34\n871 143\n739
      789\n122 186\n290 785\n333 788\n833 478\n238 855\n448 990\n230 262\n811 96\n415
      423\n469 516\n372 47\n409 486\n326 161\n519 548\n304 609\n336 777\n794 977\n561
      479\n764 745\n308 354\n600 755\n343 829\n16 153\n924 430\n927 744\n297 299\n791
      706\n136 468\n218 6\n16 521\n614 703\n297 759\n32 209\n237 147\n954 896\n500
      553\n650 194\n733 665\n346 8\n447 625\n752 743\n275 894\n800 410\n361 18\n767
      728\n890 380\n783 187\n490 814\n747 79\n312 52\n974 812\n604 624\n5 688\n640
      703\n696 86\n327 447\n181 953\n692 332\n714 52\n349 480\n132 239\n211 914\n777
      700\n79 523\n778 390\n575 104\n553 530\n79 558\n218 718\n612 265\n156 290\n63
      688\n242 754\n19 955\n157 368\n434 288\n958 644\n553 734\n695 983\n608 825\n725
      534\n928 277\n64 6\n186 633\n75 797\n897 582\n86 311\n269 679\n64 288\n633 220\n7
      418\n860 964\n61 412\n49 756\n747 656\n580 471\n190 859\n99 605\n216 285\n589
      290\n433 837\n872 871\n147 140\n549 210\n779 534\n781 785\n951 640\n100 364\n404
      148\n471 150\n156 402\n972 697\n260 70\n653 827\n706 241\n116 139\n77 339\n361
      223\n831 261\n784 609\n794 564\n746 97\n204 845\n460 607\n345 282\n108 500\n683
      79\n548 294\n148 200\n120 206\n440 587\n344 868\n926 56\n90 756\n316 873\n716
      462\n788 461\n910 991\n658 369\n949 354\n2 56\n205 684\n486 752\n977 986\n303
      448\n191 742\n34 886\n609 959\n941 50\n66 608\n274 134\n69 61\n946 978\n404
      603\n698 352\n308 699\n760 512\n734 245\n263 62\n230 565\n509 420\n658 543\n657
      618\n853 597\n667 919\n205 292\n404 625\n705 349\n955 108\n304 4\n811 611\n55
      922\n123 788\n167 737\n850 748\n302 358\n520 311\n252 176\n929 105\n125 947\n375
      329\n591 130\n305 295\n478 611\n402 781\n615 564\n392 669\n486 514\n808 4\n250
      657\n751 903\n367 622\n214 970\n150 494\n426 274\n440 152\n954 30\n281 258\n676
      759\n221 77\n539 835\n993 282\n855 478\n147 662\n833 749\n319 583\n651 37\n557
      216\n6 706\n709 432\n979 501\n583 284\n882 216\n541 558\n974 113\n986 864\n947
      978\n146 801\n807 644\n815 639\n392 133\n574 395\n521 130\n610 526\n187 671\n309
      517\n523 244\n800 404\n459 692\n313 432\n805 299\n647 103\n628 144\n256 435\n788
      70\n425 179\n554 998\n573 74\n479 535\n951 17\n205 260\n533 727\n503 684\n482
      313\n376 795\n96 532\n445 742\n634 72\n886 241\n858 673\n310 283\n203 863\n280
      776\n936 111\n310 887\n127 866\n498 12\n944 352\n695 425\n664 422\n571 759\n305
      15\n852 291\n87 737\n531 944\n761 841\n578 964\n55 858\n91 991\n320 400\n229
      798\n617 726\n809 560\n77 856\n336 92\n629 907\n202 286\n273 53\n576 359\n790
      458\n655 902\n650 232\n865 705\n441 955\n47 112\n706 627\n910 322\n352 70\n233
      780\n925 569\n871 906\n827 424\n191 99\n476 118\n810 617\n575 816\n519 225\n47
      735\n281 840\n42 679\n303 747\n305 212\n421 656\n634 653\n787 558\n573 9\n815
      399\n432 357\n850 907\n474 659\n876 401\n474 394\n625 872\n128 257\n63 169\n935
      366\n268 239\n929 688\n246 562\n692 384\n472 265\n392 286\n15 823\n995 216\n81
      468\n874 956\n868 699\n701 844\n923 181\n100 337\n701 386\n702 968\n976 983\n7
      221\n544 699\n604 367\n315 347\n5 681\n521 999\n897 954\n466 122\n909 686\n821
      962\n529 95\n142 981\n431 842\n366 485\n162 342\n467 168\n914 362\n218 870\n729
      532\n216 733\n565 737\n83 461\n42 548\n582 950\n585 754\n911 114\n200 404\n446
      631\n246 163\n115 407\n856 933\n926 770\n294 144\n991 374\n27 206\n458 591\n294
      540\n403 335\n440 337\n637 24\n90 899\n137 290\n303 934\n272 900\n97 738\n658
      952\n670 935\n721 315\n78 711\n689 105\n269 498\n47 914\n38 450\n601 477\n786
      237\n500 875\n487 989\n516 141\n922 139\n392 370\n876 49\n322 897\n984 394\n212
      413\n105 252\n869 725\n749 916\n990 138\n365 590\n966 150\n826 818\n376 665\n806
      244\n805 79\n382 197\n449 610\n597 770\n506 932\n163 69\n697 619\n672 565\n695
      773\n480 685\n262 844\n274 228\n345 452\n45 73\n468 850\n316 272\n280 49\n820
      80\n658 769\n201 516\n700 716\n936 396\n686 960\n313 381\n732 792\n417 993\n988
      690\n220 684\n493 616\n756 960\n465 71\n584 97\n472 403\n176 481\n171 729\n996
      223\n444 284\n970 129\n243 282\n509 326\n426 277\n318 765\n319 890\n448 811\n505
      204\n123 322\n626 706\n770 97\n460 297\n578 983\n25 925\n557 468\n208 526\n597
      802\n160 457\n127 585\n86 797\n349 404\n38 796\n214 894\n351 688\n567 977\n393
      336\n73 205\n633 2\n187 9\n927 95\n477 486\n620 425\n640 131\n233 766\n67 318\n914
      415\n721 303\n563 287\n197 265\n974 115\n241 719\n451 666\n923 435\n19 461\n443
      945\n555 271\n783 526\n47 422\n657 632\n539 723\n949 805\n490 22\n107 404\n660
      655\n668 633\n770 261\n351 572\n278 625\n358 296\n437 152\n593 991\n423 375\n869
      821\n148 877\n452 38\n599 753\n194 440\n774 301\n843 433\n307 863\n417 428\n123
      120\n999 400\n96 356\n695 533\n508 639\n875 282\n13 743\n102 512\n971 906\n902
      922\n658 95\n361 783\n747 556\n567 54\n770 335\n481 892\n454 832\n643 550\n539
      689\n434 46\n328 308\n679 692\n403 133\n556 725\n38 457\n646 47\n551 359\n829
      298\n914 747\n703 683\n81 535\n926 887\n366 568\n788 905\n608 573\n302 935\n232
      981\n979 986\n465 534\n711 502\n990 356\n900 892\n714 80\n541 979\n826 243\n13
      258\n778 938\n144 495\n857 283\n399 817\n855 53\n751 87\n385 81\n72 849\n614
      782\n350 955\n490 249\n847 555\n328 739\n534 505\n982 546\n114 111\n836 258\n605
      44\n892 356\n860 99\n408 963\n185 792\n43 608\n992 657\n742 341\n963 231\n941
      161\n785 620\n900 670\n476 233\n568 589\n343 403\n198 299\n446 442\n654 658\n540
      413\n620 724\n556 662\n683 547\n670 424\n239 985\n654 531\n145 791\n502 396\n460
      977\n628 27\n918 970\n429 115\n621 227\n556 626\n236 95\n39 855\n170 594\n868
      853\n493 538\n276 731\n522 282\n262 18\n72 763\n414 531\n92 41\n910 9\n363 690\n475
      335\n268 383\n960 503\n829 998\n357 999\n944 225\n203 436\n114 830\n166 987\n111
      779\n4 182\n894 769\n65 985\n810 326\n345 524\n15 819\n858 283\n553 817\n785
      382\n815 494\n380 110\n718 934\n545 183\n763 62\n169 874\n841 524\n407 86\n293
      823\n70 454\n148 766\n977 163\n936 186\n445 489\n2 581\n870 168\n74 601\n277
      143\n534 173\n325 648\n235 493\n521 427\n369 280\n512 661\n102 933\n114 250\n698
      442\n764 633\n627 560\n473 628\n140 342\n148 566\n294 776\n708 827\n949 33\n827
      535\n877 347\n313 597\n978 176\n257 80\n108 722\n681 157\n163 796\n141 789\n355
      614\n769 846\n955 268\n411 249\n43 119\n427 343\n503 253\n229 731\n952 541\n328
      929\n716 936\n360 175\n658 392\n331 172\n187 472\n961 893\n85 81\n739 391\n348
      149\n991 390\n619 418\n85 473\n22 313\n556 325\n206 235\n606 921\n170 317\n96
      179\n709 778\n351 247\n249 663\n140 685\n743 878\n76 90\n378 66\n831 997\n835
      915\n821 209\n580 376\n533 785\n610 490\n57 132\n807 504\n310 867\n282 12\n113
      882\n674 252\n567 416\n129 642\n857 859\n59 40\n855 246\n306 27\n454 885\n403
      338\n21 364\n828 78\n495 986\n581 157\n852 214\n520 964\n96 194\n216 14\n961
      696\n7 170\n554 65\n209 760\n310 514\n787 115\n751 541\n453 771\n256 632\n200
      103\n617 133\n259 468\n346 778\n431 793\n323 998\n806 284\n46 812\n453 599\n229
      13\n711 538\n526 849\n5 628\n741 457\n399 996\n88 950\n98 56\n82 708\n523 780\n838
      305\n572 160\n303 730\n795 700\n541 599\n650 121\n611 360\n659 489\n560 15\n116
      300\n471 866\n648 910\n816 745\n965 897\n805 839\n676 642\n495 600\n801 149\n329
      948\n848 869\n546 498\n990 157\n209 1000\n645 769\n366 112\n420 836\n978 67\n97
      793\n164 413\n41 320\n603 69\n961 97\n668 113\n246 996\n60 93\n216 606\n590
      557\n114 151\n908 110\n271 273\n221 690\n460 550\n109 908\n694 624\n672 87\n943
      274\n155 903\n371 822\n367 968\n169 427\n60 384\n384 2\n293 497\n504 200\n958
      774\n825 530\n463 636\n80 923\n544 125\n546 215\n211 840\n841 365\n94 563\n186
      461\n530 706\n239 941\n442 622\n294 734\n470 797\n285 779\n922 109\n308 385\n97
      387\n659 640\n512 557\n206 722\n396 398\n439 490\n960 976\n302 841\n682 892\n782
      123\n513 427\n856 334\n576 492\n112 497\n953 771\n233 49\n158 244\n40 21\n800
      245\n94 195\n643 884\n36 954\n860 689\n795 541\n580 928\n15 444\n354 222\n129
      281\n713 592\n130 665\n363 362\n65 520\n605 104\n892 756\n349 337\n303 343\n221
      690\n296 80\n379 442\n972 310\n369 338\n754 75\n559 882\n355 623\n474 484\n640
      836\n198 704\n707 154\n808 950\n910 156\n638 564\n850 858\n253 497\n289 631\n939
      612\n941 307\n949 46\n381 859\n279 88\n482 104\n571 473\n939 120\n176 997\n274
      983\n298 535\n490 936\n98 339\n145 350\n836 434\n333 774\n397 625\n432 698\n22
      165\n556 300\n252 389\n404 174\n861 694\n294 37\n43 919\n371 340\n805 861\n275
      902\n199 420\n603 386\n205 287\n511 601\n263 943\n650 284\n459 558\nL L L R
      R R L L R L L R L L R L R L R L R R L L L R L R L L L R R L R R L R R L L L
      L R L R R L L R R L L R R R R L R L R R R R L R L R R L L R R R R L R R L L
      L L L R L L R L L R L L R L R L L L L R R R R R L R R L L L L R R R R R L R
      L R R R R L L R R L L R L L R L L L L L L R R R R L R R L L R R R L L R R R
      R R L L R R R L L L R L L L L L L R R L R L L L R L R L L R L L R L R L L R
      R L L R R R R L R L L R L R R R L R L L L R L R L L L L R L L R R R L R L L
      L L R L L L L L L R L R L R R R L L L R R R L L R L R L L L R L R L R L R L
      L R L R R R L L R R R L R L L R R R L R L L L R R L L R L L L R L R R R R L
      L R L L L R R L R L L L L R R L R R R L R L L L L R L R R L L L L L L L L L
      R L R L R R L L L R L L L R L R L R L L R L R R L R L R L R L L L R R L R L
      R L L R R L R L L L R R R R R L R L L L L R L R L R R L R R R R L R R R L R
      L R R L L R R L L R R R R L R L L L R R R R R L R R L L R R L L R L L L R L
      R L L R R L L R L L R L L R L L L L L R R L R R L L L R R L L L L R L L R L
      L L\n","outputs":"935\n"},{"inputs":"1000 500 1000000000\n647 576\n436 5\n85
      30\n442 896\n420 198\n770 909\n516 565\n705 437\n121 306\n789 823\n224 303\n288
      84\n945 31\n118 263\n176 304\n835 174\n879 622\n179 315\n651 620\n211 422\n169
      980\n683 37\n897 387\n825 17\n44 965\n191 268\n267 479\n351 563\n509 820\n177
      36\n475 11\n210 706\n985 388\n20 987\n359 582\n409 879\n562 91\n915 458\n477
      739\n826 873\n703 16\n140 321\n846 490\n883 707\n661 60\n742 488\n422 951\n193
      406\n338 564\n393 48\n146 153\n927 59\n243 193\n868 71\n284 693\n943 986\n60
      82\n659 258\n923 893\n964 936\n304 705\n423 726\n656 967\n483 345\n882 227\n393
      27\n379 671\n437 973\n215 304\n396 498\n348 338\n836 760\n772 494\n17 46\n386
      980\n333 690\n684 755\n767 339\n73 249\n684 955\n476 428\n981 206\n450 770\n179
      664\n73 574\n514 421\n263 349\n532 386\n194 548\n432 931\n527 764\n972 210\n871
      90\n901 943\n691 584\n897 166\n363 230\n723 812\n999 901\n827 423\n826 340\n843
      89\n40 374\n474 585\n273 257\n868 799\n373 839\n361 243\n281 261\n537 971\n844
      434\n488 558\n663 210\n369 13\n463 547\n435 288\n239 630\n376 278\n355 202\n215
      628\n810 82\n778 182\n272 138\n424 552\n398 961\n874 241\n746 361\n798 760\n571
      518\n772 33\n65 558\n672 303\n187 48\n932 542\n601 498\n521 410\n579 298\n592
      203\n436 367\n106 833\n679 980\n426 424\n340 575\n183 262\n93 306\n646 509\n864
      318\n163 402\n717 446\n943 317\n944 815\n78 874\n113 21\n76 900\n388 534\n732
      66\n513 509\n842 204\n84 376\n818 528\n34 463\n388 897\n780 550\n298 496\n995
      593\n164 938\n407 242\n812 871\n262 239\n770 1\n772 854\n419 636\n362 260\n192
      445\n987 9\n972 20\n471 711\n268 251\n260 566\n98 607\n510 262\n544 268\n855
      707\n139 116\n298 260\n117 69\n113 535\n57 475\n146 248\n919 132\n256 243\n504
      78\n953 771\n328 565\n688 778\n171 549\n391 66\n817 245\n125 307\n360 422\n566
      828\n842 679\n714 898\n505 859\n145 775\n343 752\n369 198\n830 674\n320 509\n238
      8\n638 760\n556 28\n825 724\n272 301\n30 984\n722 948\n811 564\n626 877\n813
      482\n87 310\n256 429\n413 625\n978 242\n103 887\n657 740\n646 564\n768 822\n288
      391\n123 669\n374 844\n616 185\n759 593\n61 924\n74 147\n233 330\n928 645\n306
      257\n239 603\n554 341\n489 562\n432 486\n126 551\n307 413\n942 429\n433 315\n625
      49\n851 735\n641 263\n658 67\n762 890\n748 41\n887 53\n297 477\n7 203\n169 847\n764
      600\n332 241\n151 638\n653 444\n419 438\n758 43\n486 609\n777 478\n223 435\n544
      984\n676 291\n24 914\n695 673\n390 701\n875 558\n547 990\n510 230\n231 12\n868
      235\n455 286\n672 564\n680 509\n524 456\n987 747\n242 882\n82 918\n525 458\n183
      219\n130 573\n920 356\n482 818\n345 343\n48 927\n354 267\n514 160\n904 185\n724
      583\n46 599\n390 32\n345 632\n265 779\n901 789\n236 83\n8 365\n7 279\n72 489\n448
      416\n831 847\n695 537\n113 208\n48 368\n744 123\n950 789\n722 340\n172 418\n323
      437\n196 223\n225 431\n305 584\n147 312\n862 218\n152 662\n986 334\n508 32\n870
      973\n239 270\n340 982\n392 290\n771 113\n981 294\n531 303\n730 78\n525 955\n861
      181\n890 7\n844 104\n577 995\n765 914\n329 272\n945 550\n244 183\n819 936\n516
      211\n225 638\n675 557\n932 205\n859 661\n635 735\n967 495\n267 857\n501 111\n960
      429\n105 76\n342 433\n699 286\n335 295\n468 153\n230 984\n715 806\n973 390\n362
      904\n946 572\n917 580\n658 883\n74 924\n91 927\n34 402\n355 139\n477 697\n923
      176\n334 257\n470 802\n762 51\n137 828\n856 109\n365 163\n140 281\n94 797\n515
      168\n720 606\n446 754\n7 800\n892 836\n848 166\n363 182\n423 184\n335 536\n234
      823\n363 89\n283 580\n657 999\n94 796\n279 539\n592 794\n706 311\n399 151\n416
      757\n303 307\n944 502\n825 306\n35 247\n489 721\n134 74\n543 496\n162 178\n427
      170\n176 872\n965 807\n411 908\n600 468\n219 350\n971 986\n458 625\n645 402\n126
      469\n59 513\n67 900\n233 200\n973 128\n47 487\n657 826\n656 832\n49 973\n638
      811\n880 589\n279 450\n290 601\n436 748\n225 80\n501 702\n548 559\n566 614\n810
      799\n165 135\n926 211\n621 582\n388 628\n765 437\n600 755\n247 480\n343 525\n929
      633\n477 716\n732 53\n795 232\n755 342\n142 320\n307 304\n470 471\n438 747\n682
      410\n680 69\n37 445\n857 989\n551 104\n820 245\n980 748\n229 457\n464 960\n509
      610\n543 615\n952 685\n287 258\n340 756\n81 777\n503 762\n186 534\n182 574\n978
      39\n914 880\n494 733\n125 473\n833 353\n281 648\n313 142\n257 855\n108 208\n891
      394\n818 230\n502 898\n358 356\n11 895\n889 544\n469 219\n934 734\n98 427\n467
      222\n252 299\n575 884\n946 239\n377 202\n445 485\n762 688\n230 931\n917 731\n828
      627\n86 190\n521 975\n733 341\n545 19\n75 642\n445 541\n864 48\n191 790\n284
      136\n380 660\n337 824\n496 450\n511 726\n380 780\n456 559\n406 894\n748 278\n220
      833\n971 764\n851 45\n405 647\n937 620\n695 127\n761 330\n614 140\n341 302\n316
      837\n752 178\n562 131\n957 369\n690 714\n262 789\n344 481\n621 314\n596 471\n358
      353\n118 646\n972 164\n772 85\n493 737\n576 185\n38 891\n21 789\n421 582\n272
      729\n303 961\n443 564\n749 786\n397 722\n451 344\n192 808\n696 661\n805 20\n824
      928\n104 668\n664 31\n853 701\n274 225\n490 694\n159 761\n422 461\n73 216\n376
      173\n353 124\n894 803\n468 86\n962 163\n98 766\n534 922\n693 989\n941 356\n20
      793\n57 293\n18 898\n338 528\n10 759\n988 82\n327 363\n606 679\n487 500\n482
      306\n937 795\n820 34\n561 354\n307 605\n342 248\n961 713\n392 369\n5 761\n618
      694\n288 627\n805 275\n60 131\n990 665\n161 828\n516 994\n485 804\n789 304\n838
      701\n657 144\n305 351\n743 265\n63 135\n985 420\n247 954\n465 535\n580 269\n161
      991\n399 502\n8 912\n681 523\n905 165\n327 693\n469 516\n393 477\n11 50\n179
      754\n666 594\n240 651\n13 838\n604 477\n724 536\n98 885\n878 848\n738 885\n759
      419\n408 664\n583 86\n708 51\n953 453\n880 963\n502 58\n68 167\n651 307\n169
      15\n145 125\n844 868\n12 941\n104 889\n788 194\n774 547\n612 533\n562 194\n970
      621\n597 922\n425 828\n884 278\n237 952\n797 888\n610 965\n254 106\n441 97\n326
      452\n37 429\n341 177\n974 466\n75 585\n998 636\n131 967\n608 79\n888 33\n258
      123\n310 494\n74 106\n733 684\n423 987\n141 863\n83 466\n315 472\n247 7\n1000
      220\n472 74\n805 821\n61 287\n787 668\n717 26\n52 974\n500 362\n467 574\n819
      200\n609 241\n186 749\n456 620\n215 122\n443 461\n128 442\n680 951\n515 836\n771
      927\n474 909\n947 190\n934 998\n163 433\n711 982\n358 530\n181 318\n122 718\n67
      577\n689 633\n698 132\n445 825\n925 476\n127 792\n664 897\n718 137\n805 664\n679
      90\n662 841\n875 372\n174 584\n253 706\n902 375\n423 320\n951 464\n304 1\n595
      748\n177 871\n575 304\n662 238\n200 732\n727 357\n395 405\n446 408\n597 672\n132
      771\n256 384\n476 509\n110 251\n828 413\n714 131\n413 660\n230 589\n530 804\n892
      544\n394 444\n275 120\n800 21\n876 597\n781 472\n269 912\n594 876\n647 70\n384
      109\n672 563\n521 385\n45 933\n396 274\n521 277\n429 413\n820 174\n856 446\n293
      7\n467 520\n603 599\n992 223\n862 937\n450 860\n6 185\n968 29\n747 488\n765
      791\n772 160\n416 293\n437 197\n57 608\n370 264\n406 15\n270 872\n534 224\n822
      877\n799 683\n814 248\n542 171\n433 862\n200 531\n349 316\n674 121\n476 441\n765
      264\n637 821\n223 359\n436 628\n725 57\n851 258\n280 672\n487 430\n706 652\n678
      248\n822 462\n109 373\n992 809\n689 665\n281 516\n106 45\n779 94\n217 353\n452
      652\n981 176\n708 831\n786 340\n855 624\n769 560\n275 798\n159 96\n259 267\n821
      251\n428 509\n267 708\n376 724\n753 506\n818 969\n858 621\n973 838\n149 32\n21
      934\n371 875\n557 492\n786 183\n289 945\n278 548\n563 450\n150 990\n958 768\n698
      685\n492 450\n190 661\n770 48\n281 94\n237 429\n126 609\n714 848\n835 622\n339
      621\n804 980\n917 434\n879 479\n883 380\n469 193\n147 166\n877 990\n967 67\n650
      88\n466 931\n182 54\n711 307\n15 425\n506 201\n46 197\n173 202\n176 89\n635
      406\n568 517\n785 388\n709 283\n553 938\n273 871\n356 922\n958 173\n204 139\n578
      915\n797 592\n691 655\n793 736\n851 317\n289 378\n406 923\n783 325\n792 919\n712
      500\n201 616\n789 473\n486 144\n747 795\n316 950\n286 894\n864 434\n837 554\n88
      981\n642 290\n298 930\n667 55\n205 801\n379 996\n719 442\n847 272\n57 636\n744
      894\n779 490\n688 95\n792 973\n340 655\n407 176\n561 494\n509 554\n784 806\n483
      802\n860 39\n603 590\n34 673\n31 881\n944 87\n516 40\n980 646\n881 19\n92 672\n992
      431\n679 398\n959 239\n243 467\n792 378\n624 626\n180 835\n665 134\n424 50\n806
      454\n930 102\n892 797\n141 223\n443 21\n241 534\n693 232\n317 723\n981 275\n961
      576\n93 104\n953 716\n81 484\n902 97\n617 325\n499 775\n130 428\n876 373\n577
      16\n595 19\n388 187\n904 432\n771 220\n154 751\n494 466\n678 938\n921 631\n5
      354\n114 906\n802 83\n582 300\n857 63\n728 732\n435 656\n99 381\n674 838\n568
      929\n270 338\n149 775\n440 994\n241 118\n932 513\n748 288\n866 213\n546 668\n295
      127\n967 503\n190 46\n586 976\n53 36\n357 78\n874 924\n7 143\n261 155\n269 700\n500
      861\n169 783\n374 916\n71 591\n481 616\n610 127\n94 929\n630 283\n326 567\n259
      379\n603 615\n456 476\n890 814\n970 502\n968 238\n553 820\n451 722\n602 824\n989
      672\n766 469\n639 728\n596 733\n656 577\n367 333\n143 977\n711 745\n943 519\n572
      832\n332 541\n333 652\n131 886\n471 581\n607 72\n756 595\n96 873\n416 86\n600
      363\n818 255\n939 537\n588 433\nR L L L L R R L L L R L R R L R L R R R R L
      R R L L R L L L R R L L L R L L L R R L L R L R R L R L L L R L L R L L L R
      L L R R R L R R L R R L L R R L R R R L L L R R L L R R R L R L L L L L R R
      L L R R L L R L R R L R L L R L L L R L L L R L R L R R L L R R R R R L L R
      R R L R R R L R R R L R L R L L R R L R R R L R R R R L L L L R L R R R L L
      R L L R L R R L L R L R L L R R L L R L R R R L R R R R R L L R R R R L R L
      R L L L R R R R L L L L R L L L L L L L L L R R L R R R L R L R R R L R L R
      R R L R L R L L L R R R L R L L R R L L R L L L L L R R L L R R L R R R R L
      L L R R L L R R L R R R L L L L R R R R L R L L R R L R L L L R R L R L L R
      L R L R R R L R L L R R R L R L L R R R R L R L L R L R R R R L R L L R R R
      R L R L L R R L L L L L R L R R L R R R R R R R R R R L R R R L L R R L R R
      R L R R L R L L R R L R R L L R R L R R R L R R R L R R R R R L R R L L R R
      R R L R L L L R R L L R L L L L R L L R L L L R R L R L R L R R L L R R R R
      R R L L L L L R R L R L L L L R L L L R L L\n","outputs":"376\n"},{"inputs":"1000
      500 1000000000\n2 503\n3 504\n4 505\n5 506\n6 507\n7 508\n8 509\n9 510\n10 511\n11
      512\n12 513\n13 514\n14 515\n15 516\n16 517\n17 518\n18 519\n19 520\n20 521\n21
      522\n22 523\n23 524\n24 525\n25 526\n26 527\n27 528\n28 529\n29 530\n30 531\n31
      532\n32 533\n33 534\n34 535\n35 536\n36 537\n37 538\n38 539\n39 540\n40 541\n41
      542\n42 543\n43 544\n44 545\n45 546\n46 547\n47 548\n48 549\n49 550\n50 551\n51
      552\n52 553\n53 554\n54 555\n55 556\n56 557\n57 558\n58 559\n59 560\n60 561\n61
      562\n62 563\n63 564\n64 565\n65 566\n66 567\n67 568\n68 569\n69 570\n70 571\n71
      572\n72 573\n73 574\n74 575\n75 576\n76 577\n77 578\n78 579\n79 580\n80 581\n81
      582\n82 583\n83 584\n84 585\n85 586\n86 587\n87 588\n88 589\n89 590\n90 591\n91
      592\n92 593\n93 594\n94 595\n95 596\n96 597\n97 598\n98 599\n99 600\n100 601\n101
      602\n102 603\n103 604\n104 605\n105 606\n106 607\n107 608\n108 609\n109 610\n110
      611\n111 612\n112 613\n113 614\n114 615\n115 616\n116 617\n117 618\n118 619\n119
      620\n120 621\n121 622\n122 623\n123 624\n124 625\n125 626\n126 627\n127 628\n128
      629\n129 630\n130 631\n131 632\n132 633\n133 634\n134 635\n135 636\n136 637\n137
      638\n138 639\n139 640\n140 641\n141 642\n142 643\n143 644\n144 645\n145 646\n146
      647\n147 648\n148 649\n149 650\n150 651\n151 652\n152 653\n153 654\n154 655\n155
      656\n156 657\n157 658\n158 659\n159 660\n160 661\n161 662\n162 663\n163 664\n164
      665\n165 666\n166 667\n167 668\n168 669\n169 670\n170 671\n171 672\n172 673\n173
      674\n174 675\n175 676\n176 677\n177 678\n178 679\n179 680\n180 681\n181 682\n182
      683\n183 684\n184 685\n185 686\n186 687\n187 688\n188 689\n189 690\n190 691\n191
      692\n192 693\n193 694\n194 695\n195 696\n196 697\n197 698\n198 699\n199 700\n200
      701\n201 702\n202 703\n203 704\n204 705\n205 706\n206 707\n207 708\n208 709\n209
      710\n210 711\n211 712\n212 713\n213 714\n214 715\n215 716\n216 717\n217 718\n218
      719\n219 720\n220 721\n221 722\n222 723\n223 724\n224 725\n225 726\n226 727\n227
      728\n228 729\n229 730\n230 731\n231 732\n232 733\n233 734\n234 735\n235 736\n236
      737\n237 738\n238 739\n239 740\n240 741\n241 742\n242 743\n243 744\n244 745\n245
      746\n246 747\n247 748\n248 749\n249 750\n250 751\n251 752\n252 753\n253 754\n254
      755\n255 756\n256 757\n257 758\n258 759\n259 760\n260 761\n261 762\n262 763\n263
      764\n264 765\n265 766\n266 767\n267 768\n268 769\n269 770\n270 771\n271 772\n272
      773\n273 774\n274 775\n275 776\n276 777\n277 778\n278 779\n279 780\n280 781\n281
      782\n282 783\n283 784\n284 785\n285 786\n286 787\n287 788\n288 789\n289 790\n290
      791\n291 792\n292 793\n293 794\n294 795\n295 796\n296 797\n297 798\n298 799\n299
      800\n300 801\n301 802\n302 803\n303 804\n304 805\n305 806\n306 807\n307 808\n308
      809\n309 810\n310 811\n311 812\n312 813\n313 814\n314 815\n315 816\n316 817\n317
      818\n318 819\n319 820\n320 821\n321 822\n322 823\n323 824\n324 825\n325 826\n326
      827\n327 828\n328 829\n329 830\n330 831\n331 832\n332 833\n333 834\n334 835\n335
      836\n336 837\n337 838\n338 839\n339 840\n340 841\n341 842\n342 843\n343 844\n344
      845\n345 846\n346 847\n347 848\n348 849\n349 850\n350 851\n351 852\n352 853\n353
      854\n354 855\n355 856\n356 857\n357 858\n358 859\n359 860\n360 861\n361 862\n362
      863\n363 864\n364 865\n365 866\n366 867\n367 868\n368 869\n369 870\n370 871\n371
      872\n372 873\n373 874\n374 875\n375 876\n376 877\n377 878\n378 879\n379 880\n380
      881\n381 882\n382 883\n383 884\n384 885\n385 886\n386 887\n387 888\n388 889\n389
      890\n390 891\n391 892\n392 893\n393 894\n394 895\n395 896\n396 897\n397 898\n398
      899\n399 900\n400 901\n401 902\n402 903\n403 904\n404 905\n405 906\n406 907\n407
      908\n408 909\n409 910\n410 911\n411 912\n412 913\n413 914\n414 915\n415 916\n416
      917\n417 918\n418 919\n419 920\n420 921\n421 922\n422 923\n423 924\n424 925\n425
      926\n426 927\n427 928\n428 929\n429 930\n430 931\n431 932\n432 933\n433 934\n434
      935\n435 936\n436 937\n437 938\n438 939\n439 940\n440 941\n441 942\n442 943\n443
      944\n444 945\n445 946\n446 947\n447 948\n448 949\n449 950\n450 951\n451 952\n452
      953\n453 954\n454 955\n455 956\n456 957\n457 958\n458 959\n459 960\n460 961\n461
      962\n462 963\n463 964\n464 965\n465 966\n466 967\n467 968\n468 969\n469 970\n470
      971\n471 972\n472 973\n473 974\n474 975\n475 976\n476 977\n477 978\n478 979\n479
      980\n480 981\n481 982\n482 983\n483 984\n484 985\n485 986\n486 987\n487 988\n488
      989\n489 990\n490 991\n491 992\n492 993\n493 994\n494 995\n495 996\n496 997\n497
      998\n498 999\n499 1000\n500 1\n501 2\n502 3\n503 4\n504 5\n505 6\n506 7\n507
      8\n508 9\n509 10\n510 11\n511 12\n512 13\n513 14\n514 15\n515 16\n516 17\n517
      18\n518 19\n519 20\n520 21\n521 22\n522 23\n523 24\n524 25\n525 26\n526 27\n527
      28\n528 29\n529 30\n530 31\n531 32\n532 33\n533 34\n534 35\n535 36\n536 37\n537
      38\n538 39\n539 40\n540 41\n541 42\n542 43\n543 44\n544 45\n545 46\n546 47\n547
      48\n548 49\n549 50\n550 51\n551 52\n552 53\n553 54\n554 55\n555 56\n556 57\n557
      58\n558 59\n559 60\n560 61\n561 62\n562 63\n563 64\n564 65\n565 66\n566 67\n567
      68\n568 69\n569 70\n570 71\n571 72\n572 73\n573 74\n574 75\n575 76\n576 77\n577
      78\n578 79\n579 80\n580 81\n581 82\n582 83\n583 84\n584 85\n585 86\n586 87\n587
      88\n588 89\n589 90\n590 91\n591 92\n592 93\n593 94\n594 95\n595 96\n596 97\n597
      98\n598 99\n599 100\n600 101\n601 102\n602 103\n603 104\n604 105\n605 106\n606
      107\n607 108\n608 109\n609 110\n610 111\n611 112\n612 113\n613 114\n614 115\n615
      116\n616 117\n617 118\n618 119\n619 120\n620 121\n621 122\n622 123\n623 124\n624
      125\n625 126\n626 127\n627 128\n628 129\n629 130\n630 131\n631 132\n632 133\n633
      134\n634 135\n635 136\n636 137\n637 138\n638 139\n639 140\n640 141\n641 142\n642
      143\n643 144\n644 145\n645 146\n646 147\n647 148\n648 149\n649 150\n650 151\n651
      152\n652 153\n653 154\n654 155\n655 156\n656 157\n657 158\n658 159\n659 160\n660
      161\n661 162\n662 163\n663 164\n664 165\n665 166\n666 167\n667 168\n668 169\n669
      170\n670 171\n671 172\n672 173\n673 174\n674 175\n675 176\n676 177\n677 178\n678
      179\n679 180\n680 181\n681 182\n682 183\n683 184\n684 185\n685 186\n686 187\n687
      188\n688 189\n689 190\n690 191\n691 192\n692 193\n693 194\n694 195\n695 196\n696
      197\n697 198\n698 199\n699 200\n700 201\n701 202\n702 203\n703 204\n704 205\n705
      206\n706 207\n707 208\n708 209\n709 210\n710 211\n711 212\n712 213\n713 214\n714
      215\n715 216\n716 217\n717 218\n718 219\n719 220\n720 221\n721 222\n722 223\n723
      224\n724 225\n725 226\n726 227\n727 228\n728 229\n729 230\n730 231\n731 232\n732
      233\n733 234\n734 235\n735 236\n736 237\n737 238\n738 239\n739 240\n740 241\n741
      242\n742 243\n743 244\n744 245\n745 246\n746 247\n747 248\n748 249\n749 250\n750
      251\n751 252\n752 253\n753 254\n754 255\n755 256\n756 257\n757 258\n758 259\n759
      260\n760 261\n761 262\n762 263\n763 264\n764 265\n765 266\n766 267\n767 268\n768
      269\n769 270\n770 271\n771 272\n772 273\n773 274\n774 275\n775 276\n776 277\n777
      278\n778 279\n779 280\n780 281\n781 282\n782 283\n783 284\n784 285\n785 286\n786
      287\n787 288\n788 289\n789 290\n790 291\n791 292\n792 293\n793 294\n794 295\n795
      296\n796 297\n797 298\n798 299\n799 300\n800 301\n801 302\n802 303\n803 304\n804
      305\n805 306\n806 307\n807 308\n808 309\n809 310\n810 311\n811 312\n812 313\n813
      314\n814 315\n815 316\n816 317\n817 318\n818 319\n819 320\n820 321\n821 322\n822
      323\n823 324\n824 325\n825 326\n826 327\n827 328\n828 329\n829 330\n830 331\n831
      332\n832 333\n833 334\n834 335\n835 336\n836 337\n837 338\n838 339\n839 340\n840
      341\n841 342\n842 343\n843 344\n844 345\n845 346\n846 347\n847 348\n848 349\n849
      350\n850 351\n851 352\n852 353\n853 354\n854 355\n855 356\n856 357\n857 358\n858
      359\n859 360\n860 361\n861 362\n862 363\n863 364\n864 365\n865 366\n866 367\n867
      368\n868 369\n869 370\n870 371\n871 372\n872 373\n873 374\n874 375\n875 376\n876
      377\n877 378\n878 379\n879 380\n880 381\n881 382\n882 383\n883 384\n884 385\n885
      386\n886 387\n887 388\n888 389\n889 390\n890 391\n891 392\n892 393\n893 394\n894
      395\n895 396\n896 397\n897 398\n898 399\n899 400\n900 401\n901 402\n902 403\n903
      404\n904 405\n905 406\n906 407\n907 408\n908 409\n909 410\n910 411\n911 412\n912
      413\n913 414\n914 415\n915 416\n916 417\n917 418\n918 419\n919 420\n920 421\n921
      422\n922 423\n923 424\n924 425\n925 426\n926 427\n927 428\n928 429\n929 430\n930
      431\n931 432\n932 433\n933 434\n934 435\n935 436\n936 437\n937 438\n938 439\n939
      440\n940 441\n941 442\n942 443\n943 444\n944 445\n945 446\n946 447\n947 448\n948
      449\n949 450\n950 451\n951 452\n952 453\n953 454\n954 455\n955 456\n956 457\n957
      458\n958 459\n959 460\n960 461\n961 462\n962 463\n963 464\n964 465\n965 466\n966
      467\n967 468\n968 469\n969 470\n970 471\n971 472\n972 473\n973 474\n974 475\n975
      476\n976 477\n977 478\n978 479\n979 480\n980 481\n981 482\n982 483\n983 484\n984
      485\n985 486\n986 487\n987 488\n988 489\n989 490\n990 491\n991 492\n992 493\n993
      494\n994 495\n995 496\n996 497\n997 498\n998 499\n999 500\n1000 501\n1 502\nL
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L
      L L L L R\n","outputs":"1\n"}],"runtime_limit":2,"status":"in_progress"},"run_type":"chain"}]}'
    headers:
      Accept:
      - application/json
      Accept-Encoding:
      - gzip, deflate
      Connection:
      - keep-alive
      Content-Length:
      - '81419'
      Content-Type:
      - application/json
      User-Agent:
      - langsmith-py/0.1.123
    method: POST
    uri: https://api.smith.langchain.com/runs/batch
  response:
    body:
      string: '{"detail":"Monthly unique traces usage limit exceeded"}'
    headers:
      Access-Control-Allow-Credentials:
      - 'true'
      Access-Control-Allow-Headers:
      - '*'
      Access-Control-Allow-Methods:
      - '*'
      Access-Control-Allow-Origin:
      - ''
      Access-Control-Expose-Headers:
      - '*'
      Access-Control-Max-Age:
      - '600'
      Alt-Svc:
      - h3=":443"; ma=2592000,h3-29=":443"; ma=2592000
      Content-Length:
      - '55'
      Via:
      - 1.1 google
      content-type:
      - application/json
      date:
      - Thu, 19 Sep 2024 18:21:19 GMT
      server:
      - uvicorn
    status:
      code: 429
      message: Too Many Requests
- request:
    body: '{"post":[{"id":"ebfff908-70f1-435d-8d73-f69ce81019ea","start_time":"2024-09-19T18:19:52.746742+00:00","end_time":"2024-09-19T18:19:52.747301+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":1,"langgraph_node":"draft","langgraph_triggers":["start:draft"],"langgraph_path":["__pregel_pull","draft"],"langgraph_checkpoint_ns":"draft:cda28afa-f13f-d31a-0b4b-5b431e5199e9","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:19:52.746742+00:00"},{"name":"end","time":"2024-09-19T18:19:52.747301+00:00"}],"reference_example_id":null,"parent_run_id":"e551fcf9-9e33-4fe5-9bb1-98887f998b4f","tags":["seq:step:2","langsmith:hidden"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181918250003Ze551fcf9-9e33-4fe5-9bb1-98887f998b4f.20240919T181952746742Zebfff908-70f1-435d-8d73-f69ce81019ea","outputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"test_cases":"..."},"session_name":"default","name":"ChannelWrite<draft,candidate,examples,messages,test_cases,runtime_limit,status>","inputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"test_cases":"..."},"run_type":"chain"},{"id":"67ca6620-4bae-42c7-92c1-b5a98e5e98fe","start_time":"2024-09-19T18:19:52.748601+00:00","end_time":"2024-09-19T18:19:52.752311+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":2,"langgraph_node":"retrieve","langgraph_triggers":["draft"],"langgraph_path":["__pregel_pull","retrieve"],"langgraph_checkpoint_ns":"retrieve:ccf8bf45-8492-eb9c-afd2-4ab2f1465c4f","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"end","time":"2024-09-19T18:19:52.752311+00:00"}],"reference_example_id":null,"parent_run_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","tags":["graph:step:2"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952748601Z67ca6620-4bae-42c7-92c1-b5a98e5e98fe","outputs":{"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"session_name":"default","name":"retrieve","inputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"run_type":"chain"},{"id":"3b53fa99-b84e-440f-b68a-d2a51f59bcfe","start_time":"2024-09-19T18:19:52.749370+00:00","end_time":"2024-09-19T18:19:52.751285+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":2,"langgraph_node":"retrieve","langgraph_triggers":["draft"],"langgraph_path":["__pregel_pull","retrieve"],"langgraph_checkpoint_ns":"retrieve:ccf8bf45-8492-eb9c-afd2-4ab2f1465c4f","checkpoint_ns":"retrieve:ccf8bf45-8492-eb9c-afd2-4ab2f1465c4f","ls_retriever_name":"bm25","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:19:52.749370+00:00"},{"name":"end","time":"2024-09-19T18:19:52.751285+00:00"}],"reference_example_id":null,"parent_run_id":"67ca6620-4bae-42c7-92c1-b5a98e5e98fe","tags":["seq:step:1"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952748601Z67ca6620-4bae-42c7-92c1-b5a98e5e98fe.20240919T181952749370Z3b53fa99-b84e-440f-b68a-d2a51f59bcfe","outputs":{"documents":[{"metadata":{},"page_content":"<problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>","type":"Document"},{"metadata":{},"page_content":"<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>","type":"Document"},{"metadata":{},"page_content":"<problem>\n    \nFarmer
      Nhoj dropped Bessie in the middle of nowhere! At time $t=0$, Bessie is\nlocated
      at $x=0$ on an infinite number line. She frantically searches for an\nexit by
      moving left or right by $1$ unit each second. However, there actually is\nno
      exit and after $T$ seconds, Bessie is back at $x=0$, tired and resigned. \n\nFarmer
      Nhoj tries to track Bessie but only knows how many times Bessie crosses\n$x=.5,
      1.5, 2.5, \\ldots, (N-1).5$, given by an array $A_0,A_1,\\dots,A_{N-1}$\n($1\\leq
      N \\leq 10^5$, $1 \\leq A_i \\leq 10^6$). Bessie never reaches $x>N$ nor\n$x<0$.\n\nIn
      particular, Bessie''s route can be represented by a string of\n$T = \\sum_{i=0}^{N-1}
      A_i$ $L$s and $R$s where the $i$th character represents\nthe direction Bessie
      moves in during the $i$th second. The number of direction\nchanges is defined
      as the number of occurrences of  $LR$s plus the number of\noccurrences of $RL$s.
      \n\nPlease help Farmer Nhoj count the number of routes Bessie could have taken
      that\nare consistent with $A$ and minimize the number of direction changes.
      It is\nguaranteed that there is at least one valid route.\n\nINPUT FORMAT (input
      arrives from the terminal / stdin):\nThe first line contains $N$. The second
      line contains $A_0,A_1,\\dots,A_{N-1}$.\n\nOUTPUT FORMAT (print output to the
      terminal / stdout):\nThe number of routes Bessie could have taken, modulo $10^9+7$.\n\nSAMPLE
      INPUT:\n2\n4 6\nSAMPLE OUTPUT: \n2\n\nBessie must change direction at least
      5 times. There are two routes \ncorresponding to Bessie changing direction exactly
      5 times:\n\n\nRRLRLLRRLL\nRRLLRRLRLL\n\nSCORING:\nInputs 2-4: $N\\le 2$ and
      $\\max(A_i)\\le 10^3$Inputs 5-7: $N\\le 2$Inputs 8-11: $\\max(A_i)\\le 10^3$Inputs
      12-21: No additional constraints.\n\n\nProblem credits: Brandon Wang, Claire
      Zhang, and Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis by
      Claire Zhang and Brandon Wang)\nLet''s annotate each character in the route
      with a subscript that indicates which\n$i.5$ point it passes. That is, we denote
      $i+1\\to i$ moves by $L_i$, and\n$i\\to i+1$ moves by $R_i$. Then, our string
      must contain exactly\n$B_i = \\frac{A_i}{2}$ $L_i$''s, and $B_i$ $R_i$''s. In
      any route with minimal\nturns, we must have:\nIf $B_i \\geq B_{i+1}$, then any
      $L_{i+1}$ must be followed by a $L_i$. \nFurthermore, exactly $B_{i+1}$ $R_i$''s
      are followed by $R_{i+1}$''s, and the\nother $B_i - B_{i+1}$  are followed by
      $L_i$''s.If $B_i \\leq B_{i+1}$,\nthen any $R_i$ must be followed by a $R_{i+1}$.  Furthermore,
      exactly $B_i$\n$L_{i+1}$''s are followed by $L_i$''s, and the other $B_{i+1}
      - B_i$  are followed\nby $R_{i+1}$''s.\nIn addition, we note that in any route,
      the final $L_{i+1}$ must be followed by\nan $L_i$ (and not an $R_{i+1}$)  since
      otherwise Bessie would not have a way to\nreturn to $0$.\nWe claim that this
      is the only restriction. That is, to count the number of\npaths, for each $i
      = 0, 1, \\ldots, N-2$ it suffices to count the number of ways\nto pick which
      $R_i$''s that are followed by $R_{i+1}$''s if $B_i \\geq B_{i+1}$, \nor which
      $L_{i+1}$''s followed by $L_i$''s if $B_i \\leq B_{i+1}$ (such that the\nlast
      $L_{i+1}$ is followed by an $L_i$).  Then, any such assignment will produce\na
      unique valid path.\nUniqueness is clear, but to show validity, suppose we construct
      the route by\nfollowing the assignments, where the route ends when the last
      $L_0$ is reached\n(and all previous $L_0$''s are followed by $R_0$''s). We need
      to check that all of\nthe $L_i$''s and $R_i$''s are actually used; since the
      number of $R_i$''s and\n$L_i$''s is the same, we need to check that this path
      visits $B_i$ $L_i$''s. \nWe will do this by induction, where $L_0$ is true by
      assumption. For the\ninductive step, suppose $B_i$ $L_i$''s appear in the path.
      Then, if\n$B_i \\geq B_{i+1}$, then $B_i-B_{i+1}$ $L_i$''s are preceded by $R_i$''s,
      and\n$B_{i+1}$ of them are preceded by $L_{i+1}$''s. So, in order for all the
      $L_i$''s\nto appear, all the $L_{i+1}$''s must also appear. Conversely, if\n$B_i
      \\leq B_{i+1}$, then since the last $L_{i+1}$ is immediately followed by an\n$L_i$,  if
      not all $L_{i+1}$''s appear then not all $L_i$''s can appear,\ncontradicting
      the inductive hypothesis. So, the constructed path contains $B_i$\n$L_i$''s
      for each $i$, and thus crosses $i.5$ exactly $2B_i = A_i$ times.\nMinimality
      (i.e. the fact that exactly\n$(B_0 - 1) + \\left(\\sum_{i=0}^{n-2} |B_i - B_{i+1}|\\right)
      + (B_{n-1})$  turns are made) follows by the\nconstruction.\nNow, if $B_i \\geq
      B_{i+1}$, then the number of assignments is just\n$\\binom{B_i}{B_{i+1}}$. In
      the second the other case, since the last $L_{i+1}$\nmust be followed by $L_i$,
      the answer is\n$\\binom{B_{i+1}-1}{B_i-1}$.\nThus we obtain our answer as a
      product of binomial coefficients:\n$$\n\\prod_{i=0}^{N-2} \\begin{cases} \\binom{B_i}{B_{i+1}}
      & \\text{ if } B_i \\geq B_{i+1} \\\\\n\\binom{B_{i+1}-1}{B_i-1} & \\text{ otherwise
      } \\end{cases}\n$$\nLet $T = \\max_i A_i$. We can precompute factorials in $O(T)$
      time. We can\ncompute inverse factorials by first computing the modular inverse
      of $T!$ (e.g.,\nby raising it to $MOD-2$ with binary exponentiation). Then we
      can obtain all\nsmaller inverse factorials in decreasing order. Now we can compute
      each binomial\ncoefficient in the desired expression in $O(1)$ time, for a total
      runtime of\n$O(\\log(MOD) + T+N)$.\nPython solution:\n\nP = int(1e9+7)\nMAX_A
      = int(1e6+1)\n \n# computes a^n mod P\ndef exp(a, n):\n    if n == 0:\n        return
      1\n    base = exp((a*a)%P, n // 2)\n    return base if n%2 == 0 else (a*base)%P\n
      \n# initialize\nfacts = [1]\nfor i in range(1, MAX_A):\n    facts.append((facts[-1]
      * i)%P)\ninv_facts = [exp(facts[-1], P-2)]\nfor i in range(MAX_A-1, 0, -1):\n    inv_facts.append((inv_facts[-1]
      * i)%P)\ninv_facts.reverse()\n \n# binom(n, m) = n!/(m!(n-m)!)\nbinom = lambda
      n, m : (inv_facts[m] * (facts[n] * inv_facts[n-m])%P)%P\n \nN = int(input())\nA
      = [int(x) for x in input().split()]\nB = [a // 2 for a in A]\n \nans = 1\nfor
      i in range(N-1):\n    if B[i] >= B[i+1]:\n        ans *= binom(B[i], B[i+1])\n    else:\n        ans
      *= binom(B[i+1]-1, B[i]-1)\n    ans %= P\n \nprint(ans)\n\n\n    </solution>","type":"Document"},{"metadata":{},"page_content":"<problem>\n    \nFarmer
      John has $N$ ($2\\le N\\le 10^5$) cows labeled $1\\dots N$, where the \nconnections
      between cows are described by a tree. Unfortunately, there is a\nsickness spreading
      throughout. \n\nInitially, some cows start off infected. Every night, an infected
      cow spreads\nthe sickness to their neighbors. Once a cow is infected, she stays
      infected.\nAfter some amount of nights, Farmer John realizes that there is an
      issue so he\ntests his cows to determine who has the sickness.  \n\nYou are
      given $Q$ ($1\\le Q\\le 20$) different values for the number of nights, \neach
      an integer in the range $[0,N]$.  For each number of nights, determine the\nminimum
      number of cows that could have  started with the illness, or that the\nnumber
      of nights is inconsistent with the given information.\n\nINPUT FORMAT (input
      arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe next
      line contains a bit string of length $N$, where the $i$th bit is 1  if\nthe
      $i$th cow is infected and 0 otherwise. At least one cow is infected.\n\nThe
      next $N-1$ lines contain the edges of the tree.\n\nThen $Q$, followed by the
      $Q$ values for the number of nights.\n\nOUTPUT FORMAT (print output to the terminal
      / stdout):\n$Q$ lines, the answers for each number of nights, or $-1$ if impossible.\n\nSAMPLE
      INPUT:\n5\n11111\n1 2\n2 3\n3 4\n4 5\n6\n5\n4\n3\n2\n1\n0\nSAMPLE OUTPUT: \n1\n1\n1\n1\n2\n5\n\nFor
      the first four queries, one possibility is that just cow 3 started with the\nillness.
      For the fifth query (1 night), one possibility is that cows 2 and 4\nstarted
      with the illness. For the sixth query (0 nights), one possibility is\nthat all
      five cows started with the illness.\n\nSAMPLE INPUT:\n10\n1111111111\n1 2\n2
      3\n2 4\n2 5\n2 6\n6 7\n7 8\n8 9\n9 10\n11\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nSAMPLE
      OUTPUT: \n10\n3\n2\n1\n1\n1\n1\n1\n1\n1\n1\n\nFor the first query (0 nights),
      one possibility is that all ten cows started\nwith the illness. For the second
      query (1 night), one possibility is that cows\n2, 7, and 9 started with the
      illness. For the third query (2 nights), one\npossibility is that cows 2 and
      9 started with the illness. For the fourth to\neleventh queries, one possibility
      is that just cow 7 started with the illness.\n\nSAMPLE INPUT:\n5\n11100\n1 2\n2
      3\n3 4\n4 5\n6\n0\n1\n2\n3\n4\n5\nSAMPLE OUTPUT: \n3\n1\n1\n-1\n-1\n-1\n\nFor
      the first query (0 nights), one possibility is that cows 1, 2, and 3 started\nwith
      the illness. For the second query (1 night), one possibility is that just\ncow
      2 started with the illness. For the third query (2 nights), one possibility\nis
      that just cow 1 started with the illness. For the fourth through sixth\nqueries,
      there is no consistent possibility.\n\nSCORING:\nInputs 4-5: $N \\le 10$Inputs
      6-8: All cows are infected.Inputs 9-11: $N \\le 400$Inputs 12-23: No additional
      restrictions.\n\n\nProblem credits: Suhas Nagar and Brandon Wang\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Brandon Wang, Richard Qi, Benjamin Qi)\nIn all solutions, the overall time
      complexity will be $Q$ times the time\ncomplexity to answer a single query.\nFirst,
      let $I$ be the set of infected cows and let $T$ be the number of nights\nin
      a given query. We first analyze whether or not $I$ is even a valid\nconfiguration.
      Note that a cow $v$ can start out infected if and only if the set\n$B_T(v) =
      \\{u \\colon d(u, v) \\leq T\\}$ is  contained entirely in $I$. Let $S$ be\nthe
      set of cows that can start out infected. Then, $I$ is a valid configuration\nif
      and only if $I = \\bigcup_{v\\in S} B_T(v)$. Furthermore, when $I$ is a valid\nconfiguration,
      we want to find the smallest possible subset $S''\\subseteq S$ \nsuch that $\\bigcup_{v\\in
      S''} B_T(v) = I$.\nTo compute the set $S$, we need to know the shortest distance
      from each cow to\nits closest non-infected cow. This can be done in $O(N)$ time
      by starting a\nmultisource BFS from all non-infected cows.\nSubtask 1 ($N =
      10$):\nFor this case, we can just brute force through all subsets $S''$ of $S$.
      For each\n$v\\in S''$, we can do a BFS to find $B_T(v)$, and check if the resulting
      sets\ncover $I$. This takes $O(2^N \\cdot N^2)$ time per query.\nBrandon''s
      code:\n\nN = int(input())\ninfected = [c == ''1'' for c in input()]\nadj = [[]
      for _ in range(N)]\n\nfor _ in range(1, N):\n    u, v = [int(x) for x in input().split()]\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndist
      = []\n\nfor u in range(N):\n    dist.append([N+1 for _ in range(N)])\n    bfs_queue
      = []\n    dist[u][u] = 0\n    bfs_queue.append(u)\n    bfs_queue_idx = 0\n    while
      len(bfs_queue) != bfs_queue_idx:\n        v = bfs_queue[bfs_queue_idx]\n        for
      w in adj[v]:\n            if dist[u][w] > dist[u][v] + 1:\n                dist[u][w]
      = dist[u][v] + 1\n                bfs_queue.append(w)\n        bfs_queue_idx
      += 1\n\ndef works(Sprime, T):\n    infected_by_Sprime = [False for _ in range(N)]\n    for
      u in Sprime:\n        for v in range(N):\n            if dist[u][v] <= T:\n                infected_by_Sprime[v]
      = True\n    for u in range(N):\n        if infected_by_Sprime[u] != infected[u]:\n            return
      False\n    return True\n\ndef query(T):\n    S = []\n    for u in range(N):\n        u_works
      = True\n        for v in range(N):\n            if dist[u][v] <= T and not infected[v]:\n                u_works
      = False\n        if u_works:\n            S.append(u)\n    \n    if not works(S,
      T):\n        return -1\n    ans = len(S)\n    for i in range(2**len(S)):\n        Sprime
      = []\n        for j in range(len(S)):\n            if i // (2**j) % 2 == 1:\n                Sprime.append(S[j])\n        if
      works(Sprime, T):\n            ans = min(ans, len(Sprime))\n    return ans\n\nQ
      = int(input())\nfor _ in range(Q):\n    T = int(input())\n    print(query(T))\n\nSubtask
      2 (all cows infected):\nWe can answer each query in $O(N)$ time using a greedy
      strategy. First, some\ndefinitions: \n\"Choosing\" a cow means that we set it
      to be initially infected.A cow is \"covered\" if it is within a distance $T$
      of some chosen cow.\nOur goal in this subtask is to choose the minimum number
      of cows so that all\ncows are covered.\nRoot the tree at any cow (the solution
      code roots the tree at the first cow). \nThe following greedy procedure covers
      all the cows in $c$''s subtree at a\ndistance at least $T$ away from $c$:\nRecursively
      apply the procedure to the subtrees of $c$''s children.Compute the distance
      from $c$ to its farthest uncovered descendant\n(guaranteed to be at most $T$).If
      the distance in step 2 is exactly $T$, choose cow $c$. Now, all cows in\n$c$''s
      subtree are covered.Special case: If $c$ is the root and there is an uncovered
      descendant of\n$c$, choose $c$.Return the distance from $c$ to its farthest
      uncovered descendant if such a\ndescendant exists (such a descendant will later
      be covered by some cow outside\nof $c$''s subtree), or otherwise the distance
      from $c$ to its closest chosen\ndescendant (this descendant has the potential
      to cover cows outside of $c$''s\nsubtree).\nIn addition, this procedure constructs
      an optimal solution because \nIf the distance from step 2 is less than $T$,
      and $c$ is not the root of the\ntree, it is always at least as good to choose
      the parent of $c$ instead of $c$,\nsince choosing the parent of $c$ will cover
      all the uncovered cows inside of\n$c$''s subtree and more cows outside of $c$''s
      subtree. Thus, we should not choose\n$c$.If the distance from step 2 is exactly
      $T$ and we have already fixed which\ncows to choose in each of the child subtrees,
      then cow $c$ is the only cow that\ncan cover the uncovered descendant, so we
      must choose $c$.\nBen''s code:\n\n#include <bits/stdc++.h>\nusing namespace
      std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\n#define mp make_pair\n#define
      f first\n#define s second\n\n#define sz(x) int((x).size())\n#define rsz resize\n#define
      pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define
      F0R(i, a) FOR(i, 0, a)\n#define rep(a) F0R(_, a)\n\nvector<vi> adj;\nstring
      infected;\nint N;\n\nint n, ans;\n\n// state:\n// dist d to closest chosen:
      {1, d}\n// dist d to farthest uncovered: {-1, d}\n\npi comb(pi a, pi b) {\n\tif
      (a > b) swap(a, b);\n\tif (b.f == -1) return max(a, b);\n\tif (a.f == 1) return
      min(a, b);\n\tassert(a.f == -1 && b.f == 1);\n\tif (a.s + b.s > n) return a;  //
      uncovered\n\treturn b;                     // covered\n}\n\npi dfs(int x, int
      p) {  // cover x''s subtree\n\tpi best{-1, 0};\n\tfor (int y : adj[x])\n\t\tif
      (y != p) {\n\t\t\tpi d = dfs(y, x);\n\t\t\t++d.s;\n\t\t\tbest = comb(best, d);\n\t\t}\n\tif
      (best.f == -1 && (best.s == n || x == 0)) {  // need to choose x\n\t\tbest =
      {1, 0};\n\t\t++ans;\n\t}\n\treturn best;\n}\n\nint query() {\n\tans = 0;\n\tdfs(0,
      -1);\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin
      >> N;\n\tcin >> infected;\n\tadj.rsz(N);\n\trep(N - 1) {\n\t\tint a, b;\n\t\tcin
      >> a >> b;\n\t\t--a, --b;\n\t\tadj.at(a).pb(b), adj.at(b).pb(a);\n\t}\n\tint
      Q;\n\tcin >> Q;\n\trep(Q) {\n\t\tcin >> n;\n\t\tcout << query() << \"\\n\";\n\t}\n}\n\nSubtask
      3 ($N\\leq 400$) Solution 1 (DP):\nOur approach for the remaining subtasks will
      be to use a tree-dp type approach. \nAs in the subtask 2 solution, root the
      tree arbitrarily. Unfortunately, just\nmaking the DP state \"min # of originally
      infected cows to cover subtree of $v$\" \ndoes not provide enough info, because
      we can cover infected nodes in a subtree\nvia starting cows outside the subtree.\nInstead,
      for each $0 \\leq t \\leq T$, we store the following:\n The min number of nodes
      we need to pick in the subtree such that all\ninfected cows with distance $\\ge
      t$ from the subtree root are covered, and  The min number of nodes we need to
      pick in the subtree such that all\ninfected cows are covered, plus our coverage
      extends distance $t$ outside the\ntree as well.\nWe can compute each of these
      in $O(\\# \\text{children})$ time given the\nchildren''s DP states,  so this
      takes a total of $O(TN)$ per query. Since\n$T\\leq N$, this takes $O(N^2)$,
      which runs in time.\nSubtask 3 Solution 2 (Greedy):\nWe will describe an algorithm
      where initially we start with no chosen cows,  and\nwe greedily choose cows
      in $S$ until every infected cow is covered. \nDefine $U$ to be the set of nodes
      that have not been covered yet. Root the tree\narbitrarily and consider the
      highest depth infected cow $c \\in U$, where depth\nis defined as distance from
      the root. \nLet $S_c$ be all elements of $S$ that are distance within $T$ of
      $c$. Clearly,\nwe must choose some element $s \\in S_c$.\nWe claim that we can
      greedily choose the lowest depth node $s'' \\in S_c$. \nConsider some other
      node $s \\in S_c$. For our greedy to be correct, it suffices\nto show that for
      all nodes $u \\in U$, if $s$ covers $u$, then $s''$ also covers\n$u$.\nThis
      is easy to prove if $s$ and $s''$ are both ancestors of $c$. Now, suppose\none
      of them is not an ancestor of $c$. Define $l = lca(c, s)$ and\n$l'' = lca(c,
      s'')$. Notice that $s$ covers all uncovered nodes $u \\in U$ that are\nalso
      in the subtree rooted at $l$ because $c$ is the highest depth uncovered\nnode,
      and similarly $s''$ covers all uncovered nodes in the subtree rooted at\n$l''$.
      From this, one can prove that $s$ covers the same uncovered nodes as the\nunique
      node with the same depth as $s$ which is also an ancestor of $c$.\nCombining
      this with the proof for the case where $s$ and $s''$ are both ancestors\nof
      $c$, the greedy is proven.\nSo, the algorithm is to repeatedly find the highest
      depth node $c$ that has not\nbeen covered, and choose the lowest depth node
      in $S_c$ to cover it. This can be\ndone naively in $O(N^2)$ per query (though
      on most test cases, it runs much\nfaster than this worst-case bound would suggest).\nRichard''s
      code: \n\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst int MOD =
      1e9+7;\nconst int mx = 100005;\n \nint N;\nint dist_to_nonsick[mx];\nvector<int>
      adj[mx];\nint depth[mx];\nvector<int> sorted_by_depth;\nstring sick;\nint k;\n
      \nvoid genDepth(int node, int p = -1, int d = 0){\n\tdepth[node] = d;\n\tfor(auto
      u: adj[node]){\n\t\tif(u == p) continue;\n\t\tgenDepth(u, node, d+1);\n\t}\n}\n
      \nint dist_to_coverer[mx];\n \nint searchForCoverer(int node, int p = -1, int
      d = 0){\n\tpair<int, int> res = make_pair(MOD, -1);\n\tif(dist_to_nonsick[node]
      > k){\n\t\tres = min(res, make_pair(depth[node], node));\n\t}\n \n\tif(d+1 <=
      k){\n\t\tfor(auto u: adj[node]){\n\t\t\tif(u == p) continue;\n\t\t\tint other_res
      = searchForCoverer(u, node, d+1);\n\t\t\tif(other_res != -1){\n\t\t\t\t//keep
      track of minimum depth node within distance k\n\t\t\t\tres = min(res, make_pair(depth[other_res],
      other_res));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res.second;\n}\n \nvoid setCoverer(int
      node, int d = 0){\n\tif(dist_to_coverer[node] <= d){\n\t\treturn;\n\t}\n\tdist_to_coverer[node]
      = d;\n\t\n\tfor(auto u: adj[node]){\n\t\tsetCoverer(u, d+1);\n\t}\n}\n \nvoid
      solve(int _k){\n\tk = _k;\n\tfor(int i = 1; i <= N; i++){\n\t\tdist_to_coverer[i]
      = k+1; //minimum distance to a coverer\n\t}\n \n\tint ans = 0;\n\tfor(int i
      = int(sorted_by_depth.size())-1; i >= 0; i--){ //start with highest depth nodes\n\t\tint
      to_cover = sorted_by_depth[i];\n\t\tif(sick[to_cover] == ''0'') continue;\n\t\tif(dist_to_coverer[to_cover]
      <= k) continue;\n \n\t\t//this node must be covered\n\t\tans++;\n\t\tint coverer
      = searchForCoverer(to_cover);\n \n\t\tif(coverer == -1){ //can''t be covered\n\t\t\tans
      = -1;\n\t\t\tbreak;\n\t\t}\n \n\t\t//update dist_to_coverer\n\t\tsetCoverer(coverer);\n\t}\n\tcout
      << ans << \"\\n\";\n}\n \nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin
      >> N;\n\tcin >> sick; sick = \"?\" + sick;\n\tfor(int i = 1; i <= N-1; i++){\n\t\tint
      a, b; cin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n
      \n\t// Compute minimum distance to a cow that is not sick with BFS\n\tfor(int
      i = 1; i <= N; i++){\n\t\tdist_to_nonsick[i] = MOD;\n\t}\n\tqueue<pair<int,
      int>> nonsick_q;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(sick[i] == ''0''){\n\t\t\tnonsick_q.push(make_pair(i,
      0));\n\t\t\tdist_to_nonsick[i] = 0;\n\t\t}\n\t}\n \n\twhile(nonsick_q.size()){\n\t\tpair<int,
      int> a = nonsick_q.front(); nonsick_q.pop();\n\t\tint node = a.first;\n\t\tint
      d = a.second;\n\t\tif(dist_to_nonsick[node] < d) continue;\n\t\tfor(auto u:
      adj[node]){\n\t\t\tif(dist_to_nonsick[u] > d+1){\n\t\t\t\tdist_to_nonsick[u]
      = d+1;\n\t\t\t\tnonsick_q.push(make_pair(u, dist_to_nonsick[u]));\n\t\t\t}\n\t\t}\n\t}\n
      \n\tgenDepth(1);\n \n\t//sort nodes by depth\n\tfor(int i = 1; i <= N; i++)
      sorted_by_depth.push_back(i);\n\tsort(begin(sorted_by_depth), end(sorted_by_depth),
      [&](int a, int b){\n\t\treturn depth[a] < depth[b];\n\t});\n \n\tint Q; cin
      >> Q;\n\tfor(int i = 1; i <= Q; i++){\n\t\tint nights; cin >> nights;\n\t\tsolve(nights);\n\t}\n}\n\nFull
      Solution 1:\nWe will answer each query in $O(N)$. This solution follows from  generalizing\nthe
      subtask 2 greedy solution or removing unnecessary states from the subtask 3\nDP
      solution (it turns out that we need to keep at most two states for each\nsubtree).
      For a node $v$, let $closest_S(v)$ denote the distance from $v$ to its\nclosest
      node in\n$S$.\nFor any vertex $v$, let $I_v$ be the set of infected cows in
      $v$''s subtree, and\nlet $S_v$ be the set of source cows in $v$''s subtree.
      In addition, let $I_v''$ be\nthe set of infected cows in $v$''s subtree that
      are distance greater than\n$T-closest_S(parent_v)$ away from $parent_v$. When
      all cows are infected, $I_v''$\nis precisely the set of all cows in $v$''s subtree
      distance at least $T$ away\nfrom $v$.  Observe that every node in $I_v''$ must
      be covered by some node\ninside $v$''s subtree, and every node in $I_v\\setminus
      I_v''$ would be covered by\nchoosing the closest cow to $parent_v$. Intuitively,
      $I_v\\setminus I_v''$ is the\nset of all cows in $v$''s subtree that might be
      covered by some node outside of\n$v$''s subtree (though they might instead be
      covered by some node inside $v$''s\nsubtree).\nLet $f(v)$ be the smallest number
      of nodes in $S_v$ we need to pick so that\nevery node in $I_v''$ is covered.
      Clearly $f(v) \\geq \\sum_{u\\in C_v} f(u)$. In\nfact the following is also
      true:\nLemma: $f(v) \\leq 1 + \\sum_{u\\in C_v} f(u)$.\nProof: We will show
      that all of $I_v$ can be covered by at most\n$1 + \\sum_{u\\in C_v} f(u)$ source
      nodes (one of which need not be in $v$''s\nsubtree). Choosing all of these source
      nodes (excluding any outside of $v$''s\nsubtree) would cover $I_v''$.\nSuppose
      that, in each subtree, we pick $f(u)$ sources in $S_u$ that cover\n$I_u''$,
      and also we are in the best possible DP state (states are defined in the\nsolution
      above). Here, \"every infected node in $u$''s subtree is covered, as is\neverything
      distance $T$ outside of $u$\" is the best case, followed by \"every\ninfected
      node in $u$''s subtree is covered, as is everything distance $T-1$\noutside
      of $u$\", etc.,  and then \"every infected node $u$''s subtree is covered,\nbut
      nothing outside the subtree is\" is better than  \"every infected node in\n$u$''s
      subtree is covered except $u$\", which is better than \"the deepest\nuncovered
      infected node is at depth 1\", which is better than \"the deepest\nuncovered
      infected node is at depth 2\", etc.\nNow, suppose $u_1, \\ldots, u_k$ are the
      children such that\n$I_{u_1}, \\ldots, I_{u_k}$ are not fully covered. Suppose
      their deepest\nuncovered children are at depth $d_1, \\ldots, d_k$, respectively
      with respect to\n$v$.  Without loss of generality suppose $d_1 = \\max(d_1,
      \\ldots, d_k)$. By\nassumption,  there exists some source node $w$ such that\n$d(w,
      parent_{u_1})=d(w,v) \\leq T - d_1$. Then, $d(w, v) \\leq T-d_i$ for every\n$i$,
      so adding $w$ to the set of sources covers all of $I_v$. This completes the\nproof
      (note that $w$ covers $v$ if needed also). $\\Box$\nSince the answer to the
      query is just $f(\\text{root})$, we just need to figure\nout when the difference
      $f(v) - \\sum_{u\\in C_v} f(u)$ is $0$ or $1$. To do this,\nwhen computing the
      DP, we additionally store what the \"best case\" is. We can do\nthis in $O(\\#\\text{children})$
      for each node with some preprocessing. Then, the\ndifference is one precisely
      when there is an uncovered node in $I_v''$, in which\ncase we can choose the
      closest node in $S$ to $v$. This newly chosen node is\nguaranteed to cover all
      uncovered nodes in $I_v$ (any nodes in $v$''s subtree not\ncovered by this new
      node are part of $I_c''$ for some child $c$ of $v$, which\nshould have been
      covered already). Note that due to our earlier observation\nabout $I_v''$, this
      node will be in $v$''s subtree.\nBen''s code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\n#define
      mp make_pair\n#define f first\n#define s second\n\n#define sz(x) int((x).size())\n#define
      rsz resize\n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i <
      (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define rep(a) F0R(_, a)\n\nvector<vi>
      adj;\nstring infected;\nvi closest_not_infected;\nint N;\n\nvi closest_ok;\nint
      n, ans;\n\n// state:\n// dist d to closest chosen: {1, d}\n// dist d to farthest
      uncovered: {-1, d}\n// nothing: {0, 0}\n\npi comb(pi a, pi b) {\n\tif (a > b)
      swap(a, b);\n\tif (a.f == 0) return b;\n\tif (b.f == 0) return a;\n\tif (b.f
      == -1) return max(a, b);\n\tif (a.f == 1) return min(a, b);\n\tassert(a.f ==
      -1 && b.f == 1);\n\tif (a.s + b.s > n) return a;  // uncovered\n\treturn b;                     //
      covered\n}\n\npi dfs(int x, int p) {  // cover x''s subtree\n\tpi best{infected.at(x)
      == ''1'' ? -1 : 0, 0};\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tpi
      d = dfs(y, x);\n\t\t\tif (d.f != 0) ++d.s;\n\t\t\tbest = comb(best, d);\n\t\t}\n\tif
      (best.f == -1) {\n\t\t// check that choosing closest node in S to x would cover
      everything in\n\t\t// x''s subtree\n\t\tassert(best.s + closest_ok.at(x) <=
      n);\n\t\tif (p == -1 || best.s + 1 + closest_ok[p] > n) {\n\t\t\t// there''s
      something that must be covered by something in x''s\n\t\t\t// subtree\n\t\t\t//
      choose closest node in S to x, which will be in x''s\n\t\t\t// subtree\n\t\t\t++ans;\n\t\t\tbest
      = {1, closest_ok.at(x)};\n\t\t}\n\t}\n\treturn best;\n}\n\nvi multi_bfs(const
      vi &sources) {\n\tvi ret(N, N + 1);\n\tqueue<int> q;\n\tfor (int i : sources)
      {\n\t\tret.at(i) = 0;\n\t\tq.push(i);\n\t}\n\twhile (sz(q)) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor
      (int y : adj.at(x))\n\t\t\tif (ret.at(x) + 1 < ret.at(y)) {\n\t\t\t\tret.at(y)
      = ret.at(x) + 1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t}\n\treturn ret;\n}\n\nint
      query() {\n\tvi origins;  // S in the analysis\n\tF0R(i, N) if (closest_not_infected.at(i)
      > n) origins.pb(i);\n\t// distance from each node to closest element of S\n\tclosest_ok
      = multi_bfs(origins);\n\tF0R(i, N)\n\tif (infected.at(i) == ''1'' && closest_ok.at(i)
      > n)\n\t\treturn -1;  // i can''t be covered by anything in S\n\tans = 0;\n\tdfs(0,
      -1);\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin
      >> N;\n\tcin >> infected;\n\tadj.rsz(N);\n\trep(N - 1) {\n\t\tint a, b;\n\t\tcin
      >> a >> b;\n\t\t--a, --b;\n\t\tadj.at(a).pb(b), adj.at(b).pb(a);\n\t}\n\tvi
      sources;\n\tF0R(i, N) if (infected.at(i) == ''0'') sources.pb(i);\n\tclosest_not_infected
      = multi_bfs(sources);\n\tint Q;\n\tcin >> Q;\n\trep(Q) {\n\t\tcin >> n;\n\t\tcout
      << query() << \"\\n\";\n\t}\n}\n\nFull Solution 2:\nWe can use centroid decomposition
      in \nthe subtask 3 greedy solution to answer queries in $O(N\\log{N})$.\nSpecifically,
      using centroid decomposition, we can do the following tasks.\nIn $O(N\\log N)$
      time, for every node $v$, find the minimum depth node  $s$\nwithin distance
      $T$ of $v$ satisfying $s \\in S$.In $O(\\log N)$ time, mark a node as chosen.In
      $O(\\log N)$ time, compute the distance from a node to its nearest chosen\nnode.\nWe
      leave the details as an exercise to the reader.\n\n    </solution>","type":"Document"}],"test_cases":"..."},"session_name":"default","name":"BM25Retriever","inputs":{"query":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","test_cases":"..."},"run_type":"retriever"},{"id":"fd424521-d4da-44d6-bf77-812e22ede0c0","start_time":"2024-09-19T18:19:52.751823+00:00","end_time":"2024-09-19T18:19:52.752201+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":2,"langgraph_node":"retrieve","langgraph_triggers":["draft"],"langgraph_path":["__pregel_pull","retrieve"],"langgraph_checkpoint_ns":"retrieve:ccf8bf45-8492-eb9c-afd2-4ab2f1465c4f","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:19:52.751823+00:00"},{"name":"end","time":"2024-09-19T18:19:52.752201+00:00"}],"reference_example_id":null,"parent_run_id":"67ca6620-4bae-42c7-92c1-b5a98e5e98fe","tags":["seq:step:2","langsmith:hidden"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952748601Z67ca6620-4bae-42c7-92c1-b5a98e5e98fe.20240919T181952751823Zfd424521-d4da-44d6-bf77-812e22ede0c0","outputs":{"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"session_name":"default","name":"ChannelWrite<retrieve,candidate,examples,messages,test_cases,runtime_limit,status>","inputs":{"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"run_type":"chain"},{"id":"e2982da8-41de-4a02-b62a-ad14364afca4","start_time":"2024-09-19T18:19:52.753002+00:00","end_time":null,"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:19:52.753002+00:00"}],"reference_example_id":null,"parent_run_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","tags":["graph:step:3"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4","outputs":null,"session_name":"default","name":"solve","inputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"run_type":"chain"},{"id":"eb06a46a-f677-45b7-a64a-a83cec798943","start_time":"2024-09-19T18:19:52.753671+00:00","end_time":null,"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:19:52.753671+00:00"}],"reference_example_id":null,"parent_run_id":"e2982da8-41de-4a02-b62a-ad14364afca4","tags":["seq:step:1"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4.20240919T181952753671Zeb06a46a-f677-45b7-a64a-a83cec798943","outputs":null,"session_name":"default","name":"RunnableSequence","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"run_type":"chain"},{"id":"8f9c78e4-9b4c-4958-82ed-90c9d5d9ad82","start_time":"2024-09-19T18:19:52.754293+00:00","end_time":"2024-09-19T18:19:52.754884+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","lc_hub_owner":"wfh","lc_hub_repo":"usaco-draft-solver","lc_hub_commit_hash":"ebe137168aa80680242963bc1f8a8eeaaf0d16b75e5c1faceab9898a4f1150d3","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"serialized":{"lc":1,"type":"constructor","id":["langchain","prompts","chat","ChatPromptTemplate"],"kwargs":{"input_variables":["examples","messages"],"metadata":{"lc_hub_owner":"wfh","lc_hub_repo":"usaco-draft-solver","lc_hub_commit_hash":"ebe137168aa80680242963bc1f8a8eeaaf0d16b75e5c1faceab9898a4f1150d3"},"messages":[{"lc":1,"type":"constructor","id":["langchain","prompts","chat","SystemMessagePromptTemplate"],"kwargs":{"prompt":{"lc":1,"type":"constructor","id":["langchain","prompts","prompt","PromptTemplate"],"kwargs":{"input_variables":["examples"],"template":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.{examples}","template_format":"f-string"},"name":"PromptTemplate"}}},{"lc":1,"type":"constructor","id":["langchain","prompts","chat","MessagesPlaceholder"],"kwargs":{"variable_name":"messages"}}]},"name":"ChatPromptTemplate"},"events":[{"name":"start","time":"2024-09-19T18:19:52.754293+00:00"},{"name":"end","time":"2024-09-19T18:19:52.754884+00:00"}],"reference_example_id":null,"parent_run_id":"eb06a46a-f677-45b7-a64a-a83cec798943","tags":["seq:step:1"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4.20240919T181952753671Zeb06a46a-f677-45b7-a64a-a83cec798943.20240919T181952754293Z8f9c78e4-9b4c-4958-82ed-90c9d5d9ad82","outputs":{"output":{"messages":[{"content":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.\n    You previously solved the following problems in
      this competition:\n    <Examples>\n    <problem>\n    Farmer John has $N$ ($1
      \\le {N} \\le {10^5}$) cows, the breed of each being\neither a Guernsey or a
      Holstein. They have lined up horizontally with the cows occupying positions
      \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ decides to
      plant grassy patches on some\nof the positions $1\\dots N$. Guernseys and Holsteins
      prefer different types of\ngrass, so if Farmer John decides to plant grass at
      some location, he must choose\nto planting either Guernsey-preferred grass or
      Holstein-preferred grass --- he\ncannot plant both at the same location. Each
      patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","additional_kwargs":{},"response_metadata":{},"type":"system"},{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58"}]},"test_cases":"..."},"session_name":"default","name":"ChatPromptTemplate","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"run_type":"prompt"},{"id":"0b58e6fc-617f-4740-ba7e-9880322c64af","start_time":"2024-09-19T18:19:52.756197+00:00","end_time":null,"extra":{"invocation_params":{"model":"claude-3-opus-20240229","max_tokens":4000,"temperature":null,"top_k":null,"top_p":null,"model_kwargs":{},"streaming":false,"max_retries":2,"default_request_timeout":null,"_type":"anthropic-chat","stop":null,"tools":[{"name":"writePython","description":"Write
      python code that resolves the problem.","input_schema":{"properties":{"reasoning":{"description":"Conceptual
      solution.","type":"string"},"pseudocode":{"description":"Detailed English pseudocode.","type":"string"},"code":{"description":"Valid
      Python 3 solution to the problem","type":"string"}},"required":["reasoning","pseudocode","code"],"type":"object"}}]},"options":{"stop":null},"batch_size":1,"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","ls_provider":"anthropic","ls_model_name":"claude-3-opus-20240229","ls_model_type":"chat","ls_temperature":null,"ls_max_tokens":4000,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"serialized":{"lc":1,"type":"constructor","id":["langchain","chat_models","anthropic","ChatAnthropic"],"kwargs":{"model":"claude-3-opus-20240229","max_tokens":4000,"max_retries":2,"anthropic_api_url":"https://api.anthropic.com","anthropic_api_key":{"lc":1,"type":"secret","id":["ANTHROPIC_API_KEY"]},"stream_usage":true},"name":"ChatAnthropic"},"events":[{"name":"start","time":"2024-09-19T18:19:52.756197+00:00"}],"reference_example_id":null,"parent_run_id":"eb06a46a-f677-45b7-a64a-a83cec798943","tags":["seq:step:2"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4.20240919T181952753671Zeb06a46a-f677-45b7-a64a-a83cec798943.20240919T181952756197Z0b58e6fc-617f-4740-ba7e-9880322c64af","outputs":null,"session_name":"default","name":"ChatAnthropic","inputs":{"messages":[[{"lc":1,"type":"constructor","id":["langchain","schema","messages","SystemMessage"],"kwargs":{"content":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.\n    You previously solved the following problems in
      this competition:\n    <Examples>\n    <problem>\n    Farmer John has $N$ ($1
      \\le {N} \\le {10^5}$) cows, the breed of each being\neither a Guernsey or a
      Holstein. They have lined up horizontally with the cows occupying positions
      \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ decides to
      plant grassy patches on some\nof the positions $1\\dots N$. Guernseys and Holsteins
      prefer different types of\ngrass, so if Farmer John decides to plant grass at
      some location, he must choose\nto planting either Guernsey-preferred grass or
      Holstein-preferred grass --- he\ncannot plant both at the same location. Each
      patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","type":"system"}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","HumanMessage"],"kwargs":{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58"}}]],"test_cases":"..."},"run_type":"llm"}],"patch":[{"id":"e551fcf9-9e33-4fe5-9bb1-98887f998b4f","name":"draft","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181918250003Ze551fcf9-9e33-4fe5-9bb1-98887f998b4f","tags":["graph:step:1"],"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":1,"langgraph_node":"draft","langgraph_triggers":["start:draft"],"langgraph_path":["__pregel_pull","draft"],"langgraph_checkpoint_ns":"draft:cda28afa-f13f-d31a-0b4b-5b431e5199e9","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:19:52.747534+00:00","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"outputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"test_cases":"..."},"events":[{"name":"end","time":"2024-09-19T18:19:52.747534+00:00"}]},{"id":"20648061-a882-4dac-8f16-0ae1d649d3d0","name":"RunnableSequence","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":"e551fcf9-9e33-4fe5-9bb1-98887f998b4f","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181918250003Ze551fcf9-9e33-4fe5-9bb1-98887f998b4f.20240919T181918250528Z20648061-a882-4dac-8f16-0ae1d649d3d0","tags":["seq:step:1"],"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":1,"langgraph_node":"draft","langgraph_triggers":["start:draft"],"langgraph_path":["__pregel_pull","draft"],"langgraph_checkpoint_ns":"draft:cda28afa-f13f-d31a-0b4b-5b431e5199e9","checkpoint_ns":"draft:cda28afa-f13f-d31a-0b4b-5b431e5199e9","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:19:52.746158+00:00","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"test_cases":"..."},"outputs":{"output":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"test_cases":"..."},"events":[{"name":"end","time":"2024-09-19T18:19:52.746158+00:00"}]},{"id":"7ea7ee26-86e5-4d16-9f95-df93ec4b3722","name":"ChatAnthropic","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":"20648061-a882-4dac-8f16-0ae1d649d3d0","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181918250003Ze551fcf9-9e33-4fe5-9bb1-98887f998b4f.20240919T181918250528Z20648061-a882-4dac-8f16-0ae1d649d3d0.20240919T181918252499Z7ea7ee26-86e5-4d16-9f95-df93ec4b3722","tags":["seq:step:2"],"extra":{"invocation_params":{"model":"claude-3-opus-20240229","max_tokens":4000,"temperature":null,"top_k":null,"top_p":null,"model_kwargs":{},"streaming":false,"max_retries":2,"default_request_timeout":null,"_type":"anthropic-chat","stop":null,"tools":[{"name":"writePython","description":"Write
      python code that resolves the problem.","input_schema":{"properties":{"reasoning":{"description":"Conceptual
      solution.","type":"string"},"pseudocode":{"description":"Detailed English pseudocode.","type":"string"},"code":{"description":"Valid
      Python 3 solution to the problem","type":"string"}},"required":["reasoning","pseudocode","code"],"type":"object"}}]},"options":{"stop":null},"batch_size":1,"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":1,"langgraph_node":"draft","langgraph_triggers":["start:draft"],"langgraph_path":["__pregel_pull","draft"],"langgraph_checkpoint_ns":"draft:cda28afa-f13f-d31a-0b4b-5b431e5199e9","checkpoint_ns":"draft:cda28afa-f13f-d31a-0b4b-5b431e5199e9","ls_provider":"anthropic","ls_model_name":"claude-3-opus-20240229","ls_model_type":"chat","ls_temperature":null,"ls_max_tokens":4000,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:19:52.745646+00:00","inputs":{"messages":[[{"lc":1,"type":"constructor","id":["langchain","schema","messages","SystemMessage"],"kwargs":{"content":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.","type":"system"}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","HumanMessage"],"kwargs":{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58"}}]],"test_cases":"..."},"outputs":{"generations":[[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","generation_info":null,"type":"ChatGeneration","message":{"lc":1,"type":"constructor","id":["langchain","schema","messages","AIMessage"],"kwargs":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251},"invalid_tool_calls":[]}}}]],"llm_output":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"run":null,"type":"LLMResult","test_cases":"..."},"events":[{"name":"start","time":"2024-09-19T18:19:18.252499+00:00"},{"name":"end","time":"2024-09-19T18:19:52.745646+00:00"}]}]}'
    headers:
      Accept:
      - application/json
      Accept-Encoding:
      - gzip, deflate
      Connection:
      - keep-alive
      Content-Length:
      - '570235'
      Content-Type:
      - application/json
      User-Agent:
      - langsmith-py/0.1.123
    method: POST
    uri: https://api.smith.langchain.com/runs/batch
  response:
    body:
      string: '{"detail":"Monthly unique traces usage limit exceeded"}'
    headers:
      Access-Control-Allow-Credentials:
      - 'true'
      Access-Control-Allow-Headers:
      - '*'
      Access-Control-Allow-Methods:
      - '*'
      Access-Control-Allow-Origin:
      - ''
      Access-Control-Expose-Headers:
      - '*'
      Access-Control-Max-Age:
      - '600'
      Alt-Svc:
      - h3=":443"; ma=2592000,h3-29=":443"; ma=2592000
      Connection:
      - close
      Content-Length:
      - '55'
      Via:
      - 1.1 google
      content-type:
      - application/json
      date:
      - Thu, 19 Sep 2024 18:21:22 GMT
      server:
      - uvicorn
    status:
      code: 429
      message: Too Many Requests
- request:
    body: '{"post":[{"id":"7c9bfd90-04ad-49c0-9cff-10ea26ba3f88","start_time":"2024-09-19T18:20:48.296617+00:00","end_time":"2024-09-19T18:20:48.297016+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:48.296617+00:00"},{"name":"end","time":"2024-09-19T18:20:48.297016+00:00"}],"reference_example_id":null,"parent_run_id":"e2982da8-41de-4a02-b62a-ad14364afca4","tags":["seq:step:2","langsmith:hidden"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4.20240919T182048296617Z7c9bfd90-04ad-49c0-9cff-10ea26ba3f88","outputs":{"messages":{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},"test_cases":"..."},"session_name":"default","name":"ChannelWrite<solve,candidate,examples,messages,test_cases,runtime_limit,status>","inputs":{"messages":{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},"test_cases":"..."},"run_type":"chain"},{"id":"644fd5b2-b220-4ac0-ad4d-17f1adeb8b77","start_time":"2024-09-19T18:20:48.298273+00:00","end_time":"2024-09-19T18:20:48.981503+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":4,"langgraph_node":"evaluate","langgraph_triggers":["solve"],"langgraph_path":["__pregel_pull","evaluate"],"langgraph_checkpoint_ns":"evaluate:ae68876e-62a3-1b2a-eee8-6df0619e0519","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:48.298273+00:00"},{"name":"end","time":"2024-09-19T18:20:48.981503+00:00"}],"reference_example_id":null,"parent_run_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","tags":["graph:step:4"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T182048298273Z644fd5b2-b220-4ac0-ad4d-17f1adeb8b77","outputs":{"messages":[{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"}],"test_cases":"..."},"session_name":"default","name":"evaluate","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"run_type":"chain"},{"id":"1ddf445a-b271-4688-b374-a4861e9ab305","start_time":"2024-09-19T18:20:48.980471+00:00","end_time":"2024-09-19T18:20:48.980895+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":4,"langgraph_node":"evaluate","langgraph_triggers":["solve"],"langgraph_path":["__pregel_pull","evaluate"],"langgraph_checkpoint_ns":"evaluate:ae68876e-62a3-1b2a-eee8-6df0619e0519","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:48.980471+00:00"},{"name":"end","time":"2024-09-19T18:20:48.980895+00:00"}],"reference_example_id":null,"parent_run_id":"644fd5b2-b220-4ac0-ad4d-17f1adeb8b77","tags":["seq:step:2","langsmith:hidden"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T182048298273Z644fd5b2-b220-4ac0-ad4d-17f1adeb8b77.20240919T182048980471Z1ddf445a-b271-4688-b374-a4861e9ab305","outputs":{"messages":[{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"}],"test_cases":"..."},"session_name":"default","name":"ChannelWrite<evaluate,candidate,examples,messages,test_cases,runtime_limit,status>","inputs":{"messages":[{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"}],"test_cases":"..."},"run_type":"chain"},{"id":"560dd218-57cc-48af-bbaa-191ba2808bca","start_time":"2024-09-19T18:20:48.981199+00:00","end_time":"2024-09-19T18:20:48.981428+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":4,"langgraph_node":"evaluate","langgraph_triggers":["solve"],"langgraph_path":["__pregel_pull","evaluate"],"langgraph_checkpoint_ns":"evaluate:ae68876e-62a3-1b2a-eee8-6df0619e0519","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:48.981199+00:00"},{"name":"end","time":"2024-09-19T18:20:48.981428+00:00"}],"reference_example_id":null,"parent_run_id":"644fd5b2-b220-4ac0-ad4d-17f1adeb8b77","tags":["seq:step:3"],"trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T182048298273Z644fd5b2-b220-4ac0-ad4d-17f1adeb8b77.20240919T182048981199Z560dd218-57cc-48af-bbaa-191ba2808bca","outputs":{"output":"solve","test_cases":"..."},"session_name":"default","name":"control_edge","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"run_type":"chain"},{"id":"f84b767f-9c07-419d-9969-433a8b434961","start_time":"2024-09-19T18:20:49.030573+00:00","end_time":null,"extra":{"metadata":{"thread_id":"silver-hl-1","checkpoint_ns":"","checkpoint_id":"1ef76b3e-54fe-6a56-8005-97ede246b587","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.030573+00:00"}],"reference_example_id":null,"parent_run_id":null,"tags":[],"trace_id":"f84b767f-9c07-419d-9969-433a8b434961","dotted_order":"20240919T182049030573Zf84b767f-9c07-419d-9969-433a8b434961","outputs":null,"session_name":"default","name":"LangGraph","inputs":{"input":null,"test_cases":"..."},"run_type":"chain"},{"id":"9c9190c8-a792-48d3-b444-94e69abcb536","start_time":"2024-09-19T18:20:49.030949+00:00","end_time":null,"extra":{"metadata":{"thread_id":"silver-hl-1","checkpoint_ns":"","checkpoint_id":"1ef76b3e-54fe-6a56-8005-97ede246b587","langgraph_step":6,"langgraph_node":"solve","langgraph_triggers":["branch:evaluate:control_edge:solve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:8a832a0b-5df1-94fa-60c5-fd204ed2a2f3","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.030949+00:00"}],"reference_example_id":null,"parent_run_id":"f84b767f-9c07-419d-9969-433a8b434961","tags":["graph:step:6"],"trace_id":"f84b767f-9c07-419d-9969-433a8b434961","dotted_order":"20240919T182049030573Zf84b767f-9c07-419d-9969-433a8b434961.20240919T182049030949Z9c9190c8-a792-48d3-b444-94e69abcb536","outputs":null,"session_name":"default","name":"solve","inputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"},{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","additional_kwargs":{},"response_metadata":{},"type":"human","id":"bcec3528-7343-4a6e-a2d0-f11973a26df4","example":false}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"run_type":"chain"},{"id":"cc4d1780-4ac2-4f90-ad36-c678b1438c04","start_time":"2024-09-19T18:20:49.031269+00:00","end_time":null,"extra":{"metadata":{"thread_id":"silver-hl-1","checkpoint_ns":"","checkpoint_id":"1ef76b3e-54fe-6a56-8005-97ede246b587","langgraph_step":6,"langgraph_node":"solve","langgraph_triggers":["branch:evaluate:control_edge:solve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:8a832a0b-5df1-94fa-60c5-fd204ed2a2f3","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"events":[{"name":"start","time":"2024-09-19T18:20:49.031269+00:00"}],"reference_example_id":null,"parent_run_id":"9c9190c8-a792-48d3-b444-94e69abcb536","tags":["seq:step:1"],"trace_id":"f84b767f-9c07-419d-9969-433a8b434961","dotted_order":"20240919T182049030573Zf84b767f-9c07-419d-9969-433a8b434961.20240919T182049030949Z9c9190c8-a792-48d3-b444-94e69abcb536.20240919T182049031269Zcc4d1780-4ac2-4f90-ad36-c678b1438c04","outputs":null,"session_name":"default","name":"RunnableSequence","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"},{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","additional_kwargs":{},"response_metadata":{},"type":"human","id":"bcec3528-7343-4a6e-a2d0-f11973a26df4","example":false}],"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"run_type":"chain"},{"id":"69fed1eb-9eaf-4a22-85fb-e0857d8766bb","start_time":"2024-09-19T18:20:49.031481+00:00","end_time":"2024-09-19T18:20:49.031812+00:00","extra":{"metadata":{"thread_id":"silver-hl-1","checkpoint_ns":"","checkpoint_id":"1ef76b3e-54fe-6a56-8005-97ede246b587","langgraph_step":6,"langgraph_node":"solve","langgraph_triggers":["branch:evaluate:control_edge:solve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:8a832a0b-5df1-94fa-60c5-fd204ed2a2f3","lc_hub_owner":"wfh","lc_hub_repo":"usaco-draft-solver","lc_hub_commit_hash":"ebe137168aa80680242963bc1f8a8eeaaf0d16b75e5c1faceab9898a4f1150d3","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"error":null,"serialized":{"lc":1,"type":"constructor","id":["langchain","prompts","chat","ChatPromptTemplate"],"kwargs":{"input_variables":["examples","messages"],"metadata":{"lc_hub_owner":"wfh","lc_hub_repo":"usaco-draft-solver","lc_hub_commit_hash":"ebe137168aa80680242963bc1f8a8eeaaf0d16b75e5c1faceab9898a4f1150d3"},"messages":[{"lc":1,"type":"constructor","id":["langchain","prompts","chat","SystemMessagePromptTemplate"],"kwargs":{"prompt":{"lc":1,"type":"constructor","id":["langchain","prompts","prompt","PromptTemplate"],"kwargs":{"input_variables":["examples"],"template":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.{examples}","template_format":"f-string"},"name":"PromptTemplate"}}},{"lc":1,"type":"constructor","id":["langchain","prompts","chat","MessagesPlaceholder"],"kwargs":{"variable_name":"messages"}}]},"name":"ChatPromptTemplate"},"events":[{"name":"start","time":"2024-09-19T18:20:49.031481+00:00"},{"name":"end","time":"2024-09-19T18:20:49.031812+00:00"}],"reference_example_id":null,"parent_run_id":"cc4d1780-4ac2-4f90-ad36-c678b1438c04","tags":["seq:step:1"],"trace_id":"f84b767f-9c07-419d-9969-433a8b434961","dotted_order":"20240919T182049030573Zf84b767f-9c07-419d-9969-433a8b434961.20240919T182049030949Z9c9190c8-a792-48d3-b444-94e69abcb536.20240919T182049031269Zcc4d1780-4ac2-4f90-ad36-c678b1438c04.20240919T182049031481Z69fed1eb-9eaf-4a22-85fb-e0857d8766bb","outputs":{"output":{"messages":[{"content":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.\n    You previously solved the following problems in
      this competition:\n    <Examples>\n    <problem>\n    Farmer John has $N$ ($1
      \\le {N} \\le {10^5}$) cows, the breed of each being\neither a Guernsey or a
      Holstein. They have lined up horizontally with the cows occupying positions
      \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ decides to
      plant grassy patches on some\nof the positions $1\\dots N$. Guernseys and Holsteins
      prefer different types of\ngrass, so if Farmer John decides to plant grass at
      some location, he must choose\nto planting either Guernsey-preferred grass or
      Holstein-preferred grass --- he\ncannot plant both at the same location. Each
      patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","additional_kwargs":{},"response_metadata":{},"type":"system"},{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58"},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0"},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138"},{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","additional_kwargs":{},"response_metadata":{},"type":"human","id":"bcec3528-7343-4a6e-a2d0-f11973a26df4"}]},"test_cases":"..."},"session_name":"default","name":"ChatPromptTemplate","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"},{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","additional_kwargs":{},"response_metadata":{},"type":"human","id":"bcec3528-7343-4a6e-a2d0-f11973a26df4","example":false}],"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"run_type":"prompt"},{"id":"b0b13ccf-0a94-4fa1-bd6a-ceedb56e625c","start_time":"2024-09-19T18:20:49.032079+00:00","end_time":null,"extra":{"invocation_params":{"model":"claude-3-opus-20240229","max_tokens":4000,"temperature":null,"top_k":null,"top_p":null,"model_kwargs":{},"streaming":false,"max_retries":2,"default_request_timeout":null,"_type":"anthropic-chat","stop":null,"tools":[{"name":"writePython","description":"Write
      python code that resolves the problem.","input_schema":{"properties":{"reasoning":{"description":"Conceptual
      solution.","type":"string"},"pseudocode":{"description":"Detailed English pseudocode.","type":"string"},"code":{"description":"Valid
      Python 3 solution to the problem","type":"string"}},"required":["reasoning","pseudocode","code"],"type":"object"}}]},"options":{"stop":null},"batch_size":1,"metadata":{"thread_id":"silver-hl-1","checkpoint_ns":"","checkpoint_id":"1ef76b3e-54fe-6a56-8005-97ede246b587","langgraph_step":6,"langgraph_node":"solve","langgraph_triggers":["branch:evaluate:control_edge:solve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:8a832a0b-5df1-94fa-60c5-fd204ed2a2f3","ls_provider":"anthropic","ls_model_name":"claude-3-opus-20240229","ls_model_type":"chat","ls_temperature":null,"ls_max_tokens":4000,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langchain-core","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1","library_version":"0.3.1"}},"error":null,"serialized":{"lc":1,"type":"constructor","id":["langchain","chat_models","anthropic","ChatAnthropic"],"kwargs":{"model":"claude-3-opus-20240229","max_tokens":4000,"max_retries":2,"anthropic_api_url":"https://api.anthropic.com","anthropic_api_key":{"lc":1,"type":"secret","id":["ANTHROPIC_API_KEY"]},"stream_usage":true},"name":"ChatAnthropic"},"events":[{"name":"start","time":"2024-09-19T18:20:49.032079+00:00"}],"reference_example_id":null,"parent_run_id":"cc4d1780-4ac2-4f90-ad36-c678b1438c04","tags":["seq:step:2"],"trace_id":"f84b767f-9c07-419d-9969-433a8b434961","dotted_order":"20240919T182049030573Zf84b767f-9c07-419d-9969-433a8b434961.20240919T182049030949Z9c9190c8-a792-48d3-b444-94e69abcb536.20240919T182049031269Zcc4d1780-4ac2-4f90-ad36-c678b1438c04.20240919T182049032079Zb0b13ccf-0a94-4fa1-bd6a-ceedb56e625c","outputs":null,"session_name":"default","name":"ChatAnthropic","inputs":{"messages":[[{"lc":1,"type":"constructor","id":["langchain","schema","messages","SystemMessage"],"kwargs":{"content":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.\n    You previously solved the following problems in
      this competition:\n    <Examples>\n    <problem>\n    Farmer John has $N$ ($1
      \\le {N} \\le {10^5}$) cows, the breed of each being\neither a Guernsey or a
      Holstein. They have lined up horizontally with the cows occupying positions
      \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ decides to
      plant grassy patches on some\nof the positions $1\\dots N$. Guernseys and Holsteins
      prefer different types of\ngrass, so if Farmer John decides to plant grass at
      some location, he must choose\nto planting either Guernsey-preferred grass or
      Holstein-preferred grass --- he\ncannot plant both at the same location. Each
      patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","type":"system"}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","HumanMessage"],"kwargs":{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58"}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","AIMessage"],"kwargs":{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869},"invalid_tool_calls":[]}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","ToolMessage"],"kwargs":{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","HumanMessage"],"kwargs":{"content":"Consider
      breaking down the algorithm into separate parts: reading inputs, detecting cycles
      using the tortoise and hare algorithm, and determining Bessie''s final position
      by skipping ahead K steps.\n    \n    Read the inputs into three arrays:\n    -
      Two arrays L and R for the ports (adjust for 0-based indexing)\n    - A third
      array S for the direction sequence\n    \n    Optimize by multiplying K by M
      before the main loop to convert the number of repetitions into the total number
      of steps.\n    \n    Use the tortoise and hare algorithm to detect the cycle:\n    -
      Define a helper function get_next(v) that returns the next position and direction
      index\n    - Initialize two pointers s0 and s1 to (0, 0)\n    - In each iteration:\n      -
      Move s0 by 1 step and s1 by 2 steps using get_next()\n      - If s0 equals s1,
      decrement K by 1 and break out of the loop\n      - Otherwise, decrement K by
      1\n    - After the loop, if K is not 0, there is a cycle\n    \n    To find
      the cycle length:\n    - Initialize a counter variable rho to 1\n    - Move
      s0 by 1 step using get_next()\n    - Enter a loop:\n      - Move s0 by 1 step
      using get_next()\n      - Increment rho\n      - If s0 equals s1, break out
      of the loop\n    \n    Skip ahead by reducing K modulo rho.\n    \n    Simulate
      the remaining steps:\n    - While K > 0, move s0 to the next position using
      get_next() and decrement K\n    \n    Print the final position (converted to
      1-based indexing).\n    \n    Pay close attention to the initialization and
      movement of pointers during cycle detection and length calculation. Ensure that
      the logic is correct and handles all cases accurately.","type":"human","id":"bcec3528-7343-4a6e-a2d0-f11973a26df4"}}]],"test_cases":"..."},"run_type":"llm"}],"patch":[{"id":"6ace1794-fbd8-4215-97e9-2a930568fce6","name":"LangGraph","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":null,"dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6","tags":[],"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:20:48.982274+00:00","inputs":{"messages":[["user","Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n"]],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"outputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false},{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},{"content":"Incorrect
      submission. Please respond with updated code.\nPass rate: 0/10\nResults:\n<test
      id=0>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (2, 4) is not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (68, 13)
      is not in list\n\n</test>\n<test id=3>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (160, 22) is
      not in list\n\n</test>\n<test id=4>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (246, 17) is not in list\n\n</test>\n<test
      id=5>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (413, 27) is not in list\n\n</test>\n<test id=6>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (779, 406)
      is not in list\n\n</test>\n<test id=8>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (616, 171) is
      not in list\n\n</test>\n<test id=9>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (1, 0) is not in list\n\n</test>\nMake
      all fixes using the writePython tool.","additional_kwargs":{},"response_metadata":{},"type":"tool","id":"aa789393-4f41-48ec-8b98-fcdc4b384138","tool_call_id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","status":"success"}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"events":[{"name":"start","time":"2024-09-19T18:19:18.247740+00:00"},{"name":"end","time":"2024-09-19T18:20:48.982274+00:00"}]},{"id":"e2982da8-41de-4a02-b62a-ad14364afca4","name":"solve","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4","tags":["graph:step:3"],"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:20:48.297177+00:00","inputs":{"candidate":{"content":[{"text":"<thinking>\nTo
      solve this problem, we need to:\n\n1. Read in the input data:\n- N ports, M
      directions in the sequence, and K repetitions of the sequence\n- Adjacency list
      representation of the port connections\n- The sequence of L/R directions\n\n2.
      Simulate following the sequence of directions K times, keeping track of which
      port we end up at after each repetition.\n\nThe key realization is that we don''t
      actually need to simulate all K repetitions of the sequence. Since there are
      only N ports, after at most N repetitions we must end up in a cycle, visiting
      the same sequence of ports over and over.\n\nSo the high-level pseudocode is:\n1.
      Simulate following the directions until we detect a cycle \n2. Figure out the
      length of the cycle and where it starts\n3. Determine which port in the cycle
      we end up at after K total repetitions\n\nWe have all the inputs needed, so
      we can proceed with implementing the solution.\n</thinking>","type":"text"},{"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","input":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01C4nDTmravpY8eG4nbhpwbT","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"output_tokens":933}},"type":"ai","id":"run-7ea7ee26-86e5-4d16-9f95-df93ec4b3722-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"To
      solve this problem, we can simulate following the sequence of directions, but
      we don''t need to actually do it K times. Since there are only N ports, after
      at most N repetitions of the sequence we must end up in a cycle, visiting the
      same sequence of ports over and over.\n\nThe key steps are:\n1. Simulate following
      the directions until we detect a cycle, keeping track of the ports visited\n2.
      Figure out the length of the cycle and the index where it starts \n3. Determine
      which port in the cycle we end up at after K total repetitions","pseudocode":"N,
      M, K = read input integers \nport_left, port_right = read input arrays of port
      connections\ndirections = read input array of L/R directions\n\nports_visited
      = []\ncurr_port = 1\n\n# Simulate until a cycle is detected\nwhile curr_port
      not in ports_visited:\n    ports_visited.append(curr_port)\n    for dir in directions:\n        if
      dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n\ncycle_start = index of curr_port in ports_visited\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start\nsteps_in_cycle = total_steps - steps_before_cycle \nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])","code":"N,
      M, K = map(int, input().split())\n\nport_left = [0] * (N+1)  \nport_right =
      [0] * (N+1)\nfor i in range(1, N+1):\n    port_left[i], port_right[i] = map(int,
      input().split())\n\ndirections = input().split()\n\nports_visited = []\ncurr_port
      = 1\n\nwhile curr_port not in ports_visited:\n    ports_visited.append(curr_port)\n    for
      dir in directions:\n        if dir == ''L'':\n            curr_port = port_left[curr_port]\n        else:\n            curr_port
      = port_right[curr_port]\n            \ncycle_start = ports_visited.index(curr_port)\ncycle_length
      = len(ports_visited) - cycle_start\n\ntotal_steps = K * M\nsteps_before_cycle
      = cycle_start  \nsteps_in_cycle = total_steps - steps_before_cycle\nfinal_index_in_cycle
      = steps_in_cycle % cycle_length\n\nprint(ports_visited[cycle_start + final_index_in_cycle])"},"id":"toolu_01QVTwmrtVLGUDyZKiSqeEKA","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":1318,"output_tokens":933,"total_tokens":2251}},"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"test_cases":"...","runtime_limit":2,"status":"in_progress"},"outputs":{"messages":{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},"test_cases":"..."},"events":[{"name":"end","time":"2024-09-19T18:20:48.297177+00:00"}]},{"id":"eb06a46a-f677-45b7-a64a-a83cec798943","name":"RunnableSequence","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":"e2982da8-41de-4a02-b62a-ad14364afca4","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4.20240919T181952753671Zeb06a46a-f677-45b7-a64a-a83cec798943","tags":["seq:step:1"],"extra":{"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:20:48.296153+00:00","inputs":{"messages":[{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","additional_kwargs":{},"response_metadata":{},"type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58","example":false}],"examples":"\n    You
      previously solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","test_cases":"..."},"outputs":{"output":{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"additional_kwargs":{},"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","example":false,"tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"invalid_tool_calls":[],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869}},"test_cases":"..."},"events":[{"name":"end","time":"2024-09-19T18:20:48.296153+00:00"}]},{"id":"0b58e6fc-617f-4740-ba7e-9880322c64af","name":"ChatAnthropic","trace_id":"6ace1794-fbd8-4215-97e9-2a930568fce6","parent_run_id":"eb06a46a-f677-45b7-a64a-a83cec798943","dotted_order":"20240919T181918247740Z6ace1794-fbd8-4215-97e9-2a930568fce6.20240919T181952753002Ze2982da8-41de-4a02-b62a-ad14364afca4.20240919T181952753671Zeb06a46a-f677-45b7-a64a-a83cec798943.20240919T181952756197Z0b58e6fc-617f-4740-ba7e-9880322c64af","tags":["seq:step:2"],"extra":{"invocation_params":{"model":"claude-3-opus-20240229","max_tokens":4000,"temperature":null,"top_k":null,"top_p":null,"model_kwargs":{},"streaming":false,"max_retries":2,"default_request_timeout":null,"_type":"anthropic-chat","stop":null,"tools":[{"name":"writePython","description":"Write
      python code that resolves the problem.","input_schema":{"properties":{"reasoning":{"description":"Conceptual
      solution.","type":"string"},"pseudocode":{"description":"Detailed English pseudocode.","type":"string"},"code":{"description":"Valid
      Python 3 solution to the problem","type":"string"}},"required":["reasoning","pseudocode","code"],"type":"object"}}]},"options":{"stop":null},"batch_size":1,"metadata":{"thread_id":"silver-hl-1","k":2,"langgraph_step":3,"langgraph_node":"solve","langgraph_triggers":["retrieve"],"langgraph_path":["__pregel_pull","solve"],"langgraph_checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","checkpoint_ns":"solve:b9376379-4c9a-76bb-ff03-07d8c7476663","ls_provider":"anthropic","ls_model_name":"claude-3-opus-20240229","ls_model_type":"chat","ls_temperature":null,"ls_max_tokens":4000,"revision_id":"checkpoint==1.0.10-68-g22fa527b-dirty"},"runtime":{"sdk":"langsmith-py","sdk_version":"0.1.123","library":"langsmith","platform":"macOS-14.5-arm64-arm-64bit","runtime":"python","py_implementation":"CPython","runtime_version":"3.12.4","langchain_version":"0.3.0","langchain_core_version":"0.3.1"}},"end_time":"2024-09-19T18:20:48.295589+00:00","inputs":{"messages":[[{"lc":1,"type":"constructor","id":["langchain","schema","messages","SystemMessage"],"kwargs":{"content":"You
      are a world-class competitive programmer.\nPlease reply with a Python 3 solution
      to the problem below. \nFirst, reason through the problem and conceptualize
      a solution.\nThen write detailed pseudocode to uncover any potential logical
      errors or omissions.\nFinally output the working Python code for your solution,
      ensuring to fix any errors uncovered while writing pseudocode.\n\nNo outside
      libraries are allowed.\n    You previously solved the following problems in
      this competition:\n    <Examples>\n    <problem>\n    Farmer John has $N$ ($1
      \\le {N} \\le {10^5}$) cows, the breed of each being\neither a Guernsey or a
      Holstein. They have lined up horizontally with the cows occupying positions
      \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ decides to
      plant grassy patches on some\nof the positions $1\\dots N$. Guernseys and Holsteins
      prefer different types of\ngrass, so if Farmer John decides to plant grass at
      some location, he must choose\nto planting either Guernsey-preferred grass or
      Holstein-preferred grass --- he\ncannot plant both at the same location. Each
      patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.","type":"system"}},{"lc":1,"type":"constructor","id":["langchain","schema","messages","HumanMessage"],"kwargs":{"content":"Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n","type":"human","id":"089e388c-20e6-410c-b12e-a3b35b638c58"}}]],"test_cases":"..."},"outputs":{"generations":[[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","generation_info":null,"type":"ChatGeneration","message":{"lc":1,"type":"constructor","id":["langchain","schema","messages","AIMessage"],"kwargs":{"content":[{"text":"<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>","type":"text"},{"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","input":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"name":"writePython","type":"tool_use"}],"response_metadata":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"type":"ai","id":"run-0b58e6fc-617f-4740-ba7e-9880322c64af-0","tool_calls":[{"name":"writePython","args":{"reasoning":"We
      can simulate the movement of Bessie through the ports based on the repeating
      direction sequence. \n\nKey optimizations:\n1. Store the left/right port destinations
      in arrays for quick lookup during simulation\n2. Detect cycles by keeping track
      of previously seen (port, sequence position) states\n3. When a cycle is detected,
      fast-forward to near the end by skipping full cycles\n\nTime Complexity: O(M
      * N) \n- We simulate at most M * N steps before a cycle must be detected\n-
      Then we simulate at most M additional steps after fast-forwarding\nSpace Complexity:
      O(M * N)\n- We store M * N states to detect cycles\n\nSo this approach avoids
      simulating all K * M steps, while still arriving at the correct final port.","pseudocode":"N,
      M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)","code":"N, M, K = map(int, input().split())\n\nleft
      = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1, N+1):\n  left[i], right[i]
      = map(int, input().split())\n\nsequence = input().split()\n\nport = 1\nseen
      = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port, step %
      M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n        \n  if (port, (step+1) % M) in seen:\n    cycle_start
      = path.index((port, (step+1) % M))\n    cycle_length = step + 1 - cycle_start\n    remaining_steps
      = K*M - (step+1)\n    remaining_cycles = remaining_steps // cycle_length\n    fast_forward
      = remaining_cycles * cycle_length\n    port = path[cycle_start + (remaining_steps
      - fast_forward) % cycle_length]\n    step = K*M - (remaining_steps - fast_forward)
      % cycle_length\n    break\n        \n  step += 1\n\nwhile step < K*M:\n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n  step
      += 1\n    \nprint(port)"},"id":"toolu_01TCbGzzL5B2sa5xFezRTVMJ","type":"tool_call"}],"usage_metadata":{"input_tokens":20540,"output_tokens":1329,"total_tokens":21869},"invalid_tool_calls":[]}}}]],"llm_output":{"id":"msg_01ChuJS2m2JqPtGyzvULJDQy","model":"claude-3-opus-20240229","stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":20540,"output_tokens":1329}},"run":null,"type":"LLMResult","test_cases":"..."},"events":[{"name":"start","time":"2024-09-19T18:19:52.756197+00:00"},{"name":"end","time":"2024-09-19T18:20:48.295589+00:00"}]}]}'
    headers:
      Accept:
      - application/json
      Accept-Encoding:
      - gzip, deflate
      Connection:
      - keep-alive
      Content-Length:
      - '650038'
      Content-Type:
      - application/json
      User-Agent:
      - langsmith-py/0.1.123
    method: POST
    uri: https://api.smith.langchain.com/runs/batch
  response:
    body:
      string: '{"detail":"Monthly unique traces usage limit exceeded"}'
    headers:
      Access-Control-Allow-Credentials:
      - 'true'
      Access-Control-Allow-Headers:
      - '*'
      Access-Control-Allow-Methods:
      - '*'
      Access-Control-Allow-Origin:
      - ''
      Access-Control-Expose-Headers:
      - '*'
      Access-Control-Max-Age:
      - '600'
      Alt-Svc:
      - h3=":443"; ma=2592000,h3-29=":443"; ma=2592000
      Connection:
      - close
      Content-Length:
      - '55'
      Via:
      - 1.1 google
      content-type:
      - application/json
      date:
      - Thu, 19 Sep 2024 18:21:23 GMT
      server:
      - uvicorn
    status:
      code: 429
      message: Too Many Requests
- request:
    body: '{"max_tokens": 4000, "messages": [{"role": "user", "content": "Problem
      3: Luxury River Cruise [Josh Alman and Nathan Pinsker, 2013]\n\nFarmer John
      is taking Bessie and the cows on a cruise! They are sailing on a \nnetwork of
      rivers with N ports (1 <= N <= 1,000) labeled 1..N, and Bessie \nstarts at port
      1. Each port has exactly two rivers leading out of it which \nlead directly
      to other ports, and rivers can only be sailed one way.\n\nAt each port, the
      tour guides choose either the \"left\" river or the \"right\" \nriver to sail
      down next, but they keep repeating the same choices over and \nover. More specifically,
      the tour guides have chosen a short sequence of M \ndirections (1 <= M <= 500),
      each either \"left\" or \"right\", and have\nrepeated it K times (1 <= K <=
      1,000,000,000). Bessie thinks she is going\nin circles -- help her figure out
      where she ends up!\n\nPROBLEM NAME: cruise\n\nINPUT FORMAT:\n\n* Line 1: Three
      space-separated integers N, M, and K.\n\n* Lines 2..N+1: Line i+1 has two space-separated
      integers,\n        representing the number of the ports that port i''s left
      and\n        right rivers lead to, respectively.\n\n* Line N+2: M space-separated
      characters, either ''L'' or ''R''. ''L''\n        represents a choice of  ''left''
      and ''R'' represents a choice of\n        ''right''.\n\nSAMPLE INPUT:\n\n4 3
      3\n2 4\n3 1\n4 2\n1 3\nL L R\n\nINPUT DETAILS:\n\nThe port numbers are arranged
      clockwise in a circle, with ''L'' being a \nclockwise rotation and ''R'' being
      a counterclockwise rotation. The sequence \ntaken is LLRLLRLLR.\n\nOUTPUT FORMAT:\n\n*
      Line 1: A single integer giving the number of the port where\n        Bessie''s
      cruise ends.\n\nSAMPLE OUTPUT:\n\n4\n\nOUTPUT DETAILS:\n\nAfter the first iteration
      of the sequence of directions, Bessie is at port\n2 (1 -> 2 -> 3 -> 2); after
      the second, she is at port 3 (2 -> 3 -> 4 ->\n3), and at the end she is at port
      4 (3 -> 4 -> 1 -> 4).\n"}, {"role": "assistant", "content": [{"text": "<thinking>\nThis
      problem involves simulating movement through a network of ports based on a repeating
      sequence of left/right directions. The key aspects are:\n1. The network of ports
      is represented as a graph, where each port has a \"left\" and \"right\" outgoing
      edge to other ports. \n2. A sequence of M left/right directions is given, which
      is repeated K times.\n3. We need to determine the final port after following
      this repeated sequence starting from port 1.\n\nTo solve this, we can:\n1. Read
      in the port graph and store the left/right destinations for each port\n2. Simulate
      the movement:\n   - Maintain a current port\n   - For each direction in the
      sequence:\n     - If ''L'', move to the left port, else move to the right port\n   -
      Repeat the sequence K times in total\n3. Output the final port\n\nThe number
      of repetitions K can be very large (up to 1 billion), so we need to find a way
      to avoid simulating all K repetitions. \n\nOne optimization is to notice that
      if we ever visit the same port twice at the same point in the direction sequence,
      we have entered a cycle. We can fast-forward by calculating how many full cycles
      are left.\n\nSo an optimized approach would be:\n1. Simulate the first M * N
      steps, keeping track of the port and position in the sequence for each step\n2.
      If a cycle is detected (same port and sequence position seen before):\n   -
      Calculate remaining number of cycles\n   - Fast-forward to the same point in
      the last cycle\n3. Finish simulating any remaining steps\n4. Output the final
      port\n\nThe time complexity will be O(M * N) and space complexity O(M * N) to
      store the state at each step for cycle detection.\n</thinking>", "type": "text"},
      {"type": "tool_use", "name": "writePython", "input": {"reasoning": "We can simulate
      the movement of Bessie through the ports based on the repeating direction sequence.
      \n\nKey optimizations:\n1. Store the left/right port destinations in arrays
      for quick lookup during simulation\n2. Detect cycles by keeping track of previously
      seen (port, sequence position) states\n3. When a cycle is detected, fast-forward
      to near the end by skipping full cycles\n\nTime Complexity: O(M * N) \n- We
      simulate at most M * N steps before a cycle must be detected\n- Then we simulate
      at most M additional steps after fast-forwarding\nSpace Complexity: O(M * N)\n-
      We store M * N states to detect cycles\n\nSo this approach avoids simulating
      all K * M steps, while still arriving at the correct final port.", "pseudocode":
      "N, M, K = input number of ports, sequence length, num repetitions\nleft, right
      = input arrays where left[i]/right[i] is port left/right of port i\nsequence
      = input array of ''L''s and ''R''s\n\nport = 1\nseen = empty hash set\npath
      = empty array\n\nfor step from 1 to M * N:\n  seen.add((port, step % M))\n  path.append(port)\n  \n  if
      sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port = right[port]\n    \n  if
      (port, step % M) in seen:\n    cycle_start = index of (port, step % M) in path  \n    cycle_length
      = step - cycle_start\n    remaining_steps = K*M - step\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    break\n\nwhile
      step < K * M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)", "code": "N, M, K = map(int,
      input().split())\n\nleft = [0] * (N+1)\nright = [0] * (N+1)\nfor i in range(1,
      N+1):\n  left[i], right[i] = map(int, input().split())\n\nsequence = input().split()\n\nport
      = 1\nseen = set()\npath = []\n\nstep = 0\nwhile step < M*N:\n  seen.add((port,
      step % M))\n  path.append(port)\n\n  if sequence[step % M] == ''L'':\n    port
      = left[port]\n  else:\n    port = right[port]\n        \n  if (port, (step+1)
      % M) in seen:\n    cycle_start = path.index((port, (step+1) % M))\n    cycle_length
      = step + 1 - cycle_start\n    remaining_steps = K*M - (step+1)\n    remaining_cycles
      = remaining_steps // cycle_length\n    fast_forward = remaining_cycles * cycle_length\n    port
      = path[cycle_start + (remaining_steps - fast_forward) % cycle_length]\n    step
      = K*M - (remaining_steps - fast_forward) % cycle_length\n    break\n        \n  step
      += 1\n\nwhile step < K*M:\n  if sequence[step % M] == ''L'':\n    port = left[port]\n  else:\n    port
      = right[port]\n  step += 1\n    \nprint(port)"}, "id": "toolu_01TCbGzzL5B2sa5xFezRTVMJ"}]},
      {"role": "user", "content": [{"type": "tool_result", "content": "Incorrect submission.
      Please respond with updated code.\nPass rate: 0/10\nResults:\n<test id=0>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\n<test id=1>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (2, 4) is
      not in list\n\n</test>\n<test id=2>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (68, 13) is not in list\n\n</test>\n<test
      id=3>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (160, 22) is not in list\n\n</test>\n<test id=4>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (246, 17) is not in list\n\n</test>\n<test id=5>\nfailed: Traceback (most recent
      call last):\n  File \"<string>\", line 25, in <module>\nValueError: (413, 27)
      is not in list\n\n</test>\n<test id=6>\nfailed: Traceback (most recent call
      last):\n  File \"<string>\", line 25, in <module>\nValueError: (1, 0) is not
      in list\n\n</test>\n<test id=7>\nfailed: Traceback (most recent call last):\n  File
      \"<string>\", line 25, in <module>\nValueError: (779, 406) is not in list\n\n</test>\n<test
      id=8>\nfailed: Traceback (most recent call last):\n  File \"<string>\", line
      25, in <module>\nValueError: (616, 171) is not in list\n\n</test>\n<test id=9>\nfailed:
      Traceback (most recent call last):\n  File \"<string>\", line 25, in <module>\nValueError:
      (1, 0) is not in list\n\n</test>\nMake all fixes using the writePython tool.",
      "tool_use_id": "toolu_01TCbGzzL5B2sa5xFezRTVMJ", "is_error": false}, {"type":
      "text", "text": "Consider breaking down the algorithm into separate parts: reading
      inputs, detecting cycles using the tortoise and hare algorithm, and determining
      Bessie''s final position by skipping ahead K steps.\n    \n    Read the inputs
      into three arrays:\n    - Two arrays L and R for the ports (adjust for 0-based
      indexing)\n    - A third array S for the direction sequence\n    \n    Optimize
      by multiplying K by M before the main loop to convert the number of repetitions
      into the total number of steps.\n    \n    Use the tortoise and hare algorithm
      to detect the cycle:\n    - Define a helper function get_next(v) that returns
      the next position and direction index\n    - Initialize two pointers s0 and
      s1 to (0, 0)\n    - In each iteration:\n      - Move s0 by 1 step and s1 by
      2 steps using get_next()\n      - If s0 equals s1, decrement K by 1 and break
      out of the loop\n      - Otherwise, decrement K by 1\n    - After the loop,
      if K is not 0, there is a cycle\n    \n    To find the cycle length:\n    -
      Initialize a counter variable rho to 1\n    - Move s0 by 1 step using get_next()\n    -
      Enter a loop:\n      - Move s0 by 1 step using get_next()\n      - Increment
      rho\n      - If s0 equals s1, break out of the loop\n    \n    Skip ahead by
      reducing K modulo rho.\n    \n    Simulate the remaining steps:\n    - While
      K > 0, move s0 to the next position using get_next() and decrement K\n    \n    Print
      the final position (converted to 1-based indexing).\n    \n    Pay close attention
      to the initialization and movement of pointers during cycle detection and length
      calculation. Ensure that the logic is correct and handles all cases accurately."}]}],
      "model": "claude-3-opus-20240229", "system": "You are a world-class competitive
      programmer.\nPlease reply with a Python 3 solution to the problem below. \nFirst,
      reason through the problem and conceptualize a solution.\nThen write detailed
      pseudocode to uncover any potential logical errors or omissions.\nFinally output
      the working Python code for your solution, ensuring to fix any errors uncovered
      while writing pseudocode.\n\nNo outside libraries are allowed.\n    You previously
      solved the following problems in this competition:\n    <Examples>\n    <problem>\n    Farmer
      John has $N$ ($1 \\le {N} \\le {10^5}$) cows, the breed of each being\neither
      a Guernsey or a Holstein. They have lined up horizontally with the cows occupying
      positions \nlabeled from\n$1\\dots N$.\n\nSince all the cows are hungry, FJ
      decides to plant grassy patches on some\nof the positions $1\\dots N$. Guernseys
      and Holsteins prefer different types of\ngrass, so if Farmer John decides to
      plant grass at some location, he must choose\nto planting either Guernsey-preferred
      grass or Holstein-preferred grass --- he\ncannot plant both at the same location.
      Each patch of grass planted can feed an\nunlimited number of cows of the appropriate
      breed. \n\nEach cow is willing to move a maximum of $K$ ($0 \\le {K} \\le N-1$)
      positions to\nreach a patch. Find the minimum number of patches needed to feed
      all the cows.\nAlso, print a configuration of patches that uses the minimum
      amount of patches\nneeded to feed the cows. Any configuration that satisfies
      the above conditions\nwill be considered correct.\n\nINPUT FORMAT (input arrives
      from the terminal / stdin):\nEach input contains $T$ test cases, each describing
      an arrangement of cows. The\nfirst line of input contains $T$ ($1 \\le T \\le
      10$). Each of the $T$ test cases\nfollow.\n\nEach test case starts with a line
      containing $N$ and $K$. The next line will\ncontain a string of length $N$,
      where each character denotes the breed of the\n$i$th cow (G meaning Guernsey
      and H meaning Holstein).\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor
      each of the $T$ test cases, please write two lines of output. For the first\nline,
      print the minimum number of patches needed to feed the cows. For the\nsecond
      line, print a string of length $N$ that describes a configuration  that\nfeeds
      all the cows with the minimum number of patches. The $i$th character,\ndescribing
      the $i$th position, should be a ''.'' if there is no patch, a ''G'' if\nthere
      is a patch that feeds Guernseys, and a ''H'' if it feeds Holsteins. Any\nvalid
      configuration will be accepted.\n\nSAMPLE INPUT:\n6\n5 0\nGHHGG\n5 1\nGHHGG\n5
      2\nGHHGG\n5 3\nGHHGG\n5 4\nGHHGG\n2 1\nGH\nSAMPLE OUTPUT: \n5\nGHHGG\n3\n.GH.G\n2\n..GH.\n2\n...GH\n2\n...HG\n2\nHG\n\nNote
      that for some test cases, there are multiple acceptable configurations that\nmanage
      to feed all cows while using the minimum number of patches. For example,\nin
      the fourth test case, another acceptable answer would be:\n\n\n.GH..\n\nThis
      corresponds to placing a patch feeding Guernseys on the 2nd position and a\npatch
      feeding Holsteins on the third position. This uses the optimal number of\npatches
      and ensures that all cows are within 3 positions of a patch they prefer.\n\n\n\nSCORING:\nInputs
      2 through 4 have $N \\le 10$. Inputs 5 through 8 have $N \\le 40$. Inputs 9
      through 12 have $N \\le 10^5$. \n\n\nProblem credits: Mythreya Dharani\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Mythreya Dharani)\nLet''s start by defining a cow as covered if there is
      a patch feeding its\nbreed within a distance of $K$. The problem is asking us
      to cover all cows with\nthe minimum number of patches.\nConsider each cow $i$
      from $1 \\dots N$ in that order, placing patches whenever\nnecessary. First
      of all, if the current cow is already covered,  then we don''t\nneed to place
      another patch, and we can just move on. Otherwise, we need to\nplace a new patch
      for this cow, so where would we place it? Consider what\nhappens if we place
      the patch at position $i + K$. Not only will cow $i$ be\ncovered but any cows
      after it which are within $K$ distance of that patch will\nalso be covered.
      In fact, placing it at this location maximizes the number of\npotential cows
      that can be covered. \nThus, we can just implement this strategy starting at
      cow $1$. Keep in mind that\nif there is a cow $i$ which needs to be fed and
      $i + K > N$, we can just place\nour new patch at position $i$ since all remaining
      same-breed cows can feed off\nthat patch. This solution runs in $O(N)$ time
      since we are just doing a single\npass over the $N$ cows.\nThere is actually
      one edge case; what if when we try to place a patch at\nposition $i$ but there
      is already a patch there? In this case, we can place the\npatch at $i-1$ instead,
      as it may be proven that there can''t already be patches\nat both $i-1$ and
      $i$. As $i-1+K\\ge N$, this patch covers all cows from $i$ to\n$N$ of the same
      breed as cow $i$.\nMythreya Dharani''s C++ code:\n\n#include <bits/stdc++.h>\nusing
      namespace std;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint
      T;\n\tcin >> T;\n\n\twhile (T--) {\n\t\tint n;\n\t\tint k;\n\t\tcin >> n >>
      k;\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tint patchG = -k - 1; // first patch
      location which does not cover cow 1\n\t\tint patchH = -k - 1; // first patch
      location which does not cover cow 1\n\n\t\tint cnt = 0;\n\t\tstring ans(n, ''.'');\n\n\t\tfor
      (int i = 0; i < n; i++) {\n\t\t\tif (s[i] == ''G'' && i - patchG > k) {\n\t\t\t\t//
      the nearest G patch we placed does not cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif
      (i + k >= n) {\n\t\t\t\t\tpatchG = i;\n\t\t\t\t\tif (ans[patchG] == ''H'') {
      patchG--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchG = i + k; // place the G patch
      k away\n\t\t\t\t}\n\t\t\t\tans[patchG] = ''G'';\n\t\t\t}\n\t\t\tif (s[i] ==
      ''H'' && i - patchH > k) {\n\t\t\t\t// the nearest H patch we placed does not
      cover cow i\n\t\t\t\t++cnt;\n\t\t\t\tif (i + k >= n) {\n\t\t\t\t\tpatchH = i;\n\t\t\t\t\tif
      (ans[patchH] == ''G'') { patchH--; }\n\t\t\t\t} else {\n\t\t\t\t\tpatchH = i
      + k; // place the H patch k away\n\t\t\t\t}\n\t\t\t\tans[patchH] = ''H'';\n\t\t\t}\n\t\t}\n\t\tcout
      << cnt << endl << ans << endl;\n\t}\n}\n\nDanny Mittal''s Java code:\n\nimport
      java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport
      java.util.StringTokenizer;\n \npublic class FeedingTheCows {\n \n    public
      static void main(String[] args) throws IOException {\n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        for (int
      t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer
      tokenizer = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      k = Integer.parseInt(tokenizer.nextToken());\n            char[] cows = in.readLine().toCharArray();\n            int
      lastGuernseyPatch = -k - 1;\n            int lastHolsteinPatch = -k - 1;\n            char[]
      answer = new char[n];\n            for (int j = 0; j < n; j++) {\n                answer[j]
      = ''.'';\n            }\n            int amtPatches = 0;\n            for (int
      j = k; j < n; j++) {\n                if (cows[j - k] == ''G'') {\n                    if
      ((j - k) - lastGuernseyPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        lastGuernseyPatch = j;\n                    }\n                }
      else {\n                    if ((j - k) - lastHolsteinPatch > k) {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        lastHolsteinPatch = j;\n                    }\n                }\n            }\n            boolean
      gNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''G'' && j - lastGuernseyPatch > k) {\n                    gNeeds
      = true;\n                }\n            }\n            if (gNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''G'';\n                        break;\n                    }\n                }\n            }\n            boolean
      hNeeds = false;\n            for (int j = n - 1; j >= 0; j--) {\n                if
      (cows[j] == ''H'' && j - lastHolsteinPatch > k) {\n                    hNeeds
      = true;\n                }\n            }\n            if (hNeeds) {\n                for
      (int j = n - 1; j >= 0; j--) {\n                    if (answer[j] == ''.'')
      {\n                        amtPatches++;\n                        answer[j]
      = ''H'';\n                        break;\n                    }\n                }\n            }\n            System.out.println(amtPatches);\n            System.out.println(answer);\n        }\n    }\n}\n\nNick
      Wu''s Python code:\n\ndef solve():\n    n, k = (int(x) for x in input().split())\n    patches
      = [''.''] * n\n    gCover = -1\n    hCover = -1\n    s = input()\n    for idx,
      ch in enumerate(s):\n        if ch == ''G'' and gCover < idx:\n            if
      idx + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''G''\n                else:\n                    patches[idx] = ''G''\n                gCover
      = n\n            else:\n                patches[idx+k] = ''G''\n                gCover
      = idx + 2*k\n        elif ch == ''H'' and hCover < idx:\n            if idx
      + k >= len(patches):\n                if patches[idx] != ''.'':\n                    patches[idx-1]
      = ''H''\n                else:\n                    patches[idx] = ''H''\n                hCover
      = idx + k\n            else:\n                patches[idx+k] = ''H''\n                hCover
      = idx + 2*k\n    print(n - patches.count(''.''))\n    print(\"\".join(patches))\n
      \nt = int(input())\nfor _ in range(t): solve()\n\n\n    </solution>\n<problem>\n    \nBessie
      is taking a vacation in a network of $N$ ($2\\le N\\le 10^4$) islands\nlabeled
      $1\\dots N$ connected by $M$ bidirectional bridges, each of which\nconnects
      two islands ($N-1\\le M\\le 3/2(N-1)$). It is guaranteed that the bridges\nform
      a connected simple graph (in particular, no two bridges connect the same\npair
      of islands, and no bridge connects an island to itself).\n\nIt is also guaranteed
      that no bridge lies on more than one simple cycle. A\nsimple cycle is a cycle
      that does not contain repeated islands.\n\nBessie starts at island $1$, and
      travels according to the following procedure.\nSupposing she is currently at
      island $i$,\n\nIf there are no bridges adjacent to island $i$ that she has not
      yet crossed,\nshe ends her vacation.Otherwise, with probability $p_i\\pmod{10^9+7}$,
      she ends her vacation.Otherwise, out of all bridges adjacent to island $i$ that
      she has not yet\ncrossed, she chooses one uniformly at random and crosses it.\nFor
      each island, output the probability that she ends her vacation at that\nisland,
      modulo $10^9+7$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe
      first line contains the number of independent test cases $T$\n($1\\le T\\le
      10$). Consecutive test cases are separated by an empty line.\n\nThe first line
      of each test contains $N$ and $M$, where $N$ is the number of\nislands and $M$
      is the number of bridges. It is guaranteed that the sum of $N$\nover all test
      cases does not exceed $10^4$.\n\nThe second line of each test contains $p_1,
      p_2,\\dots, p_N$ ($0\\le p_i<10^9+7$).\n\nThe next $M$ lines of each test describe
      the bridges. The $i$th line contains\nintegers $u_i$ and $v_i$ ($1\\le u_i<v_i\\le
      N$), meaning that the $i$th  bridge\nconnects islands $u_i$ and $v_i$. It is
      guaranteed that the bridges satisfy the\nconstraints mentioned above.\n\nOUTPUT
      FORMAT (print output to the terminal / stdout):\nFor each test case, output
      the probability of ending at each island from $1$ to\n$N$ modulo $10^9+7$ on
      a single line, separated by spaces.\n\nSAMPLE INPUT:\n2\n\n3 2\n0 10 111111112\n1
      3\n2 3\n\n6 5\n500000004 0 0 0 0 0\n1 5\n1 3\n4 5\n5 6\n1 2\nSAMPLE OUTPUT:
      \n0 888888896 111111112\n500000004 166666668 166666668 83333334 0 83333334\n\nFor
      the first test case, $p_3\\equiv 1/9 \\pmod{10^9+7}$. Bessie has  probability\n$1/9$
      of ending at $3$ (taking the path $1\\to 3$) and $8/9$  of ending at $2$\n(taking
      the path $1\\to 3\\to 2$).\n\nFor the second test case, $p_1\\equiv 1/2\\pmod{10^9+7}$.
      Bessie has probability \n$1/2$ of ending at $1$,  $1/6$ of ending at each of
      $2$ or $3$, and $1/12$  of\nending at each of $4$ or $6$.\n\nSAMPLE INPUT:\n2\n\n5
      5\n333333336 333333336 0 0 0\n1 2\n2 3\n3 4\n4 5\n1 5\n\n5 5\n0 0 0 0 0\n1 2\n2
      3\n2 4\n1 4\n1 5\nSAMPLE OUTPUT: \n777777784 222222224 0 0 0\n0 0 333333336
      0 666666672\n\nFor the first test case, $p_1\\equiv p_2\\equiv 1/3\\pmod{10^9+7}$.  Bessie
      has\nprobability $7/9$ of ending at $1$ (taking one of the paths $1$,\n$1\\to
      2\\to 3\\to 4\\to 5\\to 1$, or $1\\to 5\\to 4\\to 3\\to 2\\to 1$) and $2/9$
      of\nending at $2$.\n\nFor the second test case, Bessie has probability $1/3$
      of ending at $3$, and\n$2/3$ of ending at $5$.\n\nSAMPLE INPUT:\n1\n\n11 13\n2
      3 4 5 6 7 8 9 10 11 12\n1 2\n1 3\n2 3\n2 4\n4 5\n2 5\n4 8\n5 9\n2 6\n6 7\n2
      7\n6 10\n5 11\nSAMPLE OUTPUT: \n133332478 200000394 577778352 999999971 399999938
      933333282 355555536 800000020 18 600000029 18\n\nSCORING:\nInputs 4-5: $N\\le
      11$Inputs 6-7: There are no simple cycles.Inputs 8-11: No island lies on more
      than one simple cycle.Inputs 12-15: No island lies on more than $5$ simple cycles.Inputs
      16-19: No island lies on more than $50$ simple cycles.Inputs 20-23: No additional
      constraints.\n\n\nProblem credits: Benjamin Qi\n\n    </problem>\n    <solution>\n    \n(Analysis
      by Rain Jiang, Benjamin Qi)\nRestating the problem:\nYou are given an undirected
      graph, such that each edge belongs to at most one\nsimple cycle. Such a graph
      is called a\ncactus.\nYou start walking at vertex $1$. Every time you are at
      any vertex $i$, do the\nfollowing:\nWith a probability of $p_i$, end the walk.Otherwise,
      if there are no untraversed edges adjacent to $i$, end the\nwalk.Otherwise,
      choose an untraversed edge adjacent to $i$ uniformly randomly,\nand traverse
      it.\nFor all vertices $i$, you want to find the probability that you end your
      walk at\n$i$. Let''s call this probability $ans_i$.\nLet $d_i$ be $\\deg(i)$
      if $i=1$, and $\\deg(i)-1$ otherwise.\nLet $K$ be the maximum number of cycles
      that any vertex belongs to.\nSubtask 1: $N \\le 11$.\nFrom $N \\le 11$, we can
      see that\n$M \\le \\frac{3}{2} (N - 1) \\le \\frac{3}{2} \\cdot 10 = 15$.\nWith
      these bounds, an $O(2^M \\cdot M)$ DP is sufficient.\nLet $dp_{i, E}$ be the
      probability that you reach a state where you''re at vertex\n$i$, and the set
      of untraversed edges is $E$.\nLet''s see how to transition from $dp_{i, E}$
      to other states.\nLet $E''$ be the set of edges in $E$ adjacent to $i$.\nIf
      $E''$ is empty, we add $dp_{i, E}$ to $ans_i$.\nOtherwise, we add $dp_{i, E}
      \\cdot p_i$ to $ans_i$. Also, for each edge\n$e = \\{i, j\\} \\in E''$ adjacent
      to $i$, we add\n$dp_{i, E} \\cdot (1 - p_i) \\cdot \\frac{1}{|E''|}$ to\n$dp_{j,
      E \\setminus \\{e\\}}$,\nBecause the time spent on transitions from any $dp_{i,
      E}$ is $O(\\deg(i))$, and\nthe sum of $\\deg(i)$ is $O(M)$, the total time taken
      for this DP is\n$O(2^M \\cdot M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t11\n#define M\t((N - 1) * 3 /
      2)\n#define MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n
      \n\tvv[1] = 1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD
      % i] * (MD / i + 1) % MD;\n}\n \nint ii[M], jj[M], m;\nint *eh[N], eo[N], n;\n
      \nvoid append(int i, int h) {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o
      - 1) == 0)\n\t\teh[i] = (int *) realloc(eh[i], o * 2 * sizeof *eh[i]);\n\teh[i][o]
      = h;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tstatic int xx[N], ans[N], dp[1 << M][M];\n\t\tint h, i, j, b, b_,
      o, d, x;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n > N)\n\t\t\treturn 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\teh[i]
      = (int *) malloc(2 * sizeof *eh[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tii[h] = i, jj[h] = j;\n\t\t\tappend(i,
      h), append(j, h);\n\t\t}\n\t\tfor (b = 0; b < 1 << m; b++)\n\t\t\tmemset(dp[b],
      0, n * sizeof *dp[b]);\n\t\tmemset(ans, 0, n * sizeof *ans);\n\t\tdp[(1 << m)
      - 1][0] = 1;\n\t\tfor (b = (1 << m) - 1; b >= 0; b--)\n\t\t\tfor (i = 0; i <
      n; i++) {\n\t\t\t\tx = dp[b][i];\n\t\t\t\tif (x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\td
      = 0;\n\t\t\t\tfor (o = eo[i]; o--; ) {\n\t\t\t\t\th = eh[i][o];\n\t\t\t\t\tif
      ((b & 1 << h) != 0)\n\t\t\t\t\t\td++;\n\t\t\t\t}\n\t\t\t\tif (d == 0)\n\t\t\t\t\tans[i]
      = (ans[i] + x) % MD;\n\t\t\t\telse {\n\t\t\t\t\tans[i] = (ans[i] + (long long)
      x * xx[i]) % MD;\n\t\t\t\t\tx = (long long) x * (1 - xx[i] + MD) % MD * vv[d]
      % MD;\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\t\t\th = eh[i][o];\n\t\t\t\t\t\tif ((b & 1 << h) != 0) {\n\t\t\t\t\t\t\tb_
      = b ^ 1 << h, j = i ^ ii[h] ^ jj[h];\n\t\t\t\t\t\t\tdp[b_][j] = (dp[b_][j] +
      x) % MD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (i = 0; i
      < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(eh[i]);\n\t}\n\treturn 0;\n}\n\nSubtask 2: $K
      = 0$.\nThe graph is a tree. Let''s root the tree at vertex $1$.\nNotice that
      you travel along a path from the root, and only move deeper and\ndeeper. Let
      $pVisit_i$ be the probability that you reach $i$ from the root. Then\n$ans_i$
      is equal to $pVisit_i \\cdot p_i$ (or just $pVisit_i$ if $i$ is a leaf.)\nFor
      each child $j$ of $i$,\n$pVisit_j = pVisit_i \\cdot (1 - p_i) \\cdot \\frac{1}{d_i}$.
      We can compute\n$pVisit$ using a DFS from vertex $1$.\nTime complexity: $O(M)$.\nRain''s
      code:\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint
      o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i],
      o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint xx[N], ans[N];\n \nvoid dfs(int p, int i, int w) {\n\tint o;\n \n\tif
      (p != -1)\n\t\tdetach(i, p);\n\tif (eo[i] == 0)\n\t\tans[i] = w;\n\telse {\n\t\tans[i]
      = (long long) w * xx[i] % MD;\n\t\tw = (long long) w * (1 - xx[i] + MD) % MD
      * vv[eo[i]] % MD;\n\t\tfor (o = eo[i]; o--; ) {\n\t\t\tint j = ej[i][o];\n \n\t\t\tdfs(i,
      j, w);\n\t\t}\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tdfs(-1,
      0, 1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 <
      n ? '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nNote: The first and second subtasks can also be solved by enumerating
      all\nof Bessie''s possible walks. The number of walks is bounded above by\n$N\\cdot
      3^{(\\#\\text{ simple cycles})}\\cdot \\prod_{1\\le i\\le N}(\\#\\text{ simple
      cycles adjacent to }i)!$\nbecause if we:\nFix Bessie''s ending vertex (choices:
      $N$)For each simple cycle, decide which direction to traverse it in, or not\ntraverse
      it at all (choices: $3^{(\\#\\text{ simple cycles})}$)For each vertex, decide
      in what order we will traverse the simple cycles\nadjacent to it (choices:\n$\\prod_{1\\le
      i\\le N}(\\#\\text{ simple cycles adjacent to }i)!$).\nthen Bessie''s walk is
      uniquely determined. For $N\\le 11$, the number of simple\ncycles is at most  $(N-1)/2\\le
      5$, so the total number of walks cannot be very\nlarge.\nSubtask 3: $K \\le
      1$.\nThe graph is a vertex-disjoint cactus. We need to modify the algorithm
      from\nSubtask 2 to handle cycles.\nAgain, root the cactus at vertex $1$, and
      consider the\nDFS tree of this cactus. Since we\ndid DFS, each cycle can be
      represented as path from a vertex to one of its\ndescendants, plus the corresponding
      back edge. Let''s call this highest vertex\nthe top vertex of the cycle.\nYou
      can see that the path generally moves downward, with occasional roundabouts\nalong
      cycles.\nSimilar to Subtask 2, let $pVisit_i$ be the probability that you reach
      vertex\n$i$ from the root.\nThe transitions using a non-cycle edge can be handled
      similar to Subtask 2.\nLet''s see how to transition using cycle edges. Let $i$
      be the top vertex of\ncycle $C$.\nWe describe how to transition from $i$ to
      another vertex $j$ on cycle $C$. We\ncan see that $pVisit_j$ is the sum of the
      two probabilities of going from $i$ to\n$j$, by choosing one of two paths going
      from $i$ to $j$ along $C$. The\nprobability of traversing one such path is the
      product of $pVisit_i$ and\n$(1 - p_u) \\cdot \\frac{1}{d_u}$ for all vertices
      $u$ along that path.\nYou should also handle the special case of traversing
      the whole cycle $C$ and\nvisiting $i$ a second time. The probability of this
      occurring is similar to the\nabove. After we traverse $C$, there are no more
      cycle edges adjacent to $i$, so\nwe are forced to either stop at $i$ or traverse
      an adjacent non-cycle edge.\nWe can do this using a DFS from vertex $1$. We
      process each cycle $C$ by going\nthrough it twice, once in each direction, taking
      $O(|C|)$ time.\nTime complexity: $O(M)$.\nRain''s code:\n\n#include <stdio.h>\n#include
      <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define MD\t1000000007\n
      \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] = 1;\n\tfor (i = 2;
      i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD / i + 1) % MD;\n}\n
      \nint xx[N], *ej[N], eo[N], n;\n \nvoid append(int i, int j) {\n\tint o = eo[i]++;\n
      \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int *) realloc(ej[i], o *
      2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int i, int j) {\n\tint
      o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n \nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n \n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n \n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n \nint ww[N], ans[N];\n \nvoid dfs2(int i, int
      cycle) {\n\tint o, d, j, j_, k, w, w_;\n \n\tj_ = -1;\n\tfor (o = eo[i]; o--;
      ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] != i) {\n\t\t\tj_ = j, cycle = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\td
      = eo[i] + (cycle ? 1 : 0);\n\tif (d == 0) {\n\t\tans[i] = ww[i];\n\t\treturn;\n\t}\n\tans[i]
      = (long long) ww[i] * xx[i] % MD;\n\tw = (long long) ww[i] * (1 - xx[i] + MD)
      % MD * vv[d] % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j
      != j_)\n\t\t\tww[j] = (ww[j] + w) % MD;\n\t}\n\tif (j_ != -1) {\n\t\tw_ = w;\n\t\tfor
      (k = j_; k != i; k = pp[k]) {\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_ =
      (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t}\n\t\tw_
      = w, k = j_;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tww[k] = (ww[k] + w_) % MD;\n\t\t\tw_
      = (long long) w_ * (1 - xx[k] + MD) % MD * vv[eo[k] + 1] % MD;\n\t\t} while
      (k != j_);\n\t\tw = w_ * 2 % MD, d -= 2;\n\t\tif (d == 0)\n\t\t\tans[i] = (ans[i]
      + w) % MD;\n\t\telse {\n\t\t\tans[i] = (ans[i] + (long long) w * xx[i]) % MD;\n\t\t\tw
      = (long long) w * (1 - xx[i] + MD) % MD * vv[d] % MD;\n\t\t\tfor (o = eo[i];
      o--; ) {\n\t\t\t\tj = ej[i][o];\n\t\t\t\tif (j != j_)\n\t\t\t\t\tww[j] = (ww[j]
      + w) % MD;\n\t\t\t}\n\t\t}\n\t\tfor (k = j_; k != i; k = pp[k])\n\t\t\tdfs2(k,
      1);\n\t}\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (j != j_)\n\t\t\tdfs2(j,
      0);\n\t}\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile
      (t--) {\n\t\tint m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i =
      0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tej[i]
      = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor (h = 0; h < m; h++)
      {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd,
      0, n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0,
      1);\n\t\tmemset(ww, 0, n * sizeof *ww);\n\t\tww[0] = 1, dfs2(0, 0);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nSubtasks 4,
      5, 6\nAs in earlier subtasks, root the cactus at vertex $1$ and consider the
      DFS tree\nof it.\nHowever, the path is more complex: it can go down the tree
      for quite a while,\nbut eventually retrace and traverse another path.\nLet''s
      define a few terms. Fix vertex $i$. Consider the edge $f$ from $i$ to its\nparent.
      By the assumption that the graph is a cactus, $f$ must either be a\nbridge or
      is\ncontained in a (unique) cycle $C$. (From now on, when we say \"bridge\",
      we mean\nit in the graph theory sense.) If $f$ is a bridge, then call $pb_i=f$
      the\nparent bridge of $i$. Otherwise, call $pc_i=C$ the parent cycle of\n$i$.\nIn
      any case, let the predecessor of vertex $i$ be either its parent (if\n$f$ is
      a bridge) or the top vertex of $pc_i$ (if $f$ isn''t a bridge.)\nSymmetrically,
      $i$ is a successor of its predecessor.\nAlso, let the subcactus of $i$ be the
      connected subgraph containing $i$\nobtained by deleting $pb_i$ or all edges
      of $pc_i$. Let $T_i$ be the subcactus\nof $i$.\nLet''s observe what edges adjacent
      to vertex $i$ are untraversed when we visit\n$i$ for the first time. Consider
      two cases (recall that $f$ is the edge from $i$\nto its parent):\n\n$f$ is a
      bridge. If $i \\neq 1$, the only way to visit $i$ is through\n$pb_i$. We cannot
      use $pb_i$ twice, so we must stay in $T_i$ from now on.\n\n$f$ is not a bridge.
      We must enter $i$ via one of two adjacent edges in\n$pc_i$. In either case,
      all untraversed edges from $i$ are in $T_i$, except the\nother cycle edge. Indeed,
      this edge is the only edge that can be used to escape\n$T_i$, and once we use
      it, we can never go back to any vertex in $T_i$. We refer\nto this edge as the
      \"escape edge\" of $i$.\n\nThis motivates us to compute the following two DPs:\n$pEscape_i$
      -- the probability that, starting from $i$, we eventually use the\n\"escape
      edge\" from $i$ (For convenience later, let $pEscape_i = 0$ if there is\nno
      such \"escape edge\".)\n$qVisit_{i, j}$ -- the probability that, starting from
      $i$, we visit one of its\nsuccessors $j$.\nIf we have these two DPs, we can
      compute the answer using a DFS from vertex $1$\nas follows.\nSuppose the DFS
      reaches $i$. Let $pVisit_i$ be defined similar to Subtasks 2 and\n3.\nFor a
      successor $j$ of $i$, set $pVisit_j = pVisit_i \\cdot qVisit_{i, j}$, and\nrecurse
      on $j$.\nFinally, let''s compute $ans_i$. You end up at vertex $i$ if you visit
      vertex\n$i$, and you don''t do either of the following:\n\nUse the \"escape
      edge\" from $i$.\n\nEventually reach a successor $j$, and never escape from
      its subcactus.\n\nSince all bad cases above are mutually exclusive, we have\n$$\nans_i
      = pVisit_i \\cdot \\left(1 - pEscape_i - \\sum_{j\\:\\textrm{is a successor
      of}\\:i} qVisit_{i, j} \\left(1 - pEscape_j\\right)\\right)\n$$\nSince each
      vertex has a unique predecessor, the time to compute $ans_i$ from\n$pEscape$
      and $qVisit$ is $O(M)$.\nLet''s compute $pEscape$ and $qVisit$ in a bottom-up
      fashion. Suppose we want to\ncompute them for $i$.\nLet $qEscape_C$ for a cycle
      $C$ with top vertex $i$ be equal to the product of\n$pEscape_j$ for all vertices
      $j \\in C$ excluding $i$. In other words, this is\nthe probability that you
      can complete one traversal of $C$ from $i$ and end up\nback at $i$. \nLet $CC$
      be the set of cycles that $i$ is the top vertex of.\nThere are two things we
      need to calculate:\n$pChoose_{bridge}$ -- The probability of eventually choosing
      a certain bridge\nadjacent to $i$ (or the \"escape edge\" of $i$).\n$pChoose_C$
      -- The probability of eventually choosing one of two edges adjacent\nto $i$
      on a cycle\n$C \\in CC$.\nUsing these, we can compute $pEscape_i$ and $qVisit_{i,
      j}$ as follows:\n\n$qVisit_{i, j}$ on bridges $\\{i, j\\}$ (and $pEscape_i$,
      if there is an \"escape\nedge\") are equal to $pChoose_{bridge}$.\n\nWe are
      left with computing $qVisit_{i, j}$ for all $j$ on a cycle $C \\in CC$.\nAny
      corresponding path must eventually select one of two edges adjacent to $i$\non
      $C$, and traverse the path from $i$ to $j$ along that edge. The probability\nof
      this happening is the product of $pChoose_C$ and $pEscape_{u}$ for all $u$\nalong
      this path. So $qVisit_{i, j}$ can be computed in a similar way as in\nSubtask
      3.\n\nThe next few paragraphs describe how to compute $pChoose_{bridge}$ and\n$pChoose_C$
      for $C \\in CC$ fast.\nLet''s consider $pChoose_{bridge}$. Any corresponding
      path can be described as a\ntraversal of some subset of cycles $C_0, C_1, ...,
      C_{k-1}$, in this order, plus\nthe extra edge.\nSo $pChoose_{bridge}$ is the
      sum of the following over all ordered subsets\n$C_0, C_1, ..., C_{k-1}$:\n$$\n\\left(\\prod_{h=0}^{k-1}
      \\left(1 - p_i\\right) \\cdot \\frac{2}{d_i-2h} \\cdot qEscape_{C_h}\\right)
      \\cdot \\left(1 - p_i\\right) \\cdot \\frac{1}{d_i-2k}\n$$\nAlso, the above
      term doesn''t change if we permute $C_0, C_1, ..., C_{k-1}$, so\nlet''s instead
      sum over all subsets $S \\subseteq CC$:\n$$\npChoose_{bridge} = \\sum_{S \\subseteq
      CC} \\left(k! \\cdot \\left(1 - p_i\\right)^{k+1} \\cdot 2^k \\cdot \\left(\\prod_{h=0}^{k}
      \\frac{1}{d_i-2h}\\right) \\cdot \\prod_{C \\in S} qEscape_{C}\\right)\n$$\n$pChoose_C$
      for $C \\in CC$ can be calculated in the same way, except that in the\nabove
      formula we use $CC \\setminus \\{C\\}$ instead of $CC$.\nCalculating the above
      sums straightforwardly takes $O(2^K \\cdot K^2)$ time, and\nthis passes Subtask
      4 where $K \\le 5$.\nLet''s make it faster. Note that the terms with the same
      $k$ in the above formula\nhave a common factor, namely\n$w_k = k! \\cdot (1
      - p_i)^{k+1} \\cdot 2^k \\cdot (\\prod_{h=0}^{k} \\frac{1}{d_i-2h})$.\nFactoring
      this out, it suffices to compute the sum of\n$\\prod_{C \\in S} qEscape_{C}$
      for all subsets $S \\in CC$ of size $k$.\nWe can do this using generating functions.
      Consider the generating function\n$$\nF(x) = \\prod_{C \\in CC} \\left(1 + qEscape_C
      x\\right)\n$$\nOnce we get this generating function, we add $w_k \\cdot F(x)
      [x^k]$ for all $k$\nto get $pChoose_{bridge}$. We can calculate $pChoose_C$
      for $C \\in CC$\nsimilarly, except that we use $CC \\setminus \\{C\\}$ instead
      of $CC$.\nThe generating function has degree $K$, so multiplying $(1 + qEscape_C
      x)$ takes\n$O(K)$ time. Thus it takes $O(K^2)$ time to calculate $F(x)$, and
      doing this for\nall $O(K)$ probabilities takes $O(K^3)$.\nThe sum of $K$ is
      $O(N)$, so the sum of $K^3$ for the above solution is\n$O(N \\cdot K^2)$. This
      is enough to pass subtask 5, where $K \\le 50$.\nRain''s code for Subtask 5:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, h_, j, k, o, cntb, cntc, c, d, y,
      y_, z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h_
      = 0; h_ < cntc; h_++) {\n\t\tmemset(dp, 0, (cntc + 1) * sizeof *dp), dp[0] =
      1;\n\t\tfor (h = 0; h < cntc; h++)\n\t\t\tif (h != h_) {\n\t\t\t\tz = zz_[h];\n\t\t\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] *
      z) % MD;\n\t\t\t}\n\t\ty = 0;\n\t\tfor (c = 0; c <= cntc; c++)\n\t\t\ty = (y
      + (long long) dp[c] * ww[c]) % MD;\n\t\tj = jj[h_];\n\t\ty_ = y;\n\t\tfor (k
      = j; k != i; k = pp[k])\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_
      * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo {\n\t\t\tk = qq[k];\n\t\t\tyy[k] =
      (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n
      \nint ans[N];\n \nvoid dfs3(int i, int w) {\n\tint j, k, o, x;\n \n\tx = (1
      - zz[i] + MD) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j]
      == i) {\n\t\t\tdfs3(j, (long long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] +
      MD) % MD;\n\t\t} else\n\t\t\tfor (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k,
      (long long) w * yy[k] % MD);\n\t\t\t\tx = (x - (long long) yy[k] * (1 - zz[k]
      + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i] = (long long) w * x % MD;\n}\n
      \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\", &t);\n\twhile (t--)
      {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (i = 0;
      i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i] = 0;\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 - xx[i] + MD) %
      MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\t\tappend(i,
      j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0, n * sizeof *dd), memset(marked,
      0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy, 0, n * sizeof *yy),
      memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0, 1);\n\t\tfor (i
      = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ? '' '' : ''\\n'');\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn 0;\n}\n\nFor full credit,
      we need to compute $pChoose_{bridge}$ and $pChoose_C$ in\n$O(K^2)$ time.\nNotice
      that the generating function we calculate for $pChoose_C$ is almost the\nsame
      as the one for $pChoose_{bridge}$, but is missing a factor of\n$(1 + qEscape_C
      x)$. This factor can be removed in $O(K)$ time (To divide such a\npolynomial,
      we perform steps backward as when we multiply.)\nIn summary, we spend $O(K)$
      divisions and multiplications, $O(K)$ time for\ncomputing $O(K)$ probabilities
      from the generating function, so in total we\nspend $O(K^2)$ time to compute
      $pChoose_{bridge}$ and $pChoose_C$.\nSumming $K^2$ over all vertices $i$, we
      get a time of $O(N^2)$, which gets full\ncredit.\nA full solution by Rain:\n\n#include
      <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define N\t10000\n#define
      MD\t1000000007\n \nint vv[N + 1];\n \nvoid init() {\n\tint i;\n \n\tvv[1] =
      1;\n\tfor (i = 2; i <= N; i++)\n\t\tvv[i] = (long long) vv[i - MD % i] * (MD
      / i + 1) % MD;\n}\n \nint xx[N], *ej[N], eo[N];\n \nvoid append(int i, int j)
      {\n\tint o = eo[i]++;\n \n\tif (o >= 2 && (o & o - 1) == 0)\n\t\tej[i] = (int
      *) realloc(ej[i], o * 2 * sizeof *ej[i]);\n\tej[i][o] = j;\n}\n \nvoid detach(int
      i, int j) {\n\tint o;\n \n\tfor (o = eo[i]; o--; )\n\t\tif (ej[i][o] == j) {\n\t\t\teo[i]--;\n\t\t\twhile
      (o < eo[i])\n\t\t\t\tej[i][o] = ej[i][o + 1], o++;\n\t\t\treturn;\n\t\t}\n}\n
      \nint dd[N], pp[N], qq[N]; char marked[N];\n\nvoid dfs1(int p, int i, int d)
      {\n\tint o, o_;\n\n\tpp[i] = p, dd[i] = d;\n\tif (p != -1)\n\t\tdetach(i, p);\n\tfor
      (o = eo[i]; o--; ) {\n\t\tint j = ej[i][o], k;\n\n\t\tif (!dd[j])\n\t\t\tdfs1(i,
      j, d + 1);\n\t\telse if (dd[j] > dd[i]) {\n\t\t\tdetach(j, i);\n\t\t\tfor (k
      = j; pp[k] != i; k = pp[k])\n\t\t\t\tdetach(pp[k], k), qq[pp[k]] = k;\n\t\t\tmarked[k]
      = 1, qq[j] = k;\n\t\t}\n\t}\n\to_ = 0;\n\tfor (o = 0; o < eo[i]; o++) {\n\t\tint
      j = ej[i][o];\n\n\t\tif (!marked[j])\n\t\t\tej[i][o_++] = j;\n\t\telse\n\t\t\tmarked[j]
      = 0;\n\t}\n\teo[i] = o_;\n}\n\nint yy[N], zz[N], jj[N], zz_[N], ww[N], dp[N];\n
      \nvoid dfs2(int i, int escape) {\n\tint h, j, k, o, cntb, cntc, c, d, y, y_,
      z;\n \n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i)\n\t\t\tdfs2(j,
      0);\n\t\telse\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tdfs2(k, 1);\n\t}\n\tcntb
      = cntc = 0;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] ==
      i)\n\t\t\tcntb++;\n\t\telse {\n\t\t\tz = 1;\n\t\t\tfor (k = j; k != i; k = pp[k])\n\t\t\t\tz
      = (long long) z * zz[k] % MD;\n\t\t\tjj[cntc] = j, zz_[cntc] = z, cntc++;\n\t\t}\n\t}\n\td
      = cntb + cntc * 2 + (escape ? 1 : 0);\n\tww[0] = (long long) xx[i] * vv[d] %
      MD;\n\tfor (c = 1; c <= cntc; c++)\n\t\tww[c] = (long long) ww[c - 1] * 2 %
      MD * c % MD * xx[i] % MD * vv[d - c * 2] % MD;\n\tmemset(dp, 0, (cntc + 1) *
      sizeof *dp), dp[0] = 1;\n\tfor (h = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor
      (c = h + 1; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t}\n\ty = 0;\n\tfor (c = 0; c <= cntc; c++)\n\t\ty = (y + (long long)
      dp[c] * ww[c]) % MD;\n\tfor (o = eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif
      (pp[j] == i)\n\t\t\tyy[j] = y;\n\t}\n\tif (escape)\n\t\tzz[i] = y;\n\tfor (h
      = 0; h < cntc; h++) {\n\t\tz = zz_[h];\n\t\tfor (c = 1; c <= cntc; c++)\n\t\t\tdp[c]
      = (dp[c] - (long long) dp[c - 1] * z % MD + MD) % MD;\n\t\ty = 0;\n\t\tfor (c
      = 0; c <= cntc; c++)\n\t\t\ty = (y + (long long) dp[c] * ww[c]) % MD;\n\t\tfor
      (c = cntc; c > 0; c--)\n\t\t\tdp[c] = (dp[c] + (long long) dp[c - 1] * z) %
      MD;\n\t\tj = jj[h];\n\t\ty_ = y;\n\t\tfor (k = j; k != i; k = pp[k])\n\t\t\tyy[k]
      = (yy[k] + y_) % MD, y_ = (long long) y_ * zz[k] % MD;\n\t\tk = j, y_ = y;\n\t\tdo
      {\n\t\t\tk = qq[k];\n\t\t\tyy[k] = (yy[k] + y_) % MD, y_ = (long long) y_ *
      zz[k] % MD;\n\t\t} while (k != j);\n\t}\n}\n \nint ans[N];\n \nvoid dfs3(int
      i, int w) {\n\tint j, k, o, x;\n \n\tx = (1 - zz[i] + MD) % MD;\n\tfor (o =
      eo[i]; o--; ) {\n\t\tj = ej[i][o];\n\t\tif (pp[j] == i) {\n\t\t\tdfs3(j, (long
      long) w * yy[j] % MD);\n\t\t\tx = (x - yy[j] + MD) % MD;\n\t\t} else\n\t\t\tfor
      (k = j; k != i; k = pp[k]) {\n\t\t\t\tdfs3(k, (long long) w * yy[k] % MD);\n\t\t\t\tx
      = (x - (long long) yy[k] * (1 - zz[k] + MD) % MD + MD) % MD;\n\t\t\t}\n\t}\n\tans[i]
      = (long long) w * x % MD;\n}\n \nint main() {\n\tint t;\n \n\tinit();\n\tscanf(\"%d\",
      &t);\n\twhile (t--) {\n\t\tint n, m, h, i, j;\n \n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor
      (i = 0; i < n; i++)\n\t\t\tej[i] = (int *) malloc(2 * sizeof *ej[i]), eo[i]
      = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &xx[i]), xx[i] = (1 -
      xx[i] + MD) % MD;\n\t\tfor (h = 0; h < m; h++) {\n\t\t\tscanf(\"%d%d\", &i,
      &j), i--, j--;\n\t\t\tappend(i, j), append(j, i);\n\t\t}\n\t\tmemset(dd, 0,
      n * sizeof *dd), memset(marked, 0, n * sizeof *marked);\n\t\tdfs1(-1, 0, 1);\n\t\tmemset(yy,
      0, n * sizeof *yy), memset(zz, 0, n * sizeof *zz);\n\t\tdfs2(0, 0);\n\t\tdfs3(0,
      1);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", ans[i], i + 1 < n ?
      '' '' : ''\\n'');\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(ej[i]);\n\t}\n\treturn
      0;\n}\n\nAnother full solution by Danny Mittal:\n\nimport java.io.BufferedReader;\nimport
      java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n
      \npublic class IslandVacationBufferedReader {\n    public static final long
      MOD = 1000000007;\n    public static final long MYRIAD_FACTORIAL_INVERSE = 556156297;\n
      \n    public static void main(String[] args) throws IOException {\n        long[]
      factorial = new long[10001];\n        factorial[0] = 1;\n        for (int k
      = 1; k <= 10000; k++) {\n            factorial[k] = (((long) k) * factorial[k
      - 1]) % MOD;\n        }\n        long[] invFact = new long[10001];\n        invFact[10000]
      = MYRIAD_FACTORIAL_INVERSE;\n        for (int k = 10000; k > 0; k--) {\n            invFact[k
      - 1] = (((long) k) * invFact[k]) % MOD;\n        }\n        long[] inv = new
      long[10001];\n        for (int k = 1; k <= 10000; k++) {\n            inv[k]
      = (factorial[k - 1] * invFact[k]) % MOD;\n        }\n \n        BufferedReader
      in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder
      out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine());
      t > 0; t--) {\n            in.readLine();\n            StringTokenizer tokenizer
      = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int
      m = Integer.parseInt(tokenizer.nextToken());\n            long[] continueProbability
      = new long[n + 1];\n            List<Integer>[] adj = new List[n + 1];\n            tokenizer
      = new StringTokenizer(in.readLine());\n            for (int a = 1; a <= n; a++)
      {\n                continueProbability[a] = 1L - Long.parseLong(tokenizer.nextToken());\n                adj[a]
      = new ArrayList<>();\n            }\n            for (int j = 0; j < m; j++)
      {\n                tokenizer = new StringTokenizer(in.readLine());\n                int
      a = Integer.parseInt(tokenizer.nextToken());\n                int b = Integer.parseInt(tokenizer.nextToken());\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n
      \n            boolean[] parentIsCycle = new boolean[n + 1];\n            List<Integer>[]
      children = new List[n + 1];\n            List<Integer>[] childrenCycles = new
      List[n + 1];\n            for (int a = 1; a <= n; a++) {\n                children[a]
      = new ArrayList<>();\n                childrenCycles[a] = new ArrayList<>();\n            }\n            int[]
      cycleLeader = new int[(m / 3) + 1];\n            List<Integer>[] cycles = new
      List[(m / 3) + 1];\n            new Object() {\n                int[] seen =
      new int[n + 1];\n                int lastCycleLabel = 0;\n \n                int
      dfs(int a, int from) {\n                    seen[a] = 1;\n                    int
      result = 0;\n                    for (int b : adj[a]) {\n                        if
      (b != from && seen[b] != 2) {\n                            //System.out.println(a
      + \" -> \" + b);\n                            if (seen[b] == 1) {\n                                //System.out.println(\"seen,
      making cycle\");\n                                parentIsCycle[a] = true;\n                                result
      = ++lastCycleLabel;\n                                cycles[result] = new ArrayList<>();\n                                cycleLeader[result]
      = b;\n                                cycles[result].add(a);\n                            }
      else {\n                                int sub = dfs(b, a);\n                                if
      (sub == 0) {\n                                    children[a].add(b);\n                                }
      else {\n                                    if (cycleLeader[sub] == a) {\n                                        childrenCycles[a].add(sub);\n                                    }
      else {\n                                        parentIsCycle[a] = true;\n                                        result
      = sub;\n                                        cycles[result].add(a);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    seen[a]
      = 2;\n                    return result;\n                }\n            }.dfs(1,
      0);\n \n            long[] leaveIfEnterNode = new long[n + 1];\n            long[]
      leaveIfEnterCycle = new long[(m / 3) + 1];\n            long[][] subsetProducts
      = new long[n + 1][];\n \n            new Object() {\n \n                void
      calcNode(int a) {\n                    for (int k : childrenCycles[a]) {\n                        calcCycle(k);\n                    }\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    subsetProducts[a]
      = new long[amtChildCycles + 1];\n                    subsetProducts[a][0] =
      1;\n                    int j = 0;\n                    for (int k : childrenCycles[a])
      {\n                        j++;\n                        for (int l = j; l >
      0; l--) {\n                            subsetProducts[a][l] += leaveIfEnterCycle[k]
      * subsetProducts[a][l - 1];\n                            subsetProducts[a][l]
      %= MOD;\n                        }\n                    }\n \n                    long
      base = 1;\n                    for (int x = 0; x <= amtChildCycles; x++) {\n                        base
      *= continueProbability[a];\n                        base %= MOD;\n                        base
      *= inv[amtBridges + (2 * (amtChildCycles - x))];\n                        base
      %= MOD;\n                        if (x > 0) {\n                            base
      *= (long) x;\n                            base %= MOD;\n                        }\n                        leaveIfEnterNode[a]
      += base * subsetProducts[a][x];\n                        leaveIfEnterNode[a]
      %= MOD;\n                        base *= 2L;\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    leaveIfEnterCycle[k]
      = 1;\n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                        leaveIfEnterCycle[k]
      *= leaveIfEnterNode[a];\n                        leaveIfEnterCycle[k] %= MOD;\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] enterNode = new long[n + 1];\n            long[] enterCycle
      = new long[(m / 3) + 1];\n \n            enterNode[1] = 1;\n            new
      Object() {\n                long[] local = new long[(m / 3) + 1];\n \n                void
      calcNode(int a) {\n                    for (int b : children[a]) {\n                        enterNode[b]
      = (enterNode[a] * leaveIfEnterNode[a]) % MOD;\n                        calcNode(b);\n                    }\n
      \n                    int amtBridges = children[a].size() + (parentIsCycle[a]
      ? 1 : 0);\n                    int amtChildCycles = childrenCycles[a].size();\n                    for
      (int k : childrenCycles[a]) {\n                        local[0] = 1;\n                        long
      base = enterNode[a];\n                        for (int x = 0; x < amtChildCycles;
      x++) {\n                            base *= continueProbability[a];\n                            base
      %= MOD;\n                            base *= 2L * inv[amtBridges + (2 * (amtChildCycles
      - x))];\n                            base %= MOD;\n                            if
      (x > 0) {\n                                base *= (long) x;\n                                base
      %= MOD;\n                            }\n \n                            enterCycle[k]
      += base * local[x];\n                            enterCycle[k] %= MOD;\n \n                            local[x
      + 1] = subsetProducts[a][x + 1] - (local[x] * leaveIfEnterCycle[k]);\n                            local[x
      + 1] %= MOD;\n                        }\n                        calcCycle(k);\n                    }\n                }\n
      \n                void calcCycle(int k) {\n                    long prob = (inv[2]
      * enterCycle[k]) % MOD;\n                    for (int a : cycles[k]) {\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    prob = (inv[2] * enterCycle[k])
      % MOD;\n                    for (int j = cycles[k].size() - 1; j >= 0; j--)
      {\n                        int a = cycles[k].get(j);\n                        enterNode[a]
      += prob;\n                        prob *= leaveIfEnterNode[a];\n                        prob
      %= MOD;\n                    }\n \n                    for (int a : cycles[k])
      {\n                        enterNode[a] %= MOD;\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            long[] endInSubtreeNode = new long[n + 1];\n            long[]
      endInSubtreeCycle = new long[(m / 3) + 1];\n            long[] answers = new
      long[n + 1];\n \n            new Object() {\n \n                void calcNode(int
      a) {\n                    endInSubtreeNode[a] = enterNode[a] * (1L - (parentIsCycle[a]
      ? leaveIfEnterNode[a] : 0L));\n                    endInSubtreeNode[a] %= MOD;\n
      \n                    answers[a] = endInSubtreeNode[a];\n                    for
      (int b : children[a]) {\n                        calcNode(b);\n                        answers[a]
      -= endInSubtreeNode[b];\n                    }\n                    for (int
      k : childrenCycles[a]) {\n                        calcCycle(k);\n                        answers[a]
      -= endInSubtreeCycle[k];\n                    }\n                    answers[a]
      %= MOD;\n                    answers[a] += MOD;\n                    answers[a]
      %= MOD;\n                }\n \n                void calcCycle(int k) {\n                    endInSubtreeCycle[k]
      = enterCycle[k] * (1L - leaveIfEnterCycle[k]);\n                    endInSubtreeCycle[k]
      %= MOD;\n \n                    for (int a : cycles[k]) {\n                        calcNode(a);\n                    }\n                }\n            }.calcNode(1);\n
      \n            for (int a = 1; a <= n; a++) {\n                out.append(answers[a]).append(''
      '');\n            }\n            out.append(''\\n'');\n        }\n        System.out.print(out);\n    }\n}\n\nBonus:
      Solve this problem in $O(N\\log^2N)$ time using FFT.\n    </solution>\n    <Examples>\n    Approach
      this new question with similar sophistication.", "tools": [{"name": "writePython",
      "description": "Write python code that resolves the problem.", "input_schema":
      {"properties": {"reasoning": {"description": "Conceptual solution.", "type":
      "string"}, "pseudocode": {"description": "Detailed English pseudocode.", "type":
      "string"}, "code": {"description": "Valid Python 3 solution to the problem",
      "type": "string"}}, "required": ["reasoning", "pseudocode", "code"], "type":
      "object"}}]}'
    headers:
      accept:
      - application/json
      accept-encoding:
      - gzip, deflate
      anthropic-version:
      - '2023-06-01'
      connection:
      - keep-alive
      content-length:
      - '62006'
      content-type:
      - application/json
      host:
      - api.anthropic.com
      user-agent:
      - Anthropic/Python 0.34.2
      x-stainless-arch:
      - arm64
      x-stainless-async:
      - 'false'
      x-stainless-lang:
      - python
      x-stainless-os:
      - MacOS
      x-stainless-package-version:
      - 0.34.2
      x-stainless-runtime:
      - CPython
      x-stainless-runtime-version:
      - 3.12.4
    method: POST
    uri: https://api.anthropic.com/v1/messages
  response:
    body:
      string: !!binary |
        H4sIAAAAAAAAA7xXYXMbNRD9K4/rdGKnZ2O7pRQP7gwUSsFJgKTAQK+TUe7WPuE76SLpnJpO/juz
        0t3ZTtLQGRg+JSftrrRv3z6t30cyi6ZRaZfno/H4jC6vXl6ulP3j6bF7cvXXV8+eyd+iOHKbitiK
        rBVLiuLI6IIXhLXSOqFcFEelzqiIplFaiDqjweOBrmo7mIwmT0aTyRdRHKVaOVIumr553wZ09I5d
        /Z9p9KXLpVpJtXyeqNe5UCtsdI2FNnA5ISMnZEEZLgyJVaavFITKYOvlkqyTWtkhftf1gSEYucwd
        XC4crgipUNCVk6X8i3ykdJMWPh6l7IfaSrX0O04bp6UlHzkXhiCKpTbS5eUQr8jQgUWur9qopc7k
        YuM9RVUZLdJ8mqhEjYc4JZFBqqp2FlI5DWGM2FgcxThFbzSQKqN3lPX9SWeJmgzxQqs1GQdDFTnp
        M8I8ODvtRAHrqLKYHx6jrhZGK5eox0P8Yu+6t9NNgiHbaaIADPANLaQiLMmdK3rneus+WxpytVHg
        FfQqbVwMf78+GrfXVxqVlsqRsbCjAPwYF9rlsE4YB+HQG8UY9RuPb0WaQzoyghOZhkC8cazXxCEu
        Nhj7jGIfaYNJyK8z/H4BuqxFETf1WuhaZXGofpdNaqgk5TxOoL0zE/VkyEF2vNGb4zlGEAtHBoXW
        Vb8F5qVUWWNakFq6HCbXDTO6hBvbU8rqlDBn6OZ46C0T9dkQZ7KsC+EIhkohFfvOm6otjC5hR4l6
        ytzwcC+kEgUYbvTGHSGYP69zwoo2ELai1FkIwwUc4JVQWdFydYS1xTgUitfYwJeXP7oC79Z3r7Rs
        /kIbQ6krNij1+sM90FaeXRin1nIProBp11Rs63EKIFRGV2SKDRfa5Jp3G7B4fwvXDbAS9Zt0OR9m
        KXSbTH1xbRzuKktCqsuqoHfSbSDLyug1WU76x94xHuGkH4fiVSKl3eUhjsihJPYpAolcLrlZ8dPG
        5VoNE/Xlp50iRdfxVrW0Ls5ryzroxZO/6/PR+Lucvn756/pVWv7580Ie0eSH9beXrHxKlOx3ZaSj
        EJxdWRyi6fvIkLCas4+mEWsMpPXJtZqVweqi/keluqlqnXJNdykVAA6EamWK4/nbBLHpxGlPs7xO
        4R6hui1TXp7uVRw++Q7VsU448v3rxe1O8Ylbzu5qSSdMnZzcEoVWW1xOG5RELoZosJO2gY+yjxOY
        z7zA7Lh/lMrcah3Wj4sNRLYWKm1SqpWTBaTzV7Sck1gKqfYV6Gbf7CqSV5pOkPjMe0Tp806U2HAr
        TDHSUGv2uhDpig/otKrl1a0utF2XYcAvQ6mtw+Tw+PBki57deaI6RHxXq86FgXnUSWxDXUZ1yEef
        +Zb+wLmO7bWhHXIHNnvXF7qshKHMkzYnVIbWUte2e8bjIAZirWVmfSRGQBQFfBLMxZIyydB6stqg
        MjwUXNYyXRUb2JWsoNdkQmp2GMVRZanOdKozloOTGMcx5pg191N1eUEGeuGhtzEsXdak0pYnMVvs
        NR0S5XtztpchRyho4T4NY5AP5qcoT9/w3ox23puzfX92z6RpVCTNhRGpb72DowOf5MHpAWPIF5/j
        EMfAg5Yme7dzun3RE5XRYlcCfD80LY8Z1vwpFzh7I99iNuOTQsd4cTj3V57h6A3/85Y3qLB0h8Xp
        1sIvc+yexCOM+3iIY15vn8LOLW5M/cNrR5hxr826YSZRD+6erhbbgSFRV7kseCB4jpG/lo/T5WvD
        VOTjdovb3XHfb88xmGHcIMEB+CZNks3Qw5eRi3DO3ljETGg3vMuD3fsF+vjsc43mkFtX9CNaSMSO
        8MnO6XdmE4I9aqIFMjTCw9e0t0ehPc3BDdSAD+K2BSZRlZGKN96M3oay7nDvlj753xw3Wq0UVU8q
        /9RUtev1h7YqpOv1famPMANHPsRJok53P7h9JD8BRqgl9U4Cg4sY5v6YwJHnNIqBz+A0fJlBk0/X
        e1uv0FuHM+brf9o4+L8753/qCv73Bv3v4/m/o/nDWeA4Prbr72NvdH39No6s09V5GAL3h0u/0T4C
        0VTVRRFHtf8FPn0f5sdzp1ekbDSdTJ49fRpHuna7q+Mnjx9fX/8NAAD//wMAPE6jj+QPAAA=
    headers:
      CF-Cache-Status:
      - DYNAMIC
      CF-RAY:
      - 8c5b9786adae16a6-SJC
      Connection:
      - keep-alive
      Content-Encoding:
      - gzip
      Content-Type:
      - application/json
      Date:
      - Thu, 19 Sep 2024 18:21:40 GMT
      Server:
      - cloudflare
      Transfer-Encoding:
      - chunked
      X-Robots-Tag:
      - none
      request-id:
      - req_01LFecoPEXxexBVGabDvGu9k
      via:
      - 1.1 google
      x-cloud-trace-context:
      - 5a5d6d578b3b2a5043e8260a7ef4d813
    status:
      code: 200
      message: OK
version: 1
